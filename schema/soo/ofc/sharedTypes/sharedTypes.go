//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sharedTypes

import (
	_g "encoding/xml"
	_gbe "fmt"
	_gb "regexp"
)

func _ed(_ag bool) uint8 {
	if _ag {
		return 1
	}
	return 0
}

const ST_PositiveFixedPercentagePattern = "\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039\u005d\u003f\u0029\u0029\u0028\u005c\u002e[\u0030\u002d\u0039\u005d\u005b0\u002d\u0039]\u003f\u0029\u003f\u0025"

func (_d ST_TwipsMeasure) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _d.ST_UnsignedDecimalNumber != nil {
		e.EncodeToken(_g.CharData(_gbe.Sprintf("\u0025\u0064", *_d.ST_UnsignedDecimalNumber)))
	}
	if _d.ST_PositiveUniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_d.ST_PositiveUniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_cd *ST_AlgClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bdd, _ffg := d.Token()
	if _ffg != nil {
		return _ffg
	}
	if _ge, _cb := _bdd.(_g.EndElement); _cb && _ge.Name == start.Name {
		*_cd = 1
		return nil
	}
	if _fbb, _edg := _bdd.(_g.CharData); !_edg {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bdd)
	} else {
		switch string(_fbb) {
		case "":
			*_cd = 0
		case "\u0068\u0061\u0073\u0068":
			*_cd = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_cd = 2
		}
	}
	_bdd, _ffg = d.Token()
	if _ffg != nil {
		return _ffg
	}
	if _gff, _gbece := _bdd.(_g.EndElement); _gbece && _gff.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bdd)
}
func (_fdbe ST_AlgType) String() string {
	switch _fdbe {
	case 0:
		return ""
	case 1:
		return "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}
func (_bcf ST_TrueFalseBlank) String() string {
	switch _bcf {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	case 6:
		return "\u0054\u0072\u0075\u0065"
	case 7:
		return "\u0046\u0061\u006cs\u0065"
	}
	return ""
}

const (
	ST_CryptProvUnset   ST_CryptProv = 0
	ST_CryptProvRsaAES  ST_CryptProv = 1
	ST_CryptProvRsaFull ST_CryptProv = 2
	ST_CryptProvCustom  ST_CryptProv = 3
)
const ST_GuidPattern = "\u005c\u007b\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b\u0038\u007d\u002d\u005b\u0030\u002d9\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030-\u0039\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b4\u007d\u002d\u005b\u0030\u002d\u0039A\u002d\u0046]\u007b\u00312\u007d\\\u007d"

// ST_TwipsMeasure is a union type
type ST_TwipsMeasure struct {
	ST_UnsignedDecimalNumber    *uint64
	ST_PositiveUniversalMeasure *string
}

func (_ef *ST_AlgType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dg, _fc := d.Token()
	if _fc != nil {
		return _fc
	}
	if _fdb, _bba := _dg.(_g.EndElement); _bba && _fdb.Name == start.Name {
		*_ef = 1
		return nil
	}
	if _efa, _cf := _dg.(_g.CharData); !_cf {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dg)
	} else {
		switch string(_efa) {
		case "":
			*_ef = 0
		case "\u0074y\u0070\u0065\u0041\u006e\u0079":
			*_ef = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_ef = 2
		}
	}
	_dg, _fc = d.Token()
	if _fc != nil {
		return _fc
	}
	if _adc, _ab := _dg.(_g.EndElement); _ab && _adc.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dg)
}
func (_faf *ST_AlgType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_faf = 0
	case "\u0074y\u0070\u0065\u0041\u006e\u0079":
		*_faf = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_faf = 2
	}
	return nil
}
func (_gg ST_CalendarType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_gg.String(), start)
}
func (_age *ST_TrueFalse) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fcf, _ec := d.Token()
	if _ec != nil {
		return _ec
	}
	if _ddc, _bda := _fcf.(_g.EndElement); _bda && _ddc.Name == start.Name {
		*_age = 1
		return nil
	}
	if _cfe, _fafc := _fcf.(_g.CharData); !_fafc {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fcf)
	} else {
		switch string(_cfe) {
		case "":
			*_age = 0
		case "\u0074":
			*_age = 1
		case "\u0066":
			*_age = 2
		case "\u0074\u0072\u0075\u0065":
			*_age = 3
		case "\u0066\u0061\u006cs\u0065":
			*_age = 4
		}
	}
	_fcf, _ec = d.Token()
	if _ec != nil {
		return _ec
	}
	if _bddf, _bbe := _fcf.(_g.EndElement); _bbe && _bddf.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fcf)
}
func (_dd *ST_CryptProv) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dd = 0
	case "\u0072\u0073\u0061\u0041\u0045\u0053":
		*_dd = 1
	case "\u0072s\u0061\u0046\u0075\u006c\u006c":
		*_dd = 2
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_dd = 3
	}
	return nil
}
func (_gga ST_TrueFalse) Validate() error { return _gga.ValidateWithPath("") }
func (_deg ST_AlgClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_agaf := _g.Attr{}
	_agaf.Name = name
	switch _deg {
	case ST_AlgClassUnset:
		_agaf.Value = ""
	case ST_AlgClassHash:
		_agaf.Value = "\u0068\u0061\u0073\u0068"
	case ST_AlgClassCustom:
		_agaf.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _agaf, nil
}
func (_ga *ST_OnOff) ValidateWithPath(path string) error {
	_gc := []string{}
	if _ga.Bool != nil {
		_gc = append(_gc, "\u0042\u006f\u006f\u006c")
	}
	if _ga.ST_OnOff1 != ST_OnOff1Unset {
		_gc = append(_gc, "\u0053T\u005f\u004f\u006e\u004f\u0066\u00661")
	}
	if len(_gc) > 1 {
		return _gbe.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _gc)
	}
	return nil
}
func (_ffcf ST_TrueFalse) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ffcf.String(), start)
}
func (_bd ST_CalendarType) Validate() error { return _bd.ValidateWithPath("") }

var ST_PositiveFixedPercentagePatternRe = _gb.MustCompile(ST_PositiveFixedPercentagePattern)

func (_ege ST_OnOff1) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gef := _g.Attr{}
	_gef.Name = name
	switch _ege {
	case ST_OnOff1Unset:
		_gef.Value = ""
	case ST_OnOff1On:
		_gef.Value = "\u006f\u006e"
	case ST_OnOff1Off:
		_gef.Value = "\u006f\u0066\u0066"
	}
	return _gef, nil
}
func (_fba ST_ConformanceClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fba.String(), start)
}

const (
	ST_OnOff1Unset ST_OnOff1 = 0
	ST_OnOff1On    ST_OnOff1 = 1
	ST_OnOff1Off   ST_OnOff1 = 2
)

func (_eeg ST_ConformanceClass) ValidateWithPath(path string) error {
	switch _eeg {
	case 0, 1, 2:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_eeg))
	}
	return nil
}
func (_db ST_CryptProv) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_db.String(), start)
}
func (_fcdg ST_VerticalAlignRun) ValidateWithPath(path string) error {
	switch _fcdg {
	case 0, 1, 2, 3:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_fcdg))
	}
	return nil
}

const (
	ST_ConformanceClassUnset        ST_ConformanceClass = 0
	ST_ConformanceClassStrict       ST_ConformanceClass = 1
	ST_ConformanceClassTransitional ST_ConformanceClass = 2
)

func (_bed ST_TwipsMeasure) String() string {
	if _bed.ST_UnsignedDecimalNumber != nil {
		return _gbe.Sprintf("\u0025\u0076", *_bed.ST_UnsignedDecimalNumber)
	}
	if _bed.ST_PositiveUniversalMeasure != nil {
		return _gbe.Sprintf("\u0025\u0076", *_bed.ST_PositiveUniversalMeasure)
	}
	return ""
}
func (_fbf ST_YAlign) Validate() error { return _fbf.ValidateWithPath("") }
func (_abg ST_AlgType) ValidateWithPath(path string) error {
	switch _abg {
	case 0, 1, 2:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_abg))
	}
	return nil
}
func (_fg ST_AlgType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fg.String(), start)
}
func (_eb *ST_YAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cda, _ecg := d.Token()
	if _ecg != nil {
		return _ecg
	}
	if _faae, _daa := _cda.(_g.EndElement); _daa && _faae.Name == start.Name {
		*_eb = 1
		return nil
	}
	if _bge, _ece := _cda.(_g.CharData); !_ece {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cda)
	} else {
		switch string(_bge) {
		case "":
			*_eb = 0
		case "\u0069\u006e\u006c\u0069\u006e\u0065":
			*_eb = 1
		case "\u0074\u006f\u0070":
			*_eb = 2
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_eb = 3
		case "\u0062\u006f\u0074\u0074\u006f\u006d":
			*_eb = 4
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_eb = 5
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_eb = 6
		}
	}
	_cda, _ecg = d.Token()
	if _ecg != nil {
		return _ecg
	}
	if _egcg, _fee := _cda.(_g.EndElement); _fee && _egcg.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cda)
}
func (_b ST_OnOff) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _b.Bool != nil {
		e.EncodeToken(_g.CharData(_gbe.Sprintf("\u0025\u0064", _ed(*_b.Bool))))
	}
	if _b.ST_OnOff1 != ST_OnOff1Unset {
		e.EncodeToken(_g.CharData(_b.ST_OnOff1.String()))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

const ST_PercentagePattern = "-\u003f[\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e[\u0030\u002d\u0039\u005d+)\u003f\u0025"

func (_fda ST_CryptProv) String() string {
	switch _fda {
	case 0:
		return ""
	case 1:
		return "\u0072\u0073\u0061\u0041\u0045\u0053"
	case 2:
		return "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case 3:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

type ST_VerticalAlignRun byte

func (_afa ST_XAlign) ValidateWithPath(path string) error {
	switch _afa {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_afa))
	}
	return nil
}

type ST_AlgType byte

func (_egc *ST_TrueFalse) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_egc = 0
	case "\u0074":
		*_egc = 1
	case "\u0066":
		*_egc = 2
	case "\u0074\u0072\u0075\u0065":
		*_egc = 3
	case "\u0066\u0061\u006cs\u0065":
		*_egc = 4
	}
	return nil
}
func (_fe ST_AlgClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fe.String(), start)
}
func (_e *ST_OnOff) Validate() error { return _e.ValidateWithPath("") }
func (_ccd ST_TrueFalseBlank) ValidateWithPath(path string) error {
	switch _ccd {
	case 0, 1, 2, 3, 4, 6, 7:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ccd))
	}
	return nil
}
func (_ca *ST_VerticalAlignRun) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_ca = 0
	case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
		*_ca = 1
	case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
		*_ca = 2
	case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
		*_ca = 3
	}
	return nil
}

type ST_TrueFalseBlank byte

const (
	ST_VerticalAlignRunUnset       ST_VerticalAlignRun = 0
	ST_VerticalAlignRunBaseline    ST_VerticalAlignRun = 1
	ST_VerticalAlignRunSuperscript ST_VerticalAlignRun = 2
	ST_VerticalAlignRunSubscript   ST_VerticalAlignRun = 3
)

func (_bgbg ST_ConformanceClass) Validate() error { return _bgbg.ValidateWithPath("") }
func (_cgc *ST_XAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cbab, _gegbc := d.Token()
	if _gegbc != nil {
		return _gegbc
	}
	if _eaef, _ceb := _cbab.(_g.EndElement); _ceb && _eaef.Name == start.Name {
		*_cgc = 1
		return nil
	}
	if _bdg, _dege := _cbab.(_g.CharData); !_dege {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cbab)
	} else {
		switch string(_bdg) {
		case "":
			*_cgc = 0
		case "\u006c\u0065\u0066\u0074":
			*_cgc = 1
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_cgc = 2
		case "\u0072\u0069\u0067h\u0074":
			*_cgc = 3
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_cgc = 4
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_cgc = 5
		}
	}
	_cbab, _gegbc = d.Token()
	if _gegbc != nil {
		return _gegbc
	}
	if _ddb, _fdd := _cbab.(_g.EndElement); _fdd && _ddb.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cbab)
}
func (_dc ST_OnOff1) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dc.String(), start)
}
func (_fb ST_CalendarType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fbe := _g.Attr{}
	_fbe.Name = name
	switch _fb {
	case ST_CalendarTypeUnset:
		_fbe.Value = ""
	case ST_CalendarTypeGregorian:
		_fbe.Value = "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case ST_CalendarTypeGregorianUs:
		_fbe.Value = "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case ST_CalendarTypeGregorianMeFrench:
		_fbe.Value = "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeGregorianArabic:
		_fbe.Value = "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case ST_CalendarTypeHijri:
		_fbe.Value = "\u0068\u0069\u006ar\u0069"
	case ST_CalendarTypeHebrew:
		_fbe.Value = "\u0068\u0065\u0062\u0072\u0065\u0077"
	case ST_CalendarTypeTaiwan:
		_fbe.Value = "\u0074\u0061\u0069\u0077\u0061\u006e"
	case ST_CalendarTypeJapan:
		_fbe.Value = "\u006a\u0061\u0070a\u006e"
	case ST_CalendarTypeThai:
		_fbe.Value = "\u0074\u0068\u0061\u0069"
	case ST_CalendarTypeKorea:
		_fbe.Value = "\u006b\u006f\u0072e\u0061"
	case ST_CalendarTypeSaka:
		_fbe.Value = "\u0073\u0061\u006b\u0061"
	case ST_CalendarTypeGregorianXlitEnglish:
		_fbe.Value = "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case ST_CalendarTypeGregorianXlitFrench:
		_fbe.Value = "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeNone:
		_fbe.Value = "\u006e\u006f\u006e\u0065"
	}
	return _fbe, nil
}
func (_ccb ST_CalendarType) ValidateWithPath(path string) error {
	switch _ccb {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ccb))
	}
	return nil
}
func (_aed ST_TrueFalseBlank) Validate() error { return _aed.ValidateWithPath("") }
func (_dec ST_AlgClass) String() string {
	switch _dec {
	case 0:
		return ""
	case 1:
		return "\u0068\u0061\u0073\u0068"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}
func (_ded ST_TrueFalse) ValidateWithPath(path string) error {
	switch _ded {
	case 0, 1, 2, 3, 4:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ded))
	}
	return nil
}

const (
	ST_YAlignUnset   ST_YAlign = 0
	ST_YAlignInline  ST_YAlign = 1
	ST_YAlignTop     ST_YAlign = 2
	ST_YAlignCenter  ST_YAlign = 3
	ST_YAlignBottom  ST_YAlign = 4
	ST_YAlignInside  ST_YAlign = 5
	ST_YAlignOutside ST_YAlign = 6
)

var ST_GuidPatternRe = _gb.MustCompile(ST_GuidPattern)

func (_becg ST_XAlign) Validate() error { return _becg.ValidateWithPath("") }
func (_cde ST_AlgType) Validate() error { return _cde.ValidateWithPath("") }
func (_cga *ST_ConformanceClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gabd, _adf := d.Token()
	if _adf != nil {
		return _adf
	}
	if _gaag, _aab := _gabd.(_g.EndElement); _aab && _gaag.Name == start.Name {
		*_cga = 1
		return nil
	}
	if _ggf, _eagb := _gabd.(_g.CharData); !_eagb {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gabd)
	} else {
		switch string(_ggf) {
		case "":
			*_cga = 0
		case "\u0073\u0074\u0072\u0069\u0063\u0074":
			*_cga = 1
		case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
			*_cga = 2
		}
	}
	_gabd, _adf = d.Token()
	if _adf != nil {
		return _adf
	}
	if _bdec, _ceee := _gabd.(_g.EndElement); _ceee && _bdec.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gabd)
}

type ST_ConformanceClass byte

func (_cff ST_VerticalAlignRun) String() string {
	switch _cff {
	case 0:
		return ""
	case 1:
		return "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case 2:
		return "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case 3:
		return "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return ""
}
func (_bee ST_OnOff1) String() string {
	switch _bee {
	case 0:
		return ""
	case 1:
		return "\u006f\u006e"
	case 2:
		return "\u006f\u0066\u0066"
	}
	return ""
}

var ST_FixedPercentagePatternRe = _gb.MustCompile(ST_FixedPercentagePattern)
var ST_PositiveUniversalMeasurePatternRe = _gb.MustCompile(ST_PositiveUniversalMeasurePattern)

func (_bde ST_AlgType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_eag := _g.Attr{}
	_eag.Name = name
	switch _bde {
	case ST_AlgTypeUnset:
		_eag.Value = ""
	case ST_AlgTypeTypeAny:
		_eag.Value = "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case ST_AlgTypeCustom:
		_eag.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _eag, nil
}
func (_aefa *ST_ConformanceClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_aefa = 0
	case "\u0073\u0074\u0072\u0069\u0063\u0074":
		*_aefa = 1
	case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
		*_aefa = 2
	}
	return nil
}
func (_dfd ST_CryptProv) ValidateWithPath(path string) error {
	switch _dfd {
	case 0, 1, 2, 3:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dfd))
	}
	return nil
}
func (_bfe ST_YAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bfe.String(), start)
}

const (
	ST_CalendarTypeUnset                ST_CalendarType = 0
	ST_CalendarTypeGregorian            ST_CalendarType = 1
	ST_CalendarTypeGregorianUs          ST_CalendarType = 2
	ST_CalendarTypeGregorianMeFrench    ST_CalendarType = 3
	ST_CalendarTypeGregorianArabic      ST_CalendarType = 4
	ST_CalendarTypeHijri                ST_CalendarType = 5
	ST_CalendarTypeHebrew               ST_CalendarType = 6
	ST_CalendarTypeTaiwan               ST_CalendarType = 7
	ST_CalendarTypeJapan                ST_CalendarType = 8
	ST_CalendarTypeThai                 ST_CalendarType = 9
	ST_CalendarTypeKorea                ST_CalendarType = 10
	ST_CalendarTypeSaka                 ST_CalendarType = 11
	ST_CalendarTypeGregorianXlitEnglish ST_CalendarType = 12
	ST_CalendarTypeGregorianXlitFrench  ST_CalendarType = 13
	ST_CalendarTypeNone                 ST_CalendarType = 14
)
const ST_FixedPercentagePattern = "-\u003f\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039]\u003f\u0029\u0029\u0028\u005c\u002e\u005b\u0030\u002d\u0039][\u0030\u002d\u0039]\u003f)\u003f\u0025"

func (_ffc ST_CryptProv) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ggg := _g.Attr{}
	_ggg.Name = name
	switch _ffc {
	case ST_CryptProvUnset:
		_ggg.Value = ""
	case ST_CryptProvRsaAES:
		_ggg.Value = "\u0072\u0073\u0061\u0041\u0045\u0053"
	case ST_CryptProvRsaFull:
		_ggg.Value = "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case ST_CryptProvCustom:
		_ggg.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _ggg, nil
}
func (_ee ST_XAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ee.String(), start)
}

const (
	ST_TrueFalseBlankUnset  ST_TrueFalseBlank = 0
	ST_TrueFalseBlankT      ST_TrueFalseBlank = 1
	ST_TrueFalseBlankF      ST_TrueFalseBlank = 2
	ST_TrueFalseBlankTrue   ST_TrueFalseBlank = 3
	ST_TrueFalseBlankFalse  ST_TrueFalseBlank = 4
	ST_TrueFalseBlankTrue_  ST_TrueFalseBlank = 6
	ST_TrueFalseBlankFalse_ ST_TrueFalseBlank = 7
)

func (_gab ST_TrueFalseBlank) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ac := _g.Attr{}
	_ac.Name = name
	switch _gab {
	case ST_TrueFalseBlankUnset:
		_ac.Value = ""
	case ST_TrueFalseBlankT:
		_ac.Value = "\u0074"
	case ST_TrueFalseBlankF:
		_ac.Value = "\u0066"
	case ST_TrueFalseBlankTrue:
		_ac.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse:
		_ac.Value = "\u0066\u0061\u006cs\u0065"
	case ST_TrueFalseBlankTrue_:
		_ac.Value = "\u0054\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse_:
		_ac.Value = "\u0046\u0061\u006cs\u0065"
	}
	return _ac, nil
}
func (_be *ST_TwipsMeasure) ValidateWithPath(path string) error {
	_fa := []string{}
	if _be.ST_UnsignedDecimalNumber != nil {
		_fa = append(_fa, "\u0053T\u005f\u0055\u006e\u0073\u0069\u0067\u006e\u0065\u0064\u0044\u0065c\u0069\u006d\u0061\u006c\u004e\u0075\u006d\u0062\u0065\u0072")
	}
	if _be.ST_PositiveUniversalMeasure != nil {
		_fa = append(_fa, "S\u0054\u005f\u0050\u006f\u0073\u0069t\u0069\u0076\u0065\u0055\u006e\u0069\u0076\u0065\u0072s\u0061\u006c\u004de\u0061s\u0075\u0072\u0065")
	}
	if len(_fa) > 1 {
		return _gbe.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _fa)
	}
	return nil
}
func (_aae *ST_TrueFalseBlank) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_aae = 0
	case "\u0074":
		*_aae = 1
	case "\u0066":
		*_aae = 2
	case "\u0074\u0072\u0075\u0065":
		*_aae = 3
	case "\u0066\u0061\u006cs\u0065":
		*_aae = 4
	case "\u0054\u0072\u0075\u0065":
		*_aae = 6
	case "\u0046\u0061\u006cs\u0065":
		*_aae = 7
	}
	return nil
}
func (_c ST_OnOff) String() string {
	if _c.Bool != nil {
		return _gbe.Sprintf("\u0025\u0076", *_c.Bool)
	}
	if _c.ST_OnOff1 != ST_OnOff1Unset {
		return _c.ST_OnOff1.String()
	}
	return ""
}
func (_gce ST_TrueFalse) String() string {
	switch _gce {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}
func (_cbg ST_YAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_gbc := _g.Attr{}
	_gbc.Name = name
	switch _cbg {
	case ST_YAlignUnset:
		_gbc.Value = ""
	case ST_YAlignInline:
		_gbc.Value = "\u0069\u006e\u006c\u0069\u006e\u0065"
	case ST_YAlignTop:
		_gbc.Value = "\u0074\u006f\u0070"
	case ST_YAlignCenter:
		_gbc.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_YAlignBottom:
		_gbc.Value = "\u0062\u006f\u0074\u0074\u006f\u006d"
	case ST_YAlignInside:
		_gbc.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_YAlignOutside:
		_gbc.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _gbc, nil
}

type ST_YAlign byte

func (_cdf ST_TrueFalseBlank) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cdf.String(), start)
}

type ST_XAlign byte

func (_faa ST_OnOff1) Validate() error { return _faa.ValidateWithPath("") }

var ST_PositivePercentagePatternRe = _gb.MustCompile(ST_PositivePercentagePattern)

func (_fce *ST_OnOff1) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_cbd, _ba := d.Token()
	if _ba != nil {
		return _ba
	}
	if _cgb, _ce := _cbd.(_g.EndElement); _ce && _cgb.Name == start.Name {
		*_fce = 1
		return nil
	}
	if _gfc, _fcd := _cbd.(_g.CharData); !_fcd {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cbd)
	} else {
		switch string(_gfc) {
		case "":
			*_fce = 0
		case "\u006f\u006e":
			*_fce = 1
		case "\u006f\u0066\u0066":
			*_fce = 2
		}
	}
	_cbd, _ba = d.Token()
	if _ba != nil {
		return _ba
	}
	if _bc, _fcc := _cbd.(_g.EndElement); _fcc && _bc.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cbd)
}
func (_bab ST_XAlign) String() string {
	switch _bab {
	case 0:
		return ""
	case 1:
		return "\u006c\u0065\u0066\u0074"
	case 2:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 5:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}

var ST_UniversalMeasurePatternRe = _gb.MustCompile(ST_UniversalMeasurePattern)

const (
	ST_XAlignUnset   ST_XAlign = 0
	ST_XAlignLeft    ST_XAlign = 1
	ST_XAlignCenter  ST_XAlign = 2
	ST_XAlignRight   ST_XAlign = 3
	ST_XAlignInside  ST_XAlign = 4
	ST_XAlignOutside ST_XAlign = 5
)

type ST_CryptProv byte

func (_af *ST_VerticalAlignRun) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ead, _ccdf := d.Token()
	if _ccdf != nil {
		return _ccdf
	}
	if _cee, _dacg := _ead.(_g.EndElement); _dacg && _cee.Name == start.Name {
		*_af = 1
		return nil
	}
	if _egf, _ggaf := _ead.(_g.CharData); !_ggaf {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _ead)
	} else {
		switch string(_egf) {
		case "":
			*_af = 0
		case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
			*_af = 1
		case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
			*_af = 2
		case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
			*_af = 3
		}
	}
	_ead, _ccdf = d.Token()
	if _ccdf != nil {
		return _ccdf
	}
	if _dge, _ageb := _ead.(_g.EndElement); _ageb && _dge.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _ead)
}
func (_ff *ST_CalendarType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gcf, _df := d.Token()
	if _df != nil {
		return _df
	}
	if _gbg, _gbec := _gcf.(_g.EndElement); _gbec && _gbg.Name == start.Name {
		*_ff = 1
		return nil
	}
	if _bb, _aga := _gcf.(_g.CharData); !_aga {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gcf)
	} else {
		switch string(_bb) {
		case "":
			*_ff = 0
		case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
			*_ff = 1
		case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
			*_ff = 2
		case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
			*_ff = 3
		case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
			*_ff = 4
		case "\u0068\u0069\u006ar\u0069":
			*_ff = 5
		case "\u0068\u0065\u0062\u0072\u0065\u0077":
			*_ff = 6
		case "\u0074\u0061\u0069\u0077\u0061\u006e":
			*_ff = 7
		case "\u006a\u0061\u0070a\u006e":
			*_ff = 8
		case "\u0074\u0068\u0061\u0069":
			*_ff = 9
		case "\u006b\u006f\u0072e\u0061":
			*_ff = 10
		case "\u0073\u0061\u006b\u0061":
			*_ff = 11
		case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
			*_ff = 12
		case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
			*_ff = 13
		case "\u006e\u006f\u006e\u0065":
			*_ff = 14
		}
	}
	_gcf, _df = d.Token()
	if _df != nil {
		return _df
	}
	if _de, _dfa := _gcf.(_g.EndElement); _dfa && _de.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gcf)
}
func (_ae ST_CryptProv) Validate() error { return _ae.ValidateWithPath("") }
func (_aa *ST_CryptProv) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bf, _eg := d.Token()
	if _eg != nil {
		return _eg
	}
	if _dac, _ddg := _bf.(_g.EndElement); _ddg && _dac.Name == start.Name {
		*_aa = 1
		return nil
	}
	if _fd, _bfb := _bf.(_g.CharData); !_bfb {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bf)
	} else {
		switch string(_fd) {
		case "":
			*_aa = 0
		case "\u0072\u0073\u0061\u0041\u0045\u0053":
			*_aa = 1
		case "\u0072s\u0061\u0046\u0075\u006c\u006c":
			*_aa = 2
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_aa = 3
		}
	}
	_bf, _eg = d.Token()
	if _eg != nil {
		return _eg
	}
	if _geg, _cgd := _bf.(_g.EndElement); _cgd && _geg.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bf)
}
func (_gf *ST_AlgClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gf = 0
	case "\u0068\u0061\u0073\u0068":
		*_gf = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_gf = 2
	}
	return nil
}

type ST_TrueFalse byte

func (_da ST_AlgClass) Validate() error { return _da.ValidateWithPath("") }

const (
	ST_AlgTypeUnset   ST_AlgType = 0
	ST_AlgTypeTypeAny ST_AlgType = 1
	ST_AlgTypeCustom  ST_AlgType = 2
)

func (_geb ST_OnOff1) ValidateWithPath(path string) error {
	switch _geb {
	case 0, 1, 2:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_geb))
	}
	return nil
}
func (_cbc *ST_YAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cbc = 0
	case "\u0069\u006e\u006c\u0069\u006e\u0065":
		*_cbc = 1
	case "\u0074\u006f\u0070":
		*_cbc = 2
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_cbc = 3
	case "\u0062\u006f\u0074\u0074\u006f\u006d":
		*_cbc = 4
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_cbc = 5
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_cbc = 6
	}
	return nil
}
func (_aea ST_ConformanceClass) String() string {
	switch _aea {
	case 0:
		return ""
	case 1:
		return "\u0073\u0074\u0072\u0069\u0063\u0074"
	case 2:
		return "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return ""
}

const ST_PositiveUniversalMeasurePattern = "\u005b\u0030-9\u005d\u002b\u0028\\\u002e\u005b\u0030\u002d9]+\u0029?(\u006d\u006d\u007c\u0063\u006d\u007c\u0069n|\u0070\u0074\u007c\u0070\u0063\u007c\u0070i\u0029"

func (_gegb ST_TrueFalse) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dcb := _g.Attr{}
	_dcb.Name = name
	switch _gegb {
	case ST_TrueFalseUnset:
		_dcb.Value = ""
	case ST_TrueFalseT:
		_dcb.Value = "\u0074"
	case ST_TrueFalseF:
		_dcb.Value = "\u0066"
	case ST_TrueFalseTrue:
		_dcb.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseFalse:
		_dcb.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _dcb, nil
}
func ParseUnionST_OnOff(s string) (ST_OnOff, error) {
	_bg := ST_OnOff{}
	switch s {
	case "\u0074\u0072\u0075\u0065", "\u0031", "\u006f\u006e":
		_gbf := true
		_bg.Bool = &_gbf
	default:
		_a := false
		_bg.Bool = &_a
	}
	return _bg, nil
}

type ST_AlgClass byte

func (_gffd *ST_OnOff1) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gffd = 0
	case "\u006f\u006e":
		*_gffd = 1
	case "\u006f\u0066\u0066":
		*_gffd = 2
	}
	return nil
}
func (_bgb ST_YAlign) ValidateWithPath(path string) error {
	switch _bgb {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bgb))
	}
	return nil
}

type ST_CalendarType byte

func (_adca ST_VerticalAlignRun) Validate() error { return _adca.ValidateWithPath("") }

var ST_PercentagePatternRe = _gb.MustCompile(ST_PercentagePattern)

const ST_UniversalMeasurePattern = "\u002d\u003f\u005b\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u003f\u0028\u006d\u006d\u007c\u0063m\u007c\u0069\u006e\u007c\u0070t\u007c\u0070c\u007c\u0070\u0069\u0029"

func (_bec ST_XAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ede := _g.Attr{}
	_ede.Name = name
	switch _bec {
	case ST_XAlignUnset:
		_ede.Value = ""
	case ST_XAlignLeft:
		_ede.Value = "\u006c\u0065\u0066\u0074"
	case ST_XAlignCenter:
		_ede.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_XAlignRight:
		_ede.Value = "\u0072\u0069\u0067h\u0074"
	case ST_XAlignInside:
		_ede.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_XAlignOutside:
		_ede.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _ede, nil
}
func (_cc *ST_CalendarType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cc = 0
	case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
		*_cc = 1
	case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
		*_cc = 2
	case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
		*_cc = 3
	case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
		*_cc = 4
	case "\u0068\u0069\u006ar\u0069":
		*_cc = 5
	case "\u0068\u0065\u0062\u0072\u0065\u0077":
		*_cc = 6
	case "\u0074\u0061\u0069\u0077\u0061\u006e":
		*_cc = 7
	case "\u006a\u0061\u0070a\u006e":
		*_cc = 8
	case "\u0074\u0068\u0061\u0069":
		*_cc = 9
	case "\u006b\u006f\u0072e\u0061":
		*_cc = 10
	case "\u0073\u0061\u006b\u0061":
		*_cc = 11
	case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
		*_cc = 12
	case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
		*_cc = 13
	case "\u006e\u006f\u006e\u0065":
		*_cc = 14
	}
	return nil
}
func (_cg ST_CalendarType) String() string {
	switch _cg {
	case 0:
		return ""
	case 1:
		return "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case 2:
		return "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case 3:
		return "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case 4:
		return "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case 5:
		return "\u0068\u0069\u006ar\u0069"
	case 6:
		return "\u0068\u0065\u0062\u0072\u0065\u0077"
	case 7:
		return "\u0074\u0061\u0069\u0077\u0061\u006e"
	case 8:
		return "\u006a\u0061\u0070a\u006e"
	case 9:
		return "\u0074\u0068\u0061\u0069"
	case 10:
		return "\u006b\u006f\u0072e\u0061"
	case 11:
		return "\u0073\u0061\u006b\u0061"
	case 12:
		return "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case 13:
		return "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case 14:
		return "\u006e\u006f\u006e\u0065"
	}
	return ""
}
func (_ea *ST_TwipsMeasure) Validate() error { return _ea.ValidateWithPath("") }

const ST_PositivePercentagePattern = "\u005b0\u002d9\u005d\u002b\u0028\u005c\u002e[\u0030\u002d9\u005d\u002b\u0029\u003f\u0025"

func (_abf *ST_XAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_abf = 0
	case "\u006c\u0065\u0066\u0074":
		*_abf = 1
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_abf = 2
	case "\u0072\u0069\u0067h\u0074":
		*_abf = 3
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_abf = 4
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_abf = 5
	}
	return nil
}
func (_gag ST_ConformanceClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dgd := _g.Attr{}
	_dgd.Name = name
	switch _gag {
	case ST_ConformanceClassUnset:
		_dgd.Value = ""
	case ST_ConformanceClassStrict:
		_dgd.Value = "\u0073\u0074\u0072\u0069\u0063\u0074"
	case ST_ConformanceClassTransitional:
		_dgd.Value = "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return _dgd, nil
}
func (_ad ST_AlgClass) ValidateWithPath(path string) error {
	switch _ad {
	case 0, 1, 2:
	default:
		return _gbe.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ad))
	}
	return nil
}
func (_ada *ST_TrueFalseBlank) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aef, _cge := d.Token()
	if _cge != nil {
		return _cge
	}
	if _edgd, _ade := _aef.(_g.EndElement); _ade && _edgd.Name == start.Name {
		*_ada = 1
		return nil
	}
	if _eab, _bad := _aef.(_g.CharData); !_bad {
		return _gbe.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _aef)
	} else {
		switch string(_eab) {
		case "":
			*_ada = 0
		case "\u0074":
			*_ada = 1
		case "\u0066":
			*_ada = 2
		case "\u0074\u0072\u0075\u0065":
			*_ada = 3
		case "\u0066\u0061\u006cs\u0065":
			*_ada = 4
		case "\u0054\u0072\u0075\u0065":
			*_ada = 6
		case "\u0046\u0061\u006cs\u0065":
			*_ada = 7
		}
	}
	_aef, _cge = d.Token()
	if _cge != nil {
		return _cge
	}
	if _cba, _agb := _aef.(_g.EndElement); _agb && _cba.Name == start.Name {
		return nil
	}
	return _gbe.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _aef)
}
func (_fca ST_YAlign) String() string {
	switch _fca {
	case 0:
		return ""
	case 1:
		return "\u0069\u006e\u006c\u0069\u006e\u0065"
	case 2:
		return "\u0074\u006f\u0070"
	case 3:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 4:
		return "\u0062\u006f\u0074\u0074\u006f\u006d"
	case 5:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 6:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}

const (
	ST_TrueFalseUnset ST_TrueFalse = 0
	ST_TrueFalseT     ST_TrueFalse = 1
	ST_TrueFalseF     ST_TrueFalse = 2
	ST_TrueFalseTrue  ST_TrueFalse = 3
	ST_TrueFalseFalse ST_TrueFalse = 4
)

func (_gaa ST_VerticalAlignRun) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_eae := _g.Attr{}
	_eae.Name = name
	switch _gaa {
	case ST_VerticalAlignRunUnset:
		_eae.Value = ""
	case ST_VerticalAlignRunBaseline:
		_eae.Value = "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case ST_VerticalAlignRunSuperscript:
		_eae.Value = "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case ST_VerticalAlignRunSubscript:
		_eae.Value = "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return _eae, nil
}

// ST_OnOff is a union type
type ST_OnOff struct {
	Bool      *bool
	ST_OnOff1 ST_OnOff1
}
type ST_OnOff1 byte

const (
	ST_AlgClassUnset  ST_AlgClass = 0
	ST_AlgClassHash   ST_AlgClass = 1
	ST_AlgClassCustom ST_AlgClass = 2
)

func (_ffa ST_VerticalAlignRun) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ffa.String(), start)
}
