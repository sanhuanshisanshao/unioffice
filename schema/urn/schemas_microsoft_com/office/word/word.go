//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package word

import (
	_c "encoding/xml"
	_g "fmt"
	_b "github.com/sanhuanshisanshao/unioffice"
	_f "strconv"
)

func (_bae *CT_Wrap) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for _, _bd := range start.Attr {
		if _bd.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bae.TypeAttr.UnmarshalXMLAttr(_bd)
			continue
		}
		if _bd.Name.Local == "\u0073\u0069\u0064\u0065" {
			_bae.SideAttr.UnmarshalXMLAttr(_bd)
			continue
		}
		if _bd.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_bae.AnchorxAttr.UnmarshalXMLAttr(_bd)
			continue
		}
		if _bd.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_bae.AnchoryAttr.UnmarshalXMLAttr(_bd)
			continue
		}
	}
	for {
		_fac, _aff := d.Token()
		if _aff != nil {
			return _g.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0043\u0054\u005f\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _aff)
		}
		if _ffc, _eg := _fac.(_c.EndElement); _eg && _ffc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gf *Borderright) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_gf.CT_Border = *NewCT_Border()
	for _, _cbf := range start.Attr {
		if _cbf.Name.Local == "\u0074\u0079\u0070\u0065" {
			_gf.TypeAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
		if _cbf.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ffb, _de := _f.ParseUint(_cbf.Value, 10, 32)
			if _de != nil {
				return _de
			}
			_acd := uint32(_ffb)
			_gf.WidthAttr = &_acd
			continue
		}
		if _cbf.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_gf.ShadowAttr.UnmarshalXMLAttr(_cbf)
			continue
		}
	}
	for {
		_gafe, _aag := d.Token()
		if _aag != nil {
			return _g.Errorf("\u0070\u0061\u0072si\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074\u003a\u0020\u0025\u0073", _aag)
		}
		if _af, _ecf := _gafe.(_c.EndElement); _ecf && _af.Name == start.Name {
			break
		}
	}
	return nil
}
func (_fa *Anchorlock) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_fa.CT_AnchorLock = *NewCT_AnchorLock()
	for {
		_cg, _ec := d.Token()
		if _ec != nil {
			return _g.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b\u003a\u0020%\u0073", _ec)
		}
		if _d, _ac := _cg.(_c.EndElement); _ac && _d.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gbg ST_BorderType) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_gbg.String(), start)
}
func (_bde ST_BorderType) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_fed := _c.Attr{}
	_fed.Name = name
	switch _bde {
	case ST_BorderTypeUnset:
		_fed.Value = ""
	case ST_BorderTypeNone:
		_fed.Value = "\u006e\u006f\u006e\u0065"
	case ST_BorderTypeSingle:
		_fed.Value = "\u0073\u0069\u006e\u0067\u006c\u0065"
	case ST_BorderTypeThick:
		_fed.Value = "\u0074\u0068\u0069c\u006b"
	case ST_BorderTypeDouble:
		_fed.Value = "\u0064\u006f\u0075\u0062\u006c\u0065"
	case ST_BorderTypeHairline:
		_fed.Value = "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case ST_BorderTypeDot:
		_fed.Value = "\u0064\u006f\u0074"
	case ST_BorderTypeDash:
		_fed.Value = "\u0064\u0061\u0073\u0068"
	case ST_BorderTypeDotDash:
		_fed.Value = "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case ST_BorderTypeDashDotDot:
		_fed.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case ST_BorderTypeTriple:
		_fed.Value = "\u0074\u0072\u0069\u0070\u006c\u0065"
	case ST_BorderTypeThinThickSmall:
		_fed.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickThinSmall:
		_fed.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickBetweenThinSmall:
		_fed.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThinThick:
		_fed.Value = "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case ST_BorderTypeThickThin:
		_fed.Value = "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case ST_BorderTypeThickBetweenThin:
		_fed.Value = "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case ST_BorderTypeThinThickLarge:
		_fed.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickThinLarge:
		_fed.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickBetweenThinLarge:
		_fed.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case ST_BorderTypeWave:
		_fed.Value = "\u0077\u0061\u0076\u0065"
	case ST_BorderTypeDoubleWave:
		_fed.Value = "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case ST_BorderTypeDashedSmall:
		_fed.Value = "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeDashDotStroked:
		_fed.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case ST_BorderTypeThreeDEmboss:
		_fed.Value = "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case ST_BorderTypeThreeDEngrave:
		_fed.Value = "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case ST_BorderTypeHTMLOutset:
		_fed.Value = "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case ST_BorderTypeHTMLInset:
		_fed.Value = "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return _fed, nil
}
func (_efa ST_BorderType) String() string {
	switch _efa {
	case 0:
		return ""
	case 1:
		return "\u006e\u006f\u006e\u0065"
	case 2:
		return "\u0073\u0069\u006e\u0067\u006c\u0065"
	case 3:
		return "\u0074\u0068\u0069c\u006b"
	case 4:
		return "\u0064\u006f\u0075\u0062\u006c\u0065"
	case 5:
		return "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case 6:
		return "\u0064\u006f\u0074"
	case 7:
		return "\u0064\u0061\u0073\u0068"
	case 8:
		return "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case 9:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case 10:
		return "\u0074\u0072\u0069\u0070\u006c\u0065"
	case 11:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case 12:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case 13:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case 14:
		return "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case 15:
		return "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case 16:
		return "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case 17:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case 18:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case 19:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case 20:
		return "\u0077\u0061\u0076\u0065"
	case 21:
		return "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case 22:
		return "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case 23:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case 24:
		return "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case 25:
		return "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case 26:
		return "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case 27:
		return "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return ""
}
func (_ca *Borderleft) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_ca.CT_Border = *NewCT_Border()
	for _, _gcb := range start.Attr {
		if _gcb.Name.Local == "\u0074\u0079\u0070\u0065" {
			_ca.TypeAttr.UnmarshalXMLAttr(_gcb)
			continue
		}
		if _gcb.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ef, _gcd := _f.ParseUint(_gcb.Value, 10, 32)
			if _gcd != nil {
				return _gcd
			}
			_ebe := uint32(_ef)
			_ca.WidthAttr = &_ebe
			continue
		}
		if _gcb.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_ca.ShadowAttr.UnmarshalXMLAttr(_gcb)
			continue
		}
	}
	for {
		_bf, _cde := d.Token()
		if _cde != nil {
			return _g.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074\u003a\u0020%\u0073", _cde)
		}
		if _dgc, _fe := _bf.(_c.EndElement); _fe && _dgc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Wrap and its children
func (_abb *CT_Wrap) Validate() error {
	return _abb.ValidateWithPath("\u0043T\u005f\u0057\u0072\u0061\u0070")
}

// Validate validates the Borderright and its children
func (_ge *Borderright) Validate() error {
	return _ge.ValidateWithPath("B\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074")
}

type Borderbottom struct{ CT_Border }

// ValidateWithPath validates the CT_Wrap and its children, prefixing error messages with path
func (_eec *CT_Wrap) ValidateWithPath(path string) error {
	if _abg := _eec.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _abg != nil {
		return _abg
	}
	if _cac := _eec.SideAttr.ValidateWithPath(path + "\u002fS\u0069\u0064\u0065\u0041\u0074\u0074r"); _cac != nil {
		return _cac
	}
	if _bafa := _eec.AnchorxAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0078\u0041\u0074\u0074\u0072"); _bafa != nil {
		return _bafa
	}
	if _beg := _eec.AnchoryAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0079\u0041\u0074\u0074\u0072"); _beg != nil {
		return _beg
	}
	return nil
}

type Borderleft struct{ CT_Border }

// Validate validates the Bordertop and its children
func (_ggb *Bordertop) Validate() error {
	return _ggb.ValidateWithPath("\u0042o\u0072\u0064\u0065\u0072\u0074\u006fp")
}
func (_daag *ST_WrapSide) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_fbce, _edb := d.Token()
	if _edb != nil {
		return _edb
	}
	if _ccf, _gda := _fbce.(_c.EndElement); _gda && _ccf.Name == start.Name {
		*_daag = 1
		return nil
	}
	if _dcf, _bdea := _fbce.(_c.CharData); !_bdea {
		return _g.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fbce)
	} else {
		switch string(_dcf) {
		case "":
			*_daag = 0
		case "\u0062\u006f\u0074\u0068":
			*_daag = 1
		case "\u006c\u0065\u0066\u0074":
			*_daag = 2
		case "\u0072\u0069\u0067h\u0074":
			*_daag = 3
		case "\u006ca\u0072\u0067\u0065\u0073\u0074":
			*_daag = 4
		}
	}
	_fbce, _edb = d.Token()
	if _edb != nil {
		return _edb
	}
	if _bded, _ccc := _fbce.(_c.EndElement); _ccc && _bded.Name == start.Name {
		return nil
	}
	return _g.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fbce)
}

type Bordertop struct{ CT_Border }
type ST_BorderType byte

func (_cfb ST_BorderShadow) ValidateWithPath(path string) error {
	switch _cfb {
	case 0, 1, 2, 3, 4:
	default:
		return _g.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cfb))
	}
	return nil
}
func (_gc *Borderbottom) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_gc.CT_Border = *NewCT_Border()
	for _, _gb := range start.Attr {
		if _gb.Name.Local == "\u0074\u0079\u0070\u0065" {
			_gc.TypeAttr.UnmarshalXMLAttr(_gb)
			continue
		}
		if _gb.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_gca, _ce := _f.ParseUint(_gb.Value, 10, 32)
			if _ce != nil {
				return _ce
			}
			_gac := uint32(_gca)
			_gc.WidthAttr = &_gac
			continue
		}
		if _gb.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_gc.ShadowAttr.UnmarshalXMLAttr(_gb)
			continue
		}
	}
	for {
		_gaf, _cd := d.Token()
		if _cd != nil {
			return _g.Errorf("\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065r\u0062\u006f\u0074\u0074\u006f\u006d\u003a\u0020\u0025\u0073", _cd)
		}
		if _eb, _fd := _gaf.(_c.EndElement); _fd && _eb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_eaaf ST_WrapSide) ValidateWithPath(path string) error {
	switch _eaaf {
	case 0, 1, 2, 3, 4:
	default:
		return _g.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_eaaf))
	}
	return nil
}
func (_cgf ST_BorderShadow) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_cgf.String(), start)
}
func (_efga ST_HorizontalAnchor) String() string {
	switch _efga {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u0063\u0068\u0061\u0072"
	}
	return ""
}
func (_be *CT_Wrap) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	if _be.TypeAttr != ST_WrapTypeUnset {
		_dc, _adb := _be.TypeAttr.MarshalXMLAttr(_c.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _adb != nil {
			return _adb
		}
		start.Attr = append(start.Attr, _dc)
	}
	if _be.SideAttr != ST_WrapSideUnset {
		_bbd, _dec := _be.SideAttr.MarshalXMLAttr(_c.Name{Local: "\u0073\u0069\u0064\u0065"})
		if _dec != nil {
			return _dec
		}
		start.Attr = append(start.Attr, _bbd)
	}
	if _be.AnchorxAttr != ST_HorizontalAnchorUnset {
		_baf, _aed := _be.AnchorxAttr.MarshalXMLAttr(_c.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0078"})
		if _aed != nil {
			return _aed
		}
		start.Attr = append(start.Attr, _baf)
	}
	if _be.AnchoryAttr != ST_VerticalAnchorUnset {
		_bfd, _agb := _be.AnchoryAttr.MarshalXMLAttr(_c.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0079"})
		if _agb != nil {
			return _agb
		}
		start.Attr = append(start.Attr, _bfd)
	}
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_AnchorLock and its children, prefixing error messages with path
func (_da *CT_AnchorLock) ValidateWithPath(path string) error { return nil }
func (_fdd *Bordertop) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp"
	return _fdd.CT_Border.MarshalXML(e, start)
}
func NewCT_Border() *CT_Border { _bb := &CT_Border{}; return _bb }
func (_gbd *ST_WrapType) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_gbd = 0
	case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
		*_gbd = 1
	case "\u0073\u0071\u0075\u0061\u0072\u0065":
		*_gbd = 2
	case "\u006e\u006f\u006e\u0065":
		*_gbd = 3
	case "\u0074\u0069\u0067h\u0074":
		*_gbd = 4
	case "\u0074h\u0072\u006f\u0075\u0067\u0068":
		*_gbd = 5
	}
	return nil
}
func (_gab *Wrap) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_gab.CT_Wrap = *NewCT_Wrap()
	for _, _aad := range start.Attr {
		if _aad.Name.Local == "\u0074\u0079\u0070\u0065" {
			_gab.TypeAttr.UnmarshalXMLAttr(_aad)
			continue
		}
		if _aad.Name.Local == "\u0073\u0069\u0064\u0065" {
			_gab.SideAttr.UnmarshalXMLAttr(_aad)
			continue
		}
		if _aad.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_gab.AnchorxAttr.UnmarshalXMLAttr(_aad)
			continue
		}
		if _aad.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_gab.AnchoryAttr.UnmarshalXMLAttr(_aad)
			continue
		}
	}
	for {
		_bgb, _gag := d.Token()
		if _gag != nil {
			return _g.Errorf("\u0070\u0061r\u0073\u0069\u006eg\u0020\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _gag)
		}
		if _efef, _acf := _bgb.(_c.EndElement); _acf && _efef.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_BorderTypeUnset                 ST_BorderType = 0
	ST_BorderTypeNone                  ST_BorderType = 1
	ST_BorderTypeSingle                ST_BorderType = 2
	ST_BorderTypeThick                 ST_BorderType = 3
	ST_BorderTypeDouble                ST_BorderType = 4
	ST_BorderTypeHairline              ST_BorderType = 5
	ST_BorderTypeDot                   ST_BorderType = 6
	ST_BorderTypeDash                  ST_BorderType = 7
	ST_BorderTypeDotDash               ST_BorderType = 8
	ST_BorderTypeDashDotDot            ST_BorderType = 9
	ST_BorderTypeTriple                ST_BorderType = 10
	ST_BorderTypeThinThickSmall        ST_BorderType = 11
	ST_BorderTypeThickThinSmall        ST_BorderType = 12
	ST_BorderTypeThickBetweenThinSmall ST_BorderType = 13
	ST_BorderTypeThinThick             ST_BorderType = 14
	ST_BorderTypeThickThin             ST_BorderType = 15
	ST_BorderTypeThickBetweenThin      ST_BorderType = 16
	ST_BorderTypeThinThickLarge        ST_BorderType = 17
	ST_BorderTypeThickThinLarge        ST_BorderType = 18
	ST_BorderTypeThickBetweenThinLarge ST_BorderType = 19
	ST_BorderTypeWave                  ST_BorderType = 20
	ST_BorderTypeDoubleWave            ST_BorderType = 21
	ST_BorderTypeDashedSmall           ST_BorderType = 22
	ST_BorderTypeDashDotStroked        ST_BorderType = 23
	ST_BorderTypeThreeDEmboss          ST_BorderType = 24
	ST_BorderTypeThreeDEngrave         ST_BorderType = 25
	ST_BorderTypeHTMLOutset            ST_BorderType = 26
	ST_BorderTypeHTMLInset             ST_BorderType = 27
)

func (_ad *CT_Border) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	if _ad.TypeAttr != ST_BorderTypeUnset {
		_gdg, _cbd := _ad.TypeAttr.MarshalXMLAttr(_c.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _cbd != nil {
			return _cbd
		}
		start.Attr = append(start.Attr, _gdg)
	}
	if _ad.WidthAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0077\u0069\u0064t\u0068"}, Value: _g.Sprintf("\u0025\u0076", *_ad.WidthAttr)})
	}
	if _ad.ShadowAttr != ST_BorderShadowUnset {
		_dad, _bc := _ad.ShadowAttr.MarshalXMLAttr(_c.Name{Local: "\u0073\u0068\u0061\u0064\u006f\u0077"})
		if _bc != nil {
			return _bc
		}
		start.Attr = append(start.Attr, _dad)
	}
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func NewAnchorlock() *Anchorlock {
	_a := &Anchorlock{}
	_a.CT_AnchorLock = *NewCT_AnchorLock()
	return _a
}

// Validate validates the CT_Border and its children
func (_edg *CT_Border) Validate() error {
	return _edg.ValidateWithPath("\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r")
}

// ValidateWithPath validates the Anchorlock and its children, prefixing error messages with path
func (_gd *Anchorlock) ValidateWithPath(path string) error {
	if _ba := _gd.CT_AnchorLock.ValidateWithPath(path); _ba != nil {
		return _ba
	}
	return nil
}
func (_gcf ST_WrapSide) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_gfb := _c.Attr{}
	_gfb.Name = name
	switch _gcf {
	case ST_WrapSideUnset:
		_gfb.Value = ""
	case ST_WrapSideBoth:
		_gfb.Value = "\u0062\u006f\u0074\u0068"
	case ST_WrapSideLeft:
		_gfb.Value = "\u006c\u0065\u0066\u0074"
	case ST_WrapSideRight:
		_gfb.Value = "\u0072\u0069\u0067h\u0074"
	case ST_WrapSideLargest:
		_gfb.Value = "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return _gfb, nil
}
func (_ga *Anchorlock) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b"
	return _ga.CT_AnchorLock.MarshalXML(e, start)
}
func (_dffb ST_VerticalAnchor) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_dffb.String(), start)
}

type ST_BorderShadow byte

// Validate validates the Borderbottom and its children
func (_faa *Borderbottom) Validate() error {
	return _faa.ValidateWithPath("\u0042\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d")
}
func NewWrap() *Wrap { _cf := &Wrap{}; _cf.CT_Wrap = *NewCT_Wrap(); return _cf }
func (_dg *Borderbottom) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d"
	return _dg.CT_Border.MarshalXML(e, start)
}

type ST_VerticalAnchor byte

func (_ed *CT_AnchorLock) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func (_daac *ST_BorderShadow) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_cee, _agc := d.Token()
	if _agc != nil {
		return _agc
	}
	if _daaca, _eecb := _cee.(_c.EndElement); _eecb && _daaca.Name == start.Name {
		*_daac = 1
		return nil
	}
	if _cec, _dcc := _cee.(_c.CharData); !_dcc {
		return _g.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _cee)
	} else {
		switch string(_cec) {
		case "":
			*_daac = 0
		case "\u0074":
			*_daac = 1
		case "\u0074\u0072\u0075\u0065":
			*_daac = 2
		case "\u0066":
			*_daac = 3
		case "\u0066\u0061\u006cs\u0065":
			*_daac = 4
		}
	}
	_cee, _agc = d.Token()
	if _agc != nil {
		return _agc
	}
	if _cddf, _cag := _cee.(_c.EndElement); _cag && _cddf.Name == start.Name {
		return nil
	}
	return _g.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _cee)
}
func (_cff ST_HorizontalAnchor) ValidateWithPath(path string) error {
	switch _cff {
	case 0, 1, 2, 3, 4:
	default:
		return _g.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cff))
	}
	return nil
}
func (_fgg ST_WrapType) String() string {
	switch _fgg {
	case 0:
		return ""
	case 1:
		return "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case 2:
		return "\u0073\u0071\u0075\u0061\u0072\u0065"
	case 3:
		return "\u006e\u006f\u006e\u0065"
	case 4:
		return "\u0074\u0069\u0067h\u0074"
	case 5:
		return "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return ""
}
func (_bef *ST_WrapType) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_efg, _aca := d.Token()
	if _aca != nil {
		return _aca
	}
	if _afc, _geb := _efg.(_c.EndElement); _geb && _afc.Name == start.Name {
		*_bef = 1
		return nil
	}
	if _gfc, _fg := _efg.(_c.CharData); !_fg {
		return _g.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _efg)
	} else {
		switch string(_gfc) {
		case "":
			*_bef = 0
		case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
			*_bef = 1
		case "\u0073\u0071\u0075\u0061\u0072\u0065":
			*_bef = 2
		case "\u006e\u006f\u006e\u0065":
			*_bef = 3
		case "\u0074\u0069\u0067h\u0074":
			*_bef = 4
		case "\u0074h\u0072\u006f\u0075\u0067\u0068":
			*_bef = 5
		}
	}
	_efg, _aca = d.Token()
	if _aca != nil {
		return _aca
	}
	if _cdf, _efagd := _efg.(_c.EndElement); _efagd && _cdf.Name == start.Name {
		return nil
	}
	return _g.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _efg)
}
func (_agd ST_HorizontalAnchor) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_agd.String(), start)
}
func (_deg *ST_VerticalAnchor) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_deg = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_deg = 1
	case "\u0070\u0061\u0067\u0065":
		*_deg = 2
	case "\u0074\u0065\u0078\u0074":
		*_deg = 3
	case "\u006c\u0069\u006e\u0065":
		*_deg = 4
	}
	return nil
}

// ValidateWithPath validates the Borderright and its children, prefixing error messages with path
func (_ddf *Borderright) ValidateWithPath(path string) error {
	if _ceg := _ddf.CT_Border.ValidateWithPath(path); _ceg != nil {
		return _ceg
	}
	return nil
}
func (_efag ST_BorderShadow) Validate() error { return _efag.ValidateWithPath("") }
func (_fca *Wrap) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0077\u0072\u0061\u0070"
	return _fca.CT_Wrap.MarshalXML(e, start)
}

// ValidateWithPath validates the Bordertop and its children, prefixing error messages with path
func (_dfe *Bordertop) ValidateWithPath(path string) error {
	if _ea := _dfe.CT_Border.ValidateWithPath(path); _ea != nil {
		return _ea
	}
	return nil
}
func (_aec ST_WrapSide) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_aec.String(), start)
}
func NewBorderbottom() *Borderbottom {
	_dd := &Borderbottom{}
	_dd.CT_Border = *NewCT_Border()
	return _dd
}

const (
	ST_WrapTypeUnset        ST_WrapType = 0
	ST_WrapTypeTopAndBottom ST_WrapType = 1
	ST_WrapTypeSquare       ST_WrapType = 2
	ST_WrapTypeNone         ST_WrapType = 3
	ST_WrapTypeTight        ST_WrapType = 4
	ST_WrapTypeThrough      ST_WrapType = 5
)

func NewBorderleft() *Borderleft {
	_cga := &Borderleft{}
	_cga.CT_Border = *NewCT_Border()
	return _cga
}
func (_dff *ST_BorderType) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_dff = 0
	case "\u006e\u006f\u006e\u0065":
		*_dff = 1
	case "\u0073\u0069\u006e\u0067\u006c\u0065":
		*_dff = 2
	case "\u0074\u0068\u0069c\u006b":
		*_dff = 3
	case "\u0064\u006f\u0075\u0062\u006c\u0065":
		*_dff = 4
	case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
		*_dff = 5
	case "\u0064\u006f\u0074":
		*_dff = 6
	case "\u0064\u0061\u0073\u0068":
		*_dff = 7
	case "\u0064o\u0074\u0044\u0061\u0073\u0068":
		*_dff = 8
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
		*_dff = 9
	case "\u0074\u0072\u0069\u0070\u006c\u0065":
		*_dff = 10
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
		*_dff = 11
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
		*_dff = 12
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
		*_dff = 13
	case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
		*_dff = 14
	case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
		*_dff = 15
	case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
		*_dff = 16
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
		*_dff = 17
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
		*_dff = 18
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
		*_dff = 19
	case "\u0077\u0061\u0076\u0065":
		*_dff = 20
	case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
		*_dff = 21
	case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
		*_dff = 22
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
		*_dff = 23
	case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
		*_dff = 24
	case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
		*_dff = 25
	case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
		*_dff = 26
	case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
		*_dff = 27
	}
	return nil
}
func (_bfac ST_WrapType) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_dbc := _c.Attr{}
	_dbc.Name = name
	switch _bfac {
	case ST_WrapTypeUnset:
		_dbc.Value = ""
	case ST_WrapTypeTopAndBottom:
		_dbc.Value = "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case ST_WrapTypeSquare:
		_dbc.Value = "\u0073\u0071\u0075\u0061\u0072\u0065"
	case ST_WrapTypeNone:
		_dbc.Value = "\u006e\u006f\u006e\u0065"
	case ST_WrapTypeTight:
		_dbc.Value = "\u0074\u0069\u0067h\u0074"
	case ST_WrapTypeThrough:
		_dbc.Value = "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return _dbc, nil
}
func (_dgg ST_VerticalAnchor) ValidateWithPath(path string) error {
	switch _dgg {
	case 0, 1, 2, 3, 4:
	default:
		return _g.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dgg))
	}
	return nil
}
func (_bfda ST_WrapType) Validate() error { return _bfda.ValidateWithPath("") }
func (_ecb *ST_HorizontalAnchor) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_ecb = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_ecb = 1
	case "\u0070\u0061\u0067\u0065":
		*_ecb = 2
	case "\u0074\u0065\u0078\u0074":
		*_ecb = 3
	case "\u0063\u0068\u0061\u0072":
		*_ecb = 4
	}
	return nil
}

type Borderright struct{ CT_Border }

// Validate validates the CT_AnchorLock and its children
func (_gef *CT_AnchorLock) Validate() error {
	return _gef.ValidateWithPath("\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b")
}

// Validate validates the Anchorlock and its children
func (_ff *Anchorlock) Validate() error {
	return _ff.ValidateWithPath("\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b")
}
func NewCT_Wrap() *CT_Wrap { _aaa := &CT_Wrap{}; return _aaa }
func (_eaab ST_VerticalAnchor) String() string {
	switch _eaab {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u006c\u0069\u006e\u0065"
	}
	return ""
}

type CT_Border struct {
	TypeAttr   ST_BorderType
	WidthAttr  *uint32
	ShadowAttr ST_BorderShadow
}
type ST_HorizontalAnchor byte

func (_gfg ST_WrapSide) Validate() error { return _gfg.ValidateWithPath("") }

// Validate validates the Wrap and its children
func (_adg *Wrap) Validate() error { return _adg.ValidateWithPath("\u0057\u0072\u0061\u0070") }
func (_bda ST_WrapSide) String() string {
	switch _bda {
	case 0:
		return ""
	case 1:
		return "\u0062\u006f\u0074\u0068"
	case 2:
		return "\u006c\u0065\u0066\u0074"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return ""
}
func (_ada *ST_WrapSide) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_ada = 0
	case "\u0062\u006f\u0074\u0068":
		*_ada = 1
	case "\u006c\u0065\u0066\u0074":
		*_ada = 2
	case "\u0072\u0069\u0067h\u0074":
		*_ada = 3
	case "\u006ca\u0072\u0067\u0065\u0073\u0074":
		*_ada = 4
	}
	return nil
}

const (
	ST_VerticalAnchorUnset  ST_VerticalAnchor = 0
	ST_VerticalAnchorMargin ST_VerticalAnchor = 1
	ST_VerticalAnchorPage   ST_VerticalAnchor = 2
	ST_VerticalAnchorText   ST_VerticalAnchor = 3
	ST_VerticalAnchorLine   ST_VerticalAnchor = 4
)

// ValidateWithPath validates the Wrap and its children, prefixing error messages with path
func (_afe *Wrap) ValidateWithPath(path string) error {
	if _bga := _afe.CT_Wrap.ValidateWithPath(path); _bga != nil {
		return _bga
	}
	return nil
}
func (_gcc *CT_AnchorLock) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for {
		_db, _ab := d.Token()
		if _ab != nil {
			return _g.Errorf("\u0070a\u0072\u0073\u0069\u006eg\u0020\u0043\u0054\u005f\u0041n\u0063h\u006fr\u004c\u006f\u0063\u006b\u003a\u0020\u0025s", _ab)
		}
		if _ee, _ede := _db.(_c.EndElement); _ede && _ee.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cbdc *ST_HorizontalAnchor) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_eed, _cecc := d.Token()
	if _cecc != nil {
		return _cecc
	}
	if _aae, _edd := _eed.(_c.EndElement); _edd && _aae.Name == start.Name {
		*_cbdc = 1
		return nil
	}
	if _ecbg, _cfe := _eed.(_c.CharData); !_cfe {
		return _g.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _eed)
	} else {
		switch string(_ecbg) {
		case "":
			*_cbdc = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_cbdc = 1
		case "\u0070\u0061\u0067\u0065":
			*_cbdc = 2
		case "\u0074\u0065\u0078\u0074":
			*_cbdc = 3
		case "\u0063\u0068\u0061\u0072":
			*_cbdc = 4
		}
	}
	_eed, _cecc = d.Token()
	if _cecc != nil {
		return _cecc
	}
	if _ddd, _cagb := _eed.(_c.EndElement); _cagb && _ddd.Name == start.Name {
		return nil
	}
	return _g.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _eed)
}
func (_fbf *CT_Border) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for _, _eda := range start.Attr {
		if _eda.Name.Local == "\u0074\u0079\u0070\u0065" {
			_fbf.TypeAttr.UnmarshalXMLAttr(_eda)
			continue
		}
		if _eda.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_ae, _eaa := _f.ParseUint(_eda.Value, 10, 32)
			if _eaa != nil {
				return _eaa
			}
			_cdd := uint32(_ae)
			_fbf.WidthAttr = &_cdd
			continue
		}
		if _eda.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_fbf.ShadowAttr.UnmarshalXMLAttr(_eda)
			continue
		}
	}
	for {
		_def, _fcb := d.Token()
		if _fcb != nil {
			return _g.Errorf("p\u0061\u0072\u0073\u0069ng\u0020C\u0054\u005f\u0042\u006f\u0072d\u0065\u0072\u003a\u0020\u0025\u0073", _fcb)
		}
		if _bfc, _eef := _def.(_c.EndElement); _eef && _bfc.Name == start.Name {
			break
		}
	}
	return nil
}

type Anchorlock struct{ CT_AnchorLock }

const (
	ST_HorizontalAnchorUnset  ST_HorizontalAnchor = 0
	ST_HorizontalAnchorMargin ST_HorizontalAnchor = 1
	ST_HorizontalAnchorPage   ST_HorizontalAnchor = 2
	ST_HorizontalAnchorText   ST_HorizontalAnchor = 3
	ST_HorizontalAnchorChar   ST_HorizontalAnchor = 4
)

// ValidateWithPath validates the CT_Border and its children, prefixing error messages with path
func (_bag *CT_Border) ValidateWithPath(path string) error {
	if _ecd := _bag.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _ecd != nil {
		return _ecd
	}
	if _bfaf := _bag.ShadowAttr.ValidateWithPath(path + "/\u0053\u0068\u0061\u0064\u006f\u0077\u0041\u0074\u0074\u0072"); _bfaf != nil {
		return _bfaf
	}
	return nil
}
func (_aee ST_BorderShadow) String() string {
	switch _aee {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0074\u0072\u0075\u0065"
	case 3:
		return "\u0066"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}
func (_fcc ST_WrapType) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	return e.EncodeElement(_fcc.String(), start)
}

const (
	ST_BorderShadowUnset ST_BorderShadow = 0
	ST_BorderShadowT     ST_BorderShadow = 1
	ST_BorderShadowTrue  ST_BorderShadow = 2
	ST_BorderShadowF     ST_BorderShadow = 3
	ST_BorderShadowFalse ST_BorderShadow = 4
)

func (_dcb ST_WrapType) ValidateWithPath(path string) error {
	switch _dcb {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _g.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dcb))
	}
	return nil
}

type ST_WrapSide byte

// ValidateWithPath validates the Borderbottom and its children, prefixing error messages with path
func (_ag *Borderbottom) ValidateWithPath(path string) error {
	if _cea := _ag.CT_Border.ValidateWithPath(path); _cea != nil {
		return _cea
	}
	return nil
}

type CT_AnchorLock struct{}

func NewBordertop() *Bordertop { _bg := &Bordertop{}; _bg.CT_Border = *NewCT_Border(); return _bg }

// ValidateWithPath validates the Borderleft and its children, prefixing error messages with path
func (_ffa *Borderleft) ValidateWithPath(path string) error {
	if _cb := _ffa.CT_Border.ValidateWithPath(path); _cb != nil {
		return _cb
	}
	return nil
}

// Validate validates the Borderleft and its children
func (_gcbb *Borderleft) Validate() error {
	return _gcbb.ValidateWithPath("\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074")
}
func (_fb *Borderright) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074"
	return _fb.CT_Border.MarshalXML(e, start)
}
func (_dfd *ST_VerticalAnchor) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_gebc, _dfdf := d.Token()
	if _dfdf != nil {
		return _dfdf
	}
	if _cegc, _fee := _gebc.(_c.EndElement); _fee && _cegc.Name == start.Name {
		*_dfd = 1
		return nil
	}
	if _fba, _aea := _gebc.(_c.CharData); !_aea {
		return _g.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gebc)
	} else {
		switch string(_fba) {
		case "":
			*_dfd = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_dfd = 1
		case "\u0070\u0061\u0067\u0065":
			*_dfd = 2
		case "\u0074\u0065\u0078\u0074":
			*_dfd = 3
		case "\u006c\u0069\u006e\u0065":
			*_dfd = 4
		}
	}
	_gebc, _dfdf = d.Token()
	if _dfdf != nil {
		return _dfdf
	}
	if _cdbg, _aac := _gebc.(_c.EndElement); _aac && _cdbg.Name == start.Name {
		return nil
	}
	return _g.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gebc)
}
func (_ffd ST_BorderType) ValidateWithPath(path string) error {
	switch _ffd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27:
	default:
		return _g.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ffd))
	}
	return nil
}

type ST_WrapType byte

func NewCT_AnchorLock() *CT_AnchorLock { _fc := &CT_AnchorLock{}; return _fc }
func (_add ST_VerticalAnchor) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_gee := _c.Attr{}
	_gee.Name = name
	switch _add {
	case ST_VerticalAnchorUnset:
		_gee.Value = ""
	case ST_VerticalAnchorMargin:
		_gee.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_VerticalAnchorPage:
		_gee.Value = "\u0070\u0061\u0067\u0065"
	case ST_VerticalAnchorText:
		_gee.Value = "\u0074\u0065\u0078\u0074"
	case ST_VerticalAnchorLine:
		_gee.Value = "\u006c\u0069\u006e\u0065"
	}
	return _gee, nil
}
func (_bdc ST_BorderShadow) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_cfd := _c.Attr{}
	_cfd.Name = name
	switch _bdc {
	case ST_BorderShadowUnset:
		_cfd.Value = ""
	case ST_BorderShadowT:
		_cfd.Value = "\u0074"
	case ST_BorderShadowTrue:
		_cfd.Value = "\u0074\u0072\u0075\u0065"
	case ST_BorderShadowF:
		_cfd.Value = "\u0066"
	case ST_BorderShadowFalse:
		_cfd.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _cfd, nil
}
func (_ebb ST_HorizontalAnchor) MarshalXMLAttr(name _c.Name) (_c.Attr, error) {
	_dbcc := _c.Attr{}
	_dbcc.Name = name
	switch _ebb {
	case ST_HorizontalAnchorUnset:
		_dbcc.Value = ""
	case ST_HorizontalAnchorMargin:
		_dbcc.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_HorizontalAnchorPage:
		_dbcc.Value = "\u0070\u0061\u0067\u0065"
	case ST_HorizontalAnchorText:
		_dbcc.Value = "\u0074\u0065\u0078\u0074"
	case ST_HorizontalAnchorChar:
		_dbcc.Value = "\u0063\u0068\u0061\u0072"
	}
	return _dbcc, nil
}

const (
	ST_WrapSideUnset   ST_WrapSide = 0
	ST_WrapSideBoth    ST_WrapSide = 1
	ST_WrapSideLeft    ST_WrapSide = 2
	ST_WrapSideRight   ST_WrapSide = 3
	ST_WrapSideLargest ST_WrapSide = 4
)

func (_daa *ST_BorderType) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_bca, _ega := d.Token()
	if _ega != nil {
		return _ega
	}
	if _ebc, _dab := _bca.(_c.EndElement); _dab && _ebc.Name == start.Name {
		*_daa = 1
		return nil
	}
	if _gbc, _aadc := _bca.(_c.CharData); !_aadc {
		return _g.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bca)
	} else {
		switch string(_gbc) {
		case "":
			*_daa = 0
		case "\u006e\u006f\u006e\u0065":
			*_daa = 1
		case "\u0073\u0069\u006e\u0067\u006c\u0065":
			*_daa = 2
		case "\u0074\u0068\u0069c\u006b":
			*_daa = 3
		case "\u0064\u006f\u0075\u0062\u006c\u0065":
			*_daa = 4
		case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
			*_daa = 5
		case "\u0064\u006f\u0074":
			*_daa = 6
		case "\u0064\u0061\u0073\u0068":
			*_daa = 7
		case "\u0064o\u0074\u0044\u0061\u0073\u0068":
			*_daa = 8
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
			*_daa = 9
		case "\u0074\u0072\u0069\u0070\u006c\u0065":
			*_daa = 10
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
			*_daa = 11
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
			*_daa = 12
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
			*_daa = 13
		case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
			*_daa = 14
		case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
			*_daa = 15
		case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
			*_daa = 16
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
			*_daa = 17
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
			*_daa = 18
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
			*_daa = 19
		case "\u0077\u0061\u0076\u0065":
			*_daa = 20
		case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
			*_daa = 21
		case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
			*_daa = 22
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
			*_daa = 23
		case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
			*_daa = 24
		case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
			*_daa = 25
		case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
			*_daa = 26
		case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
			*_daa = 27
		}
	}
	_bca, _ega = d.Token()
	if _ega != nil {
		return _ega
	}
	if _bgdd, _ecg := _bca.(_c.EndElement); _ecg && _bgdd.Name == start.Name {
		return nil
	}
	return _g.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bca)
}

type Wrap struct{ CT_Wrap }

func (_fgge ST_HorizontalAnchor) Validate() error { return _fgge.ValidateWithPath("") }
func (_gdc ST_VerticalAnchor) Validate() error    { return _gdc.ValidateWithPath("") }

type CT_Wrap struct {
	TypeAttr    ST_WrapType
	SideAttr    ST_WrapSide
	AnchorxAttr ST_HorizontalAnchor
	AnchoryAttr ST_VerticalAnchor
}

func NewBorderright() *Borderright {
	_ddc := &Borderright{}
	_ddc.CT_Border = *NewCT_Border()
	return _ddc
}
func (_fcbc ST_BorderType) Validate() error { return _fcbc.ValidateWithPath("") }
func (_agg *Bordertop) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_agg.CT_Border = *NewCT_Border()
	for _, _gfa := range start.Attr {
		if _gfa.Name.Local == "\u0074\u0079\u0070\u0065" {
			_agg.TypeAttr.UnmarshalXMLAttr(_gfa)
			continue
		}
		if _gfa.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_cdb, _df := _f.ParseUint(_gfa.Value, 10, 32)
			if _df != nil {
				return _df
			}
			_bgg := uint32(_cdb)
			_agg.WidthAttr = &_bgg
			continue
		}
		if _gfa.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_agg.ShadowAttr.UnmarshalXMLAttr(_gfa)
			continue
		}
	}
	for {
		_cbc, _bgd := d.Token()
		if _bgd != nil {
			return _g.Errorf("p\u0061\u0072\u0073\u0069ng\u0020B\u006f\u0072\u0064\u0065\u0072t\u006f\u0070\u003a\u0020\u0025\u0073", _bgd)
		}
		if _fbc, _bfa := _cbc.(_c.EndElement); _bfa && _fbc.Name == start.Name {
			break
		}
	}
	return nil
}
func (_ebg *Borderleft) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074"
	return _ebg.CT_Border.MarshalXML(e, start)
}
func (_bafb *ST_BorderShadow) UnmarshalXMLAttr(attr _c.Attr) error {
	switch attr.Value {
	case "":
		*_bafb = 0
	case "\u0074":
		*_bafb = 1
	case "\u0074\u0072\u0075\u0065":
		*_bafb = 2
	case "\u0066":
		*_bafb = 3
	case "\u0066\u0061\u006cs\u0065":
		*_bafb = 4
	}
	return nil
}
func init() {
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r", NewCT_Border)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0057\u0072\u0061\u0070", NewCT_Wrap)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b", NewCT_AnchorLock)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp", NewBordertop)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074", NewBorderleft)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074", NewBorderright)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d", NewBorderbottom)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0077\u0072\u0061\u0070", NewWrap)
	_b.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b", NewAnchorlock)
}
