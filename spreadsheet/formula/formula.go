//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package formula provides formula parsing and evaluation. The lexer is
// implemented with a ragel grammar while the the parser is implemented with
// goyacc. The entire formula grammar is not implemented and not all functions
// are supported yet. For compatibility sake, upon failure to parse or execute a
// formula, unioffice leaves cached formula results blank allowing Excel to compute
// formulas upon load. This is similar to what most other Excel libraries do
// which leave all cached results blank instead of attempting to execute
// formulas.
//
// The unit tests for this package are unique in that we can take advantage of
// "cached" formula results that Excel/LibreOffice write to the sheet.  These
// are the computed results of a formula in string form.  By comparing these
// values to the value computed by the unioffice evaluation of the formula, adding
// a new test means just adding a new formula to one of the reference sheets
// with Excel. During the unit test, we evaluate the formula and compare it to
// the value that Excel computed.  If they're the same, the test passes.
package formula

import (
	_gb "bytes"
	_e "errors"
	_c "fmt"
	_ga "github.com/sanhuanshisanshao/unioffice/common/logger"
	_b "github.com/sanhuanshisanshao/unioffice/internal/mergesort"
	_ce "github.com/sanhuanshisanshao/unioffice/internal/wildcard"
	_cd "github.com/sanhuanshisanshao/unioffice/spreadsheet/format"
	_ee "github.com/sanhuanshisanshao/unioffice/spreadsheet/reference"
	_de "github.com/sanhuanshisanshao/unioffice/spreadsheet/update"
	_ef "io"
	_gfc "math"
	_cf "math/big"
	_gf "math/rand"
	_ed "regexp"
	_eaf "sort"
	_ff "strconv"
	_gg "strings"
	_f "sync"
	_d "time"
	_ea "unicode"
)

// String returns a string representation for Negate.
func (_fgbd Negate) String() string { return "\u002d" + _fgbd._gdda.String() }
func _acdf(_dgae []Result, _gbdaf string) (*couponArgs, Result) {
	_abd := len(_dgae)
	if _abd != 3 && _abd != 4 {
		return nil, MakeErrorResult(_gbdaf + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u0066o\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_eaeda, _dcec, _ebf := _geae(_dgae[0], _dgae[1], _gbdaf)
	if _ebf.Type == ResultTypeError {
		return nil, _ebf
	}
	if _dgae[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_gbdaf + "\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fecg := _dgae[2].ValueNumber
	if !_beg(_fecg) {
		return nil, MakeErrorResult("\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0065q\u0075\u0065\u006e\u0063\u0079\u0020\u0066\u006f\u0072\u0020" + _gbdaf)
	}
	_badg := 0
	if _abd == 4 && _dgae[3].Type != ResultTypeEmpty {
		if _dgae[3].Type != ResultTypeNumber {
			return nil, MakeErrorResult(_gbdaf + "\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_badg = int(_dgae[3].ValueNumber)
		if !_dfeg(_badg) {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020"+_gbdaf)
		}
	}
	return &couponArgs{_eaeda, _dcec, int(_fecg), _badg}, _gaef
}

// Eval evaluates and returns the result of an error expression.
func (_aea Error) Eval(ctx Context, ev Evaluator) Result { return MakeErrorResult(_aea._cbgb) }

const _feffe = 57354

func (_aafgg *ivr) SetOffset(col, row uint32) {}

var _bedb = [...]uint8{0, 17, 33, 49, 63, 78, 93, 108}

// Not is an implementation of the Excel NOT() function and takes a single
// argument.
func Not(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004eO\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	switch args[0].Type {
	case ResultTypeError:
		return args[0]
	case ResultTypeString, ResultTypeList:
		return MakeErrorResult("\u004e\u004f\u0054\u0020\u0065\u0078\u0070\u0065\u0063\u0074s\u0020\u0061\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	case ResultTypeNumber:
		return MakeBoolResult(!(args[0].ValueNumber != 0))
	default:
		return MakeErrorResult("u\u006e\u0068\u0061\u006e\u0064\u006ce\u0064\u0020\u004e\u004f\u0054\u0020\u0061\u0072\u0067u\u006d\u0065\u006et\u0020t\u0079\u0070\u0065")
	}
}

// String returns a string representation of a range with prefix.
func (_aeggb PrefixRangeExpr) String() string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _aeggb._gfdcf.String(), _aeggb._cbcgb.String(), _aeggb._fece.String())
}

const _bcfd = "\u0028\u0028\u005b\u0030\u002d\u0039]\u0029\u002b\u0029:\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b(\\\u002e\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u003f\u0029\u0028\u0020\u0028\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

// String returns a string representation of a vertical range with prefix.
func (_cfbgg PrefixVerticalRange) String() string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _cfbgg._ggdbe.String(), _cfbgg._cagbb, _cfbgg._baae)
}

// Substitute is an implementation of the Excel SUBSTITUTE function.
func Substitute(args []Result) Result {
	_cgcf := len(args)
	if _cgcf != 3 && _cgcf != 4 {
		return MakeErrorResult("\u0053\u0055\u0042\u0053\u0054\u0049\u0054U\u0054\u0045\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_feda, _fcagc := _adcgg(args[0], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u0074\u0065\u0078\u0074")
	if _fcagc.Type == ResultTypeError {
		return _fcagc
	}
	_efbag, _fcagc := _adcgg(args[1], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u006f\u006c\u0064\u0020\u0074\u0065\u0078\u0074")
	if _fcagc.Type == ResultTypeError {
		return _fcagc
	}
	_acdfg, _fcagc := _adcgg(args[2], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u006e\u0065\u0077\u0020\u0074\u0065\u0078\u0074")
	if _fcagc.Type == ResultTypeError {
		return _fcagc
	}
	_bbfac := 0
	if _cgcf == 3 {
		return MakeStringResult(_gg.Replace(_feda, _efbag, _acdfg, -1))
	} else {
		_deab, _bccc := _fagb(args[3], "\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", "\u0069\u006e\u0073t\u0061\u006e\u0063\u0065\u005f\u006e\u0075\u006d")
		if _bccc.Type == ResultTypeError {
			return _bccc
		}
		_bbfac = int(_deab)
		if _bbfac < 1 {
			return MakeErrorResult("\u0069\u006es\u0074\u0061\u006e\u0063e\u005f\u006eu\u006d\u0020\u0073\u0068\u006f\u0075\u006c\u0064 \u0062\u0065\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e \u007a\u0065\u0072\u006f")
		}
		_dedb := _feda
		_edgcc := _bbfac
		_bbfb := -1
		_cfad := len(_efbag)
		_gfff := 0
		for {
			_edgcc--
			_befdg := _gg.Index(_dedb, _efbag)
			if _befdg == -1 {
				_bbfb = -1
				break
			} else {
				_bbfb = _befdg + _gfff
				if _edgcc == 0 {
					break
				}
				_cbbdb := _cfad + _befdg
				_gfff += _cbbdb
				_dedb = _dedb[_cbbdb:]
			}
		}
		if _bbfb == -1 {
			return MakeStringResult(_feda)
		} else {
			_fdaf := _feda[:_bbfb]
			_fffc := _feda[_bbfb+_cfad:]
			return MakeStringResult(_fdaf + _acdfg + _fffc)
		}
	}
}
func (_ebcea *ivr) Cell(ref string, ev Evaluator) Result {
	return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065")
}

type criteriaRegex struct {
	_cadca byte
	_acdd  string
}

func _dbc(_bgab, _aabf, _dfff int) int {
	if _bgab > _aabf {
		return 0
	}
	if _dafg(_dfff) {
		return (_aabf - _bgab + 1) * 360
	}
	_fgceb := 0
	for _efcg := _bgab; _efcg <= _aabf; _efcg++ {
		_eddb := 365
		if _acec(_efcg) {
			_eddb = 366
		}
		_fgceb += _eddb
	}
	return _fgceb
}

// Transpose implements the TRANSPOSE function that transposes a cell range.
func Transpose(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0054\u0052AN\u0053\u0050\u004fS\u0045\u0020\u0072\u0065qui\u0072es\u0020\u0061\u0020\u0073\u0069\u006e\u0067le\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[0].Type != ResultTypeArray && args[0].Type != ResultTypeList {
		return MakeErrorResult("T\u0052\u0041\u004e\u0053\u0050\u004fS\u0045\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0061\u0020\u0072a\u006e\u0067\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_gaagc := args[0]
	if _gaagc.Type == ResultTypeList {
		_dcde := [][]Result{}
		for _, _fgfcg := range _gaagc.ValueList {
			_dcde = append(_dcde, []Result{_fgfcg})
		}
		return MakeArrayResult(_dcde)
	}
	_egbb := make([][]Result, len(_gaagc.ValueArray[0]))
	for _, _bffa := range _gaagc.ValueArray {
		for _ceebd, _ece := range _bffa {
			_egbb[_ceebd] = append(_egbb[_ceebd], _ece)
		}
	}
	return MakeArrayResult(_egbb)
}
func _bgge(_cbc, _gcc, _cfgd, _gdb int) int {
	if !_dafg(_gdb) {
		return _cfgd
	}
	_gce := _cfgd
	_gda := _ebc(_cbc, _gcc)
	if _gce > 30 || _cfgd >= _gda || _gce >= _gda {
		_gce = 30
	}
	return _gce
}

// Degrees is an implementation of the Excel function DEGREES() that converts
// radians to degrees.
func Degrees(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0044\u0045\u0047R\u0045\u0045\u0053\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_faga := args[0].AsNumber()
	if _faga.Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0045\u0047RE\u0045\u0053\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u006eu\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(180.0 / _gfc.Pi * _faga.ValueNumber)
}

var _eec int64 = _fca(1900, _d.January, 1)

// Duration implements the Excel DURATION function.
func Duration(args []Result) Result {
	_eebe, _ggda := _gfdb(args, "\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e")
	if _ggda.Type == ResultTypeError {
		return _ggda
	}
	_aecd := _eebe._acdb
	_eecb := _eebe._fbef
	_ccgb := _eebe._dgdc
	_agdef := _eebe._ggdd
	_acge := _eebe._gbgg
	_ddcbb := _eebe._bdf
	return _aggbb(_aecd, _eecb, _ccgb, _agdef, _acge, _ddcbb)
}

const _eagab = 57373

// FactDouble is an implementation of the excel FACTDOUBLE function which
// returns the double factorial of a positive numeric input.
func FactDouble(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0046\u0041C\u0054\u0044\u004f\u0055\u0042\u004c\u0045\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_decc := args[0].AsNumber()
	if _decc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0041C\u0054\u0044\u004f\u0055\u0042\u004c\u0045\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _decc.ValueNumber < 0 {
		return MakeErrorResult("\u0046A\u0043\u0054D\u004f\u0055\u0042\u004cE\u0028\u0029\u0020a\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006f\u006ely\u0020\u0070\u006fs\u0069\u0074i\u0076\u0065\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_gdcd := float64(1)
	_efbc := _gfc.Trunc(_decc.ValueNumber)
	for _cgfa := _efbc; _cgfa > 1; _cgfa -= 2 {
		_gdcd *= _cgfa
	}
	return MakeNumberResult(_gdcd)
}

// NewCellRef constructs a new cell reference.
func NewCellRef(v string) Expression { return CellRef{_acb: v} }

var _dbea []byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

func _ggdf(_efab, _bbgdf []string) []string {
	for _, _agee := range _bbgdf {
		_efab = append(_efab, _agee)
	}
	return _efab
}
func _dde() evCache {
	_cdc := evCache{}
	_cdc._agf = make(map[string]Result)
	_cdc._cgb = &_f.Mutex{}
	return _cdc
}

var _ecdeb = map[string]FunctionComplex{}

func _ffgcd(_dgfa string, _fbgdf func(_cdeg float64) float64) Function {
	return func(_gdag []Result) Result {
		if len(_gdag) != 1 {
			return MakeErrorResult(_dgfa + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_cbbeb := _gdag[0].AsNumber()
		switch _cbbeb.Type {
		case ResultTypeNumber:
			_adfg := _fbgdf(_cbbeb.ValueNumber)
			if _gfc.IsNaN(_adfg) {
				return MakeErrorResult(_dgfa + "\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0065\u0064\u0020\u004e\u0061\u004e")
			}
			if _gfc.IsInf(_adfg, 0) {
				return MakeErrorResult(_dgfa + "\u0020r\u0065t\u0075\u0072\u006e\u0065\u0064 \u0069\u006ef\u0069\u006e\u0069\u0074\u0079")
			}
			return MakeNumberResult(_adfg)
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult(_dgfa + "\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072i\u0063\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		case ResultTypeError:
			return _cbbeb
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068a\u006e\u0064\u006c\u0065d\u0020\u0025\u0073\u0028\u0029\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dgfa, _cbbeb.Type))
		}
	}
}

// Eval evaluates the binary expression using the context given.
func (_dbb BinaryExpr) String() string {
	_fgc := ""
	switch _dbb._dee {
	case BinOpTypePlus:
		_fgc = "\u002b"
	case BinOpTypeMinus:
		_fgc = "\u002d"
	case BinOpTypeMult:
		_fgc = "\u002a"
	case BinOpTypeDiv:
		_fgc = "\u002f"
	case BinOpTypeExp:
		_fgc = "\u005e"
	case BinOpTypeLT:
		_fgc = "\u003c"
	case BinOpTypeGT:
		_fgc = "\u003e"
	case BinOpTypeEQ:
		_fgc = "\u003d"
	case BinOpTypeLEQ:
		_fgc = "\u003c\u003d"
	case BinOpTypeGEQ:
		_fgc = "\u003e\u003d"
	case BinOpTypeNE:
		_fgc = "\u003c\u003e"
	case BinOpTypeConcat:
		_fgc = "\u0026"
	}
	return _dbb._bg.String() + _fgc + _dbb._fb.String()
}
func _dfeg(_eebd int) bool { return _eebd >= 0 && _eebd <= 4 }

const _eabcg = 57348

// Eval evaluates and returns a boolean.
func (_dad Bool) Eval(ctx Context, ev Evaluator) Result { return MakeBoolResult(_dad._fgg) }

// Upper is an implementation of the Excel UPPER function that returns a upper
// case version of a string.
func Upper(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0055\u0050\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_aceed := args[0].AsString()
	if _aceed.Type != ResultTypeString {
		return MakeErrorResult("\u0055\u0050\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeStringResult(_gg.ToUpper(_aceed.ValueString))
}

const _daga = 57346

// String returns a string representation of ConstArrayExpr.
func (_cag ConstArrayExpr) String() string { return "" }

// Replace is an implementation of the Excel REPLACE().
func Replace(args []Result) Result {
	_cagga, _eefa := _eacda("\u0052E\u0050\u004c\u0041\u0043\u0045", args)
	if _eefa.Type != ResultTypeEmpty {
		return _eefa
	}
	_aedba := _cagga._dcee
	_ffef := _cagga._dfgc
	_abbg := _cagga._ceeac
	_bagb := _cagga._babb
	_bced := len(_aedba)
	if _ffef > _bced {
		_ffef = _bced
	}
	_fcdf := _ffef + _abbg
	if _fcdf > _bced {
		_fcdf = _bced
	}
	_accfc := _aedba[0:_ffef] + _bagb + _aedba[_fcdf:]
	return MakeStringResult(_accfc)
}

// MakeEmptyResult is ued when parsing an empty argument.
func MakeEmptyResult() Result { return Result{Type: ResultTypeEmpty} }
func _cegd(_gdcda, _ffbfc, _baeeg Reference) string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _gdcda.Value, _ffbfc.Value, _baeeg.Value)
}

// Eval evaluates a horizontal range with prefix returning a list of results or an error.
func (_gfab PrefixHorizontalRange) Eval(ctx Context, ev Evaluator) Result {
	_dafgc := _gfab._bbff.Reference(ctx, ev)
	switch _dafgc.Type {
	case ReferenceTypeSheet:
		if _fggd(_dafgc, ctx) {
			return MakeErrorResultType(ErrorTypeName, _c.Sprintf("\u0053h\u0065e\u0074\u0020\u0025\u0073\u0020n\u006f\u0074 \u0066\u006f\u0075\u006e\u0064", _dafgc.Value))
		}
		_deaa := _gfab.horizontalRangeReference(_dafgc.Value)
		if _deeeg, _gcde := ev.GetFromCache(_deaa); _gcde {
			return _deeeg
		}
		_eafbde := ctx.Sheet(_dafgc.Value)
		_bdfca, _fegeb := _bdda(_eafbde, _gfab._abbf, _gfab._fdcc)
		_aaag := _efagg(_eafbde, ev, _bdfca, _fegeb)
		ev.SetCache(_deaa, _aaag)
		return _aaag
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dafgc.Type))
	}
}
func _gcab(_afag []Result, _gcfe string) (*amorArgs, Result) {
	_ddee := len(_afag)
	if _ddee != 6 && _ddee != 7 {
		return nil, MakeErrorResult(_gcfe + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020\u006fr\u0020s\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _afag[0].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_gcfe + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0063\u006fst \u0074o \u0062\u0065\u0020\u006e\u0075\u006d\u0062er\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_dafb := _afag[0].ValueNumber
	if _dafb < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _gcfe+"\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0063\u006f\u0073\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	_eecd, _bea := _bdea(_afag[1], "\u0064\u0061\u0074\u0065\u0020\u0070\u0075\u0072\u0063h\u0061\u0073\u0065\u0064", _gcfe)
	if _bea.Type == ResultTypeError {
		return nil, _bea
	}
	_aeaa, _bea := _bdea(_afag[2], "\u0066\u0069\u0072s\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064", _gcfe)
	if _bea.Type == ResultTypeError {
		return nil, _bea
	}
	if _aeaa < _eecd {
		return nil, MakeErrorResultType(ErrorTypeNum, _gcfe+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074 \u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020l\u0061\u0074\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0064\u0061te\u0020\u0070\u0075\u0072\u0063\u0068\u0061\u0073\u0065\u0064")
	}
	if _afag[3].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_gcfe + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006cv\u0061\u0067\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fgde := _afag[3].ValueNumber
	if _fgde < 0 || _fgde > _dafb {
		return nil, MakeErrorResultType(ErrorTypeNum, _gcfe+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061g\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0062\u0065\u0074\u0077\u0065e\u006e\u0020\u0030\u0020\u0061\u006e\u0064\u0020\u0074\u0068\u0065\u0020in\u0069\u0074\u0069\u0061\u006c\u0020\u0063\u006f\u0073\u0074")
	}
	if _afag[4].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_gcfe + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gdbf := int(_afag[4].ValueNumber)
	if _gdbf < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _gcfe+" \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0070\u0065\u0072\u0069o\u0064\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u002d\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if _afag[5].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_gcfe + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0064\u0065\u0070\u0072\u0065\u0063\u0069\u0061\u0074\u0069\u006f\u006e\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_feae := _afag[5].ValueNumber
	if _feae < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _gcfe+"\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 d\u0065\u0070\u0072\u0065\u0063\u0069\u0061\u0074\u0069\u006f\u006e\u0020\u0072\u0061t\u0065\u0020t\u006f\u0020\u0062e\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030\u0020\u0061\u006e\u0064 \u006c\u0065ss\u0020\u0074\u0068a\u006e\u0020\u0030\u002e\u0035")
	}
	_egga := 0
	if _ddee == 7 && _afag[6].Type != ResultTypeEmpty {
		if _afag[6].Type != ResultTypeNumber {
			return nil, MakeErrorResult(_gcfe + "\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_egga = int(_afag[6].ValueNumber)
		if !_dfeg(_egga) || _egga == 2 {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020"+_gcfe)
		}
	}
	return &amorArgs{_dafb, _eecd, _aeaa, _fgde, _gdbf, _feae, _egga}, _gaef
}

// String returns an empty string for EmptyExpr.
func (_aag EmptyExpr) String() string { return "" }

// Even is an implementation of the Excel EVEN() that rounds a number to the
// nearest even integer.
func Even(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0045\u0056\u0045\u004e(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_fdcdg := args[0].AsNumber()
	if _fdcdg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0056\u0045N\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cceb := _gfc.Signbit(_fdcdg.ValueNumber)
	_dgcb, _edcc := _gfc.Modf(_fdcdg.ValueNumber / 2)
	_degc := _dgcb * 2
	if _edcc != 0 {
		if !_cceb {
			_degc += 2
		} else {
			_degc -= 2
		}
	}
	return MakeNumberResult(_degc)
}

// VerticalRange is a range expression that when evaluated returns a list of Results from references like AA:IJ (all cells from columns AA to IJ).
type VerticalRange struct{ _dcac, _ddef string }

// DateValue is an implementation of the Excel DATEVALUE() function.
func DateValue(args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0044A\u0054\u0045V\u0041\u004c\u0055\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069ng\u006c\u0065\u0020s\u0074\u0072i\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_ccbf := _gg.ToLower(args[0].ValueString)
	if !_cef(_ccbf) {
		_, _, _, _, _fcd, _fdf := _cefg(_ccbf)
		if _fdf.Type == ResultTypeError {
			_fdf.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020f\u006f\u0072\u0020\u0044\u0041\u0054\u0045V\u0041\u004c\u0055\u0045"
			return _fdf
		}
		if _fcd {
			return MakeNumberResult(0)
		}
	}
	_dcbd, _dcd, _aab, _, _adbd := _agda(_ccbf)
	if _adbd.Type == ResultTypeError {
		return _adbd
	}
	return MakeNumberResult(_gfea(_dcbd, _dcd, _aab))
}

// Dollarfr implements the Excel DOLLARFR function.
func Dollarfr(args []Result) Result {
	_fggac, _dagb, _acfc := _ebfd(args, "\u0044\u004f\u004c\u004c\u0041\u0052\u0046\u0052")
	if _acfc.Type == ResultTypeError {
		return _acfc
	}
	if _dagb == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0044\u004f\u004c\u004c\u0041R\u0046\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066r\u0061\u0063\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _fggac == 0 {
		return MakeNumberResult(0)
	}
	_dffc := _fggac < 0
	if _dffc {
		_fggac = -_fggac
	}
	_eaad := float64(int(_fggac))
	_gcea := args[0].Value()
	_cgeg := _gg.Split(_gcea, "\u002e")
	_bgecf := 0.0
	if len(_cgeg) > 1 {
		var _eabfg error
		_faed := _cgeg[1]
		_bgecf, _eabfg = _ff.ParseFloat(_faed, 64)
		if _eabfg != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006fr \u0044\u004f\u004cL\u0041R\u0046\u0052")
		}
		_bbgd := float64(len(_faed))
		_bgecf /= _gfc.Pow(10, _bbgd)
	}
	_adgd := _bgecf*_dagb/_gfc.Pow(10, float64(int(_gfc.Log10(_dagb)))+1) + _eaad
	if _dffc {
		_adgd = -_adgd
	}
	return MakeNumberResult(_adgd)
}
func _agda(_ggd string) (int, int, int, bool, Result) {
	_eac := ""
	_dag := []string{}
	for _gfa, _bbg := range _fba {
		_dag = _bbg.FindStringSubmatch(_ggd)
		if len(_dag) > 1 {
			_eac = _gfa
			break
		}
	}
	if _eac == "" {
		return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
	}
	_bdge := false
	var _bdca, _acdc, _gea int
	var _fae error
	switch _eac {
	case "\u006d\u006d\u002f\u0064\u0064\u002f\u0079\u0079":
		_acdc, _fae = _ff.Atoi(_dag[1])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_gea, _fae = _ff.Atoi(_dag[3])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_bdca, _fae = _ff.Atoi(_dag[5])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		if _bdca < 0 || _bdca > 9999 || (_bdca > 99 && _bdca < 1900) {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_bdca = _gaf(_bdca)
		_bdge = _dag[8] == ""
	case "\u006dm\u0020\u0064\u0064\u002c\u0020\u0079y":
		_acdc = _agg[_dag[1]]
		_gea, _fae = _ff.Atoi(_dag[14])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_bdca, _fae = _ff.Atoi(_dag[16])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		if _bdca < 0 || _bdca > 9999 || (_bdca > 99 && _bdca < 1900) {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_bdca = _gaf(_bdca)
		_bdge = _dag[19] == ""
	case "\u0079\u0079\u002d\u006d\u006d\u002d\u0064\u0064":
		_bdbc, _adbe := _ff.Atoi(_dag[1])
		if _adbe != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_fcf, _adbe := _ff.Atoi(_dag[3])
		if _adbe != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_aad, _adbe := _ff.Atoi(_dag[5])
		if _adbe != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		if _bdbc >= 1900 && _bdbc < 10000 {
			_bdca = _bdbc
			_acdc = _fcf
			_gea = _aad
		} else if _bdbc > 0 && _bdbc < 13 {
			_acdc = _bdbc
			_gea = _fcf
			_bdca = _aad
		} else {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_bdge = _dag[8] == ""
	case "y\u0079\u002d\u006d\u006d\u0053\u0074\u0072\u002d\u0064\u0064":
		_bdca, _fae = _ff.Atoi(_dag[16])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_acdc = _agg[_dag[3]]
		_gea, _fae = _ff.Atoi(_dag[1])
		if _fae != nil {
			return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
		}
		_bdge = _dag[19] == ""
	}
	if !_gddb(_bdca, _acdc, _gea) {
		return 0, 0, 0, false, MakeErrorResultType(ErrorTypeValue, _cdeb)
	}
	return _bdca, _acdc, _gea, _bdge, _gaef
}

// Min is an implementation of the Excel MIN() function.
func Min(args []Result) Result { return _dgad(args, false) }

// Tbilleq implements the Excel TBILLEQ function.
func Tbilleq(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020t\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_daea, _cbbe, _dfdg := _geae(args[0], args[1], "\u0054B\u0049\u004c\u004c\u0045\u0051")
	if _dfdg.Type == ResultTypeError {
		return _dfdg
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0064is\u0063\u006f\u0075\u006et\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_addg := _cbbe - _daea
	if _addg > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0045\u0051\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020m\u006f\u0072e\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079\u0065\u0061r \u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074t\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_dea := args[2].ValueNumber
	if _dea <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0045Q\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074 \u0074\u006f\u0020\u0062\u0065 p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult((365 * _dea) / (360 - _dea*_addg))
}

const _bfaef int = 30

func _dcfg(_fdaa []Result, _dbfag bool, _eebf string) Result {
	var _dfgb, _dabdd string
	if _dbfag {
		_dfgb = "\u0074\u0068\u0072e\u0065"
		_dabdd = "\u006f\u0064\u0064"
	} else {
		_dfgb = "\u0074\u0077\u006f"
		_dabdd = "\u0065\u0076\u0065\u006e"
	}
	_fdege := len(_fdaa)
	if (_dbfag && _fdege < 3) || (!_dbfag && _fdege < 2) {
		return MakeErrorResult(_eebf + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020" + _dfgb + " \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0073")
	}
	if (_fdege/2*2 == _fdege) == _dbfag {
		return MakeErrorResult(_eebf + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _dabdd + " \u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020a\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_egdag := -1
	_ddea := -1
	for _bfgbb := 0; _bfgbb < _fdege; _bfgbb += 2 {
		_febf := _fdaa[_bfgbb]
		if _febf.Type != ResultTypeArray && _febf.Type != ResultTypeList {
			return MakeErrorResult(_eebf + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u006e\u0067\u0065\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065 \u006c\u0069\u0073\u0074\u0020o\u0072\u0020a\u0072\u0072\u0061\u0079")
		}
		_fgef := _bbcd(_febf)
		if _ddea == -1 {
			_ddea = len(_fgef)
			_egdag = len(_fgef[0])
		} else if len(_fgef) != _ddea || len(_fgef[0]) != _egdag {
			return MakeErrorResult(_eebf + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0061l\u006c\u0020\u0072\u0061n\u0067\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065\u0020\u0073\u0069\u007a\u0065")
		}
		if _dbfag && _bfgbb == 0 {
			_bfgbb--
		}
	}
	return _gaef
}
func (_efcfe ResultType) String() string {
	if _efcfe >= ResultType(len(_bedb)-1) {
		return _c.Sprintf("\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _efcfe)
	}
	return _bdgaf[_bedb[_efcfe]:_bedb[_efcfe+1]]
}
func (_cbea HorizontalRange) horizontalRangeReference() string {
	return _c.Sprintf("\u0025\u0064\u003a%\u0064", _cbea._ggef, _cbea._edddf)
}

// Year is an implementation of the Excel YEAR() function.
func Year(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fgce := ctx.GetEpoch()
	_fccf, _eggc := _bbfa(args[0].Value(), _fgce)
	if _eggc != nil {
		return MakeErrorResult("\u0059\u0045AR\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s a\u0020si\u006e\u0067\u006c\u0065\u0020\u0064\u0061te\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeNumberResult(float64(_fccf.Year()))
}

// Find is an implementation of the Excel FIND().
func Find(args []Result) Result {
	_fcccfd, _ecdfg := _bege("\u0046\u0049\u004e\u0044", args)
	if _ecdfg.Type != ResultTypeEmpty {
		return _ecdfg
	}
	_acbf := _fcccfd._ebda
	if _acbf == "" {
		return MakeNumberResult(1.0)
	}
	_eabdg := _fcccfd._effb
	_dfcf := _fcccfd._cbec
	_fdefc := 1
	for _gbcd := range _eabdg {
		if _fdefc < _dfcf {
			_fdefc++
			continue
		}
		_efdc := _gg.Index(_eabdg[_gbcd:], _acbf)
		if _efdc == 0 {
			return MakeNumberResult(float64(_fdefc))
		}
		_fdefc++
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// Reference returns a string reference value to a horizontal range.
func (_bccda HorizontalRange) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeHorizontalRange, Value: _bccda.horizontalRangeReference()}
}
func _beafa(_gabe []Result) Result {
	_geed := _gabe[0].ValueList
	_fgbf := len(_geed)
	switch len(_gabe) {
	case 1:
		_adfc := []Result{}
		for _, _dgecd := range _geed {
			_adfc = append(_adfc, MakeBoolResult(_dgecd.ValueNumber != 0))
		}
		return MakeListResult(_adfc)
	case 2:
		_gacc := _gabe[1]
		switch _gacc.Type {
		case ResultTypeNumber, ResultTypeString, ResultTypeEmpty:
			_dccd := []Result{}
			for _, _bbbga := range _geed {
				var _adbg Result
				if _bbbga.ValueNumber == 0 {
					_adbg = MakeBoolResult(false)
				} else {
					_adbg = _gacc
				}
				_dccd = append(_dccd, _adbg)
			}
			return MakeListResult(_dccd)
		case ResultTypeList:
			_dgee := _abda(_gacc, _fgbf)
			_daddg := []Result{}
			for _aedb, _fccc := range _geed {
				var _cdcgb Result
				if _fccc.ValueNumber == 0 {
					_cdcgb = MakeBoolResult(false)
				} else {
					_cdcgb = _dgee[_aedb]
				}
				_daddg = append(_daddg, _cdcgb)
			}
			return MakeListResult(_daddg)
		case ResultTypeArray:
			_eafb := _aaccg(_gacc, len(_gacc.ValueArray), _fgbf)
			_gddf := [][]Result{}
			for _, _gfagd := range _eafb {
				_aega := []Result{}
				for _ddge, _agbg := range _geed {
					var _gdgb Result
					if _agbg.ValueNumber == 0 {
						_gdgb = MakeBoolResult(false)
					} else {
						_gdgb = _gfagd[_ddge]
					}
					_aega = append(_aega, _gdgb)
				}
				_gddf = append(_gddf, _aega)
			}
			return MakeArrayResult(_gddf)
		}
	case 3:
		_dbfc := _gabe[1]
		_bcba := _gabe[2]
		_gbaag := _dgge(_dbfc)
		_fgbfe := _dgge(_bcba)
		if _gbaag && _fgbfe {
			_fdaeb := []Result{}
			for _, _efbfg := range _geed {
				var _cbcb Result
				if _efbfg.ValueNumber == 0 {
					_cbcb = _bcba
				} else {
					_cbcb = _dbfc
				}
				_fdaeb = append(_fdaeb, _cbcb)
			}
			return MakeListResult(_fdaeb)
		}
		if _dbfc.Type != ResultTypeArray && _bcba.Type != ResultTypeArray {
			_dbeca := _abda(_dbfc, _fgbf)
			_faaf := _abda(_bcba, _fgbf)
			_ddege := []Result{}
			for _gdad, _ggdea := range _geed {
				var _afgb Result
				if _ggdea.ValueNumber == 0 {
					_afgb = _faaf[_gdad]
				} else {
					_afgb = _dbeca[_gdad]
				}
				_ddege = append(_ddege, _afgb)
			}
			return MakeListResult(_ddege)
		}
		_dcdg, _aadd := len(_dbfc.ValueArray), len(_bcba.ValueArray)
		_gfdfa, _cddg := _dcdg, _aadd
		if _aadd > _gfdfa {
			_gfdfa, _cddg = _cddg, _gfdfa
		}
		_gfdcg := _aaccg(_dbfc, _gfdfa, _fgbf)
		_ffga := _aaccg(_bcba, _gfdfa, _fgbf)
		_gaad := [][]Result{}
		for _gfga := 0; _gfga < _gfdfa; _gfga++ {
			_acfdb := []Result{}
			for _bcfe, _agbd := range _geed {
				var _caad Result
				if _agbd.ValueNumber == 0 {
					if _gfga < _aadd {
						_caad = _ffga[_gfga][_bcfe]
					} else {
						_caad = MakeErrorResultType(ErrorTypeNA, "")
					}
				} else {
					if _gfga < _dcdg {
						_caad = _gfdcg[_gfga][_bcfe]
					} else {
						_caad = MakeErrorResultType(ErrorTypeNA, "")
					}
				}
				_acfdb = append(_acfdb, _caad)
			}
			_gaad = append(_gaad, _acfdb)
		}
		return MakeArrayResult(_gaad)
	}
	return MakeErrorResult("")
}
func _dgge(_ddgg Result) bool {
	_baeb := _ddgg.Type
	return _baeb != ResultTypeArray && _baeb != ResultTypeList
}
func _fecb(_gbed, _bgf float64, _gfae, _bcag int) float64 {
	_edba := _eeec(_gbed)
	_bggeb := _eeec(_bgf)
	_gdbe := _afa(_edba, _bggeb, _gfae, _bcag)
	return _ddeg(_gdbe, _edba, _bcag)
}

const _fbffc = _d.Millisecond * 1000
const _edec = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002d\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u002d\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

// Row implements the Excel ROW function.
func Row(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0052O\u0057\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_egca := args[0].Ref
	if _egca.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0052\u004f\u0057\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 a\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065")
	}
	_cccb, _gege := _ee.ParseCellReference(_egca.Value)
	if _gege != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _egca.Value)
	}
	return MakeNumberResult(float64(_cccb.RowIdx))
}

// Yieldmat implements the Excel YIELDMAT function.
func Yieldmat(args []Result) Result {
	_badee := len(args)
	if _badee != 5 && _badee != 6 {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0069v\u0065\u0020\u006f\u0072\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_gfbb, _gcaf, _ffcg := _geae(args[0], args[1], "\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054")
	if _ffcg.Type == ResultTypeError {
		return _ffcg
	}
	_feaab, _ffcg := _bdea(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054")
	if _ffcg.Type == ResultTypeError {
		return _ffcg
	}
	if _feaab >= _gfbb {
		return MakeErrorResult("\u0059\u0049\u0045\u004cD\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0062\u0065\u0066\u006fr\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049E\u004c\u0044\u004d\u0041T\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_fdef := args[3].ValueNumber
	if _fdef < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0049\u0045\u004c\u0044M\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_dcdbc := args[4].ValueNumber
	if _dcdbc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "Y\u0049\u0045\u004c\u0044\u004d\u0041T\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0072\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069v\u0065")
	}
	_eaebb := 0
	if _badee == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0059I\u0045\u004cD\u004d\u0041\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_eaebb = int(args[5].ValueNumber)
		if !_dfeg(_eaebb) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0059\u0049\u0045L\u0044\u004d\u0041\u0054")
		}
	}
	_fdfa, _ffcg := _fbabb(_feaab, _gcaf, _eaebb)
	if _ffcg.Type == ResultTypeError {
		return _ffcg
	}
	_bgfed, _ffcg := _fbabb(_feaab, _gfbb, _eaebb)
	if _ffcg.Type == ResultTypeError {
		return _ffcg
	}
	_dgac, _ffcg := _fbabb(_gfbb, _gcaf, _eaebb)
	if _ffcg.Type == ResultTypeError {
		return _ffcg
	}
	_cffab := 1 + _fdfa*_fdef
	_cffab /= _dcdbc/100 + _bgfed*_fdef
	_cffab--
	_cffab /= _dgac
	return MakeNumberResult(_cffab)
}
func _bege(_gfee string, _cbdga []Result) (*parsedSearchObject, Result) {
	_cgaeg := len(_cbdga)
	if _cgaeg != 2 && _cgaeg != 3 {
		return nil, MakeErrorResult(_gfee + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006fr\u0020t\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ffeb := _cbdga[0]
	if _ffeb.Type == ResultTypeError {
		return nil, _ffeb
	}
	if _ffeb.Type != ResultTypeString && _ffeb.Type != ResultTypeNumber {
		return nil, MakeErrorResult("\u0054\u0068e\u0020\u0066\u0069\u0072s\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_fdde := _cbdga[1]
	if _fdde.Type == ResultTypeError {
		return nil, _fdde
	}
	if _fdde.Type != ResultTypeString && _fdde.Type != ResultTypeNumber {
		return nil, MakeErrorResult("\u0054\u0068\u0065\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020a\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_fdfbf := _fdde.Value()
	_beceeg := _ffeb.Value()
	_dcdbb := 1
	if _cgaeg == 3 && _cbdga[2].Type != ResultTypeEmpty {
		_gcfee := _cbdga[2]
		if _gcfee.Type != ResultTypeNumber {
			return nil, MakeErrorResult("P\u006f\u0073\u0069\u0074\u0069\u006fn\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062e\u0020\u0061\u0020n\u0075m\u0062\u0065\u0072")
		}
		_dcdbb = int(_gcfee.ValueNumber)
		if _dcdbb < 1 {
			return nil, MakeErrorResultType(ErrorTypeValue, "\u0050\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u0061 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074h\u0061\u006e\u0020\u0030")
		}
		if _dcdbb > len(_fdfbf) {
			return nil, MakeErrorResultType(ErrorTypeValue, "\u0050\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u0020\u0073\u0068\u006f\u0075l\u0064\u0020\u0062\u0065\u0020\u0061 \u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074h\u0061\u006e\u0020\u0030")
		}
	}
	return &parsedSearchObject{_beceeg, _fdfbf, _dcdbb}, _gaef
}
func init() {
	_fcc()
	RegisterFunction("\u0044\u0041\u0054\u0045", Date)
	RegisterFunction("\u0044A\u0054\u0045\u0044\u0049\u0046", DateDif)
	RegisterFunction("\u0044A\u0054\u0045\u0056\u0041\u004c\u0055E", DateValue)
	RegisterFunction("\u0044\u0041\u0059", Day)
	RegisterFunction("\u0044\u0041\u0059\u0053", Days)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0044\u0041\u0059\u0053", Days)
	RegisterFunction("\u0045\u0044\u0041T\u0045", Edate)
	RegisterFunction("\u0045O\u004d\u004f\u004e\u0054\u0048", Eomonth)
	RegisterFunction("\u004d\u0049\u004e\u0055\u0054\u0045", Minute)
	RegisterFunction("\u004d\u004f\u004eT\u0048", Month)
	RegisterFunction("\u004e\u004f\u0057", Now)
	RegisterFunction("\u0054\u0049\u004d\u0045", Time)
	RegisterFunction("\u0054I\u004d\u0045\u0056\u0041\u004c\u0055E", TimeValue)
	RegisterFunction("\u0054\u004f\u0044A\u0059", Today)
	RegisterFunctionComplex("\u0059\u0045\u0041\u0052", Year)
	RegisterFunction("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043", YearFrac)
}

const _aecf = 57370

// ResultType is the type of the result
//go:generate stringer -type=ResultType
type ResultType byte

func _faff(_cfacg, _fdea Result, _eggd, _dabc bool) cmpResult {
	_cfacg = _cfacg.AsNumber()
	_fdea = _fdea.AsNumber()
	if _cfacg.Type != _fdea.Type {
		return _gfgf
	}
	if _cfacg.Type == ResultTypeNumber {
		if _cfacg.ValueNumber == _fdea.ValueNumber {
			return _effe
		}
		if _cfacg.ValueNumber < _fdea.ValueNumber {
			return _fcga
		}
		return _cgaa
	}
	if _cfacg.Type == ResultTypeString {
		_ceca := _cfacg.ValueString
		_abfe := _fdea.ValueString
		if !_eggd {
			_ceca = _gg.ToLower(_ceca)
			_abfe = _gg.ToLower(_abfe)
		}
		if _dabc {
			_cgge := _ce.Match(_abfe, _ceca)
			if _cgge {
				return _effe
			} else {
				return _cgaa
			}
		}
		return cmpResult(_gg.Compare(_ceca, _abfe))
	}
	if _cfacg.Type == ResultTypeEmpty {
		return _effe
	}
	if _cfacg.Type == ResultTypeList {
		if len(_cfacg.ValueList) < len(_fdea.ValueList) {
			return _fcga
		}
		if len(_cfacg.ValueList) > len(_fdea.ValueList) {
			return _cgaa
		}
		for _bead := range _cfacg.ValueList {
			_afgab := _faff(_cfacg.ValueList[_bead], _fdea.ValueList[_bead], _eggd, _dabc)
			if _afgab != _effe {
				return _afgab
			}
		}
		return _effe
	}
	if _cfacg.Type == ResultTypeList {
		if len(_cfacg.ValueArray) < len(_fdea.ValueArray) {
			return _fcga
		}
		if len(_cfacg.ValueArray) > len(_fdea.ValueArray) {
			return _cgaa
		}
		for _befd := range _cfacg.ValueArray {
			_ceda := _cfacg.ValueArray[_befd]
			_bedg := _cfacg.ValueArray[_befd]
			if len(_ceda) < len(_bedg) {
				return _fcga
			}
			if len(_ceda) > len(_bedg) {
				return _cgaa
			}
			for _cdcd := range _ceda {
				_cefa := _faff(_ceda[_cdcd], _bedg[_cdcd], _eggd, _dabc)
				if _cefa != _effe {
					return _cefa
				}
			}
		}
		return _effe
	}
	return _gfgf
}
func _dafg(_geaba int) bool { return _geaba == 0 || _geaba == 4 }

var _cgga string = string([]byte{92})

func _gddb(_bcfa, _cce, _bfa int) bool {
	if _cce < 1 || _cce > 12 {
		return false
	}
	if _bfa < 1 {
		return false
	}
	return _bfa <= _ebc(_bcfa, _cce)
}
func Unicode(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004fD\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fead := args[0].AsString()
	if _fead.Type != ResultTypeString {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004fD\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(_fead.ValueString) == 0 {
		return MakeErrorResult("\u0055\u004e\u0049\u0043\u004f\u0044\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 \u0061\u0020\u006e\u006f\u006e\u002d\u007a\u0065\u0072\u006f\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(float64(_fead.ValueString[0]))
}

// Coupncd implements the Excel COUPNCD function.
func Coupncd(args []Result) Result {
	_dafge, _caf := _acdf(args, "\u0043O\u0055\u0050\u004e\u0043\u0044")
	if _caf.Type == ResultTypeError {
		return _caf
	}
	_gcbg := _eeec(_dafge._fafb)
	_acbg := _eeec(_dafge._ecf)
	_ccad := _dafge._gedd
	_ddcb := _dbad(_gcbg, _acbg, _ccad)
	_ada, _ecb, _ggdg := _ddcb.Date()
	return MakeNumberResult(_gfea(_ada, int(_ecb), _ggdg))
}

// Base is an implementation of the Excel BASE function that returns a string
// form of an integer in a specified base and of a minimum length with padded
// zeros.
func Base(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0042\u0041\u0053\u0045\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0042\u0041S\u0045\u0028\u0029\u0020a\u006c\u006co\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006fs\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_bdeac := args[0].AsNumber()
	if _bdeac.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042A\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_aeda := args[1].AsNumber()
	if _aeda.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063o\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042\u0041\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_eagad := int(_aeda.ValueNumber)
	if _eagad < 0 || _eagad > 36 {
		return MakeErrorResult("\u0072\u0061\u0064\u0069\u0078\u0020m\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0074\u0068\u0065 \u0072\u0061\u006e\u0067\u0065\u0020\u005b0\u002c\u0033\u0036\u005d")
	}
	_gbddg := 0
	if len(args) > 2 {
		_dcded := args[2].AsNumber()
		if _dcded.Type != ResultTypeNumber {
			return MakeErrorResult("\u0074\u0068\u0069\u0072\u0064 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0042A\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_gbddg = int(_dcded.ValueNumber)
	}
	_bcacb := _ff.FormatInt(int64(_bdeac.ValueNumber), _eagad)
	if len(_bcacb) < _gbddg {
		_bcacb = _gg.Repeat("\u0030", _gbddg-len(_bcacb)) + _bcacb
	}
	return MakeStringResult(_bcacb)
}

// Pricemat implements the Excel PRICEMAT function.
func Pricemat(args []Result) Result {
	_efa := len(args)
	if _efa != 5 && _efa != 6 {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0066\u0069v\u0065\u0020\u006f\u0072\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_bfca, _debdf, _fcbf := _geae(args[0], args[1], "\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054")
	if _fcbf.Type == ResultTypeError {
		return _fcbf
	}
	_fbbc, _fcbf := _bdea(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054")
	if _fcbf.Type == ResultTypeError {
		return _fcbf
	}
	if _fbbc >= _bfca {
		return MakeErrorResult("\u0050\u0052\u0049\u0043E\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0062\u0065\u0066\u006fr\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052I\u0043\u0045\u004d\u0041T\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_cagb := args[3].ValueNumber
	if _cagb < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045M\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072a\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_bab := args[4].ValueNumber
	if _bab < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049C\u0045\u004d\u0041\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0079\u0069\u0065\u006c\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e \u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_afcb := 0
	if _efa == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050R\u0049\u0043E\u004d\u0041\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_afcb = int(args[5].ValueNumber)
		if !_dfeg(_afcb) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0050\u0052\u0049C\u0045\u004d\u0041\u0054")
		}
	}
	_gabb, _fcbf := _fbabb(_bfca, _debdf, _afcb)
	if _fcbf.Type == ResultTypeError {
		return _fcbf
	}
	_gccdc, _fcbf := _fbabb(_fbbc, _debdf, _afcb)
	if _fcbf.Type == ResultTypeError {
		return _fcbf
	}
	_beebae, _fcbf := _fbabb(_fbbc, _bfca, _afcb)
	if _fcbf.Type == ResultTypeError {
		return _fcbf
	}
	_faab := 1 + _gccdc*_cagb
	_ggfdg := 1 + _gabb*_bab
	return MakeNumberResult((_faab/_ggfdg - _beebae*_cagb) * 100)
}

// Eval evaluates and returns the result of an empty expression.
func (_fbg EmptyExpr) Eval(ctx Context, ev Evaluator) Result { return MakeEmptyResult() }

// Combin is an implementation of the Excel COMBINA function whic returns the
// number of combinations.
func Combin(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004d\u0042\u0049\u004e\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aaga := args[0].AsNumber()
	_adbdf := args[1].AsNumber()
	if _aaga.Type != ResultTypeNumber || _adbdf.Type != ResultTypeNumber {
		return MakeErrorResult("C\u004f\u004d\u0042\u0049\u004e\u0028)\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_cccf := _gfc.Trunc(_aaga.ValueNumber)
	_ggdcf := _gfc.Trunc(_adbdf.ValueNumber)
	if _ggdcf > _cccf {
		return MakeErrorResult("\u0043O\u004d\u0042\u0049\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006b\u0020\u003c\u003d\u0020\u006e")
	}
	if _ggdcf == _cccf || _ggdcf == 0 {
		return MakeNumberResult(1)
	}
	_fgfe := float64(1)
	for _aaggb := float64(1); _aaggb <= _ggdcf; _aaggb++ {
		_fgfe *= (_cccf + 1 - _aaggb) / _aaggb
	}
	return MakeNumberResult(_fgfe)
}

// Amordegrc implements the Excel AMORDEGRC function.
func Amordegrc(args []Result) Result {
	_abed, _ceeb := _gcab(args, "\u0041M\u004f\u0052\u0044\u0045\u0047\u0052C")
	if _ceeb.Type == ResultTypeError {
		return _ceeb
	}
	_ceb := _abed._gddd
	_bcb := _abed._fdc
	_bdgcb := _abed._aga
	_ddbb := _abed._bbd
	_ebcg := _abed._cada
	_gagf := _abed._dfbc
	if _gagf >= 0.5 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u004d\u004f\u0052\u0044\u0045\u0047R\u0043\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u0030\u002e\u0035")
	}
	_fcfe := _abed._ccbb
	_cgbc := 1.0 / _gagf
	_ggbg := 2.5
	if _cgbc < 3 {
		_ggbg = 1
	} else if _cgbc < 5 {
		_ggbg = 1.5
	} else if _cgbc <= 6 {
		_ggbg = 2
	}
	_gagf *= _ggbg
	_fffb, _ebgg := _fbabb(_bcb, _bdgcb, _fcfe)
	if _ebgg.Type == ResultTypeError {
		return MakeErrorResult("\u0069\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0065\u0073\u0020\u0066\u006f\u0072\u0020\u0041\u004d\u004f\u0052\u0044EG\u0052\u0043")
	}
	_gffb := _adgg(_fffb * _gagf * _ceb)
	_ceb -= _gffb
	_cdcg := _ceb - _ddbb
	for _cddc := 0; _cddc < _ebcg; _cddc++ {
		_gffb = _adgg(_gagf * _ceb)
		_cdcg -= _gffb
		if _cdcg < 0 {
			switch _ebcg - _cddc {
			case 0:
			case 1:
				return MakeNumberResult(_adgg(_ceb * 0.5))
			default:
				return MakeNumberResult(0)
			}
		}
		_ceb -= _gffb
	}
	return MakeNumberResult(_gffb)
}

// YearFrac is an implementation of the Excel YEARFRAC() function.
func YearFrac(args []Result) Result {
	_fbb := len(args)
	if (_fbb != 2 && _fbb != 3) || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber {
		return MakeErrorResult("Y\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006f\u0072 \u0074\u0068\u0072\u0065\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dcf := 0
	if _fbb == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("Y\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020ba\u0073\u0069\u0073\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074o \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_dcf = int(args[2].ValueNumber)
		if !_dfeg(_dcf) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0059\u0045\u0041R\u0046\u0052\u0041\u0043")
		}
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0074\u0061\u0072\u0074\u0020\u0064\u0061t\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ecg := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0045\u0041\u0052\u0046\u0052\u0041\u0043 \u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0065\u006ed\u0020\u0064\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_def := args[1].ValueNumber
	_cfgg, _fbgb := _fbabb(_ecg, _def, _dcf)
	if _fbgb.Type == ResultTypeError {
		return _fbgb
	}
	return MakeNumberResult(_cfgg)
}
func _ddeg(_bca, _egcf _d.Time, _eeee int) float64 {
	if _bca.After(_egcf) {
		_bca, _egcf = _egcf, _bca
	}
	_gacb := 0
	_aced, _dfgg, _eaed := _bca.Date()
	_aeg, _afef, _gcgf := _egcf.Date()
	_aegg, _aece := int(_dfgg), int(_afef)
	_daf, _acbc := _bgge(_aced, _aegg, _eaed, _eeee), _bgge(_aeg, _aece, _gcgf, _eeee)
	if !_dafg(_eeee) {
		return _gfea(_aeg, _aece, _acbc) - _gfea(_aced, _aegg, _daf)
	}
	if _eeee == 0 {
		if (_aegg == 2 || _daf < 30) && _gcgf == 31 {
			_acbc = 31
		} else if _aece == 2 && _acbc == _ebc(_aeg, _aece) {
			_acbc = _ebc(_aeg, 2)
		}
	} else {
		if _aegg == 2 && _daf == 30 {
			_daf = _ebc(_aced, 2)
		}
		if _aece == 2 && _acbc == 30 {
			_acbc = _ebc(_aeg, 2)
		}
	}
	if _aced < _aeg || (_aced == _aeg && _aegg < _aece) {
		_gacb = 30 - _daf + 1
		_eaed = 1
		_daf = 1
		_ecgf := _d.Date(_aced, _d.Month(_aegg), _eaed, 0, 0, 0, 0, _d.UTC).AddDate(0, 1, 0)
		if _ecgf.Year() < _aeg {
			_gacb += _acce(_ecgf.Year(), int(_ecgf.Month()), 12, _eeee)
			_ecgf = _ecgf.AddDate(0, 13-int(_ecgf.Month()), 0)
			_gacb += _dbc(_ecgf.Year(), _aeg-1, _eeee)
		}
		_gacb += _acce(_aeg, int(_ecgf.Month()), _aece-1, _eeee)
		_ecgf = _ecgf.AddDate(0, _aece-int(_ecgf.Month()), 0)
		_aegg = _ecgf.Day()
	}
	_gacb += _acbc - _daf
	if _gacb > 0 {
		return float64(_gacb)
	} else {
		return 0
	}
}

// ErrorType is a formula evaluation error type.
type ErrorType byte

const _gbagf = 57368

// Accrintm implements the Excel ACCRINTM function.
func Accrintm(args []Result) Result {
	_dafa := len(args)
	if _dafa != 4 && _dafa != 5 {
		return MakeErrorResult("A\u0043\u0043\u0052\u0049\u004e\u0054\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066o\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_beebb, _aecg := _bdea(args[0], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d")
	if _aecg.Type == ResultTypeError {
		return _aecg
	}
	_eabf, _aecg := _bdea(args[1], "\u0073e\u0074t\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065", "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d")
	if _aecg.Type == ResultTypeError {
		return _aecg
	}
	if _beebb >= _eabf {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0073\u0073\u0075\u0065\u0020d\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0065\u0061\u0072\u006c\u0069\u0065r\u0020\u0074\u0068\u0061\u006e\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065n\u0074 \u0064\u0061\u0074\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0041C\u0043\u0052I\u004e\u0054\u004d\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_eca := args[2].ValueNumber
	if _eca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061t\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0041\u0043\u0043\u0052\u0049\u004e\u0054M\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0070\u0061\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fbgg := args[3].ValueNumber
	if _fbgg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0041\u0043C\u0052\u0049\u004e\u0054\u004d \u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0061\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ecbg := 0
	if _dafa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0041C\u0043\u0052I\u004e\u0054\u004d \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_ecbg = int(args[4].ValueNumber)
		if !_dfeg(_ecbg) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0041\u0043\u0043R\u0049\u004e\u0054\u004d")
		}
	}
	_cdd, _aecg := _fbabb(_beebb, _eabf, _ecbg)
	if _aecg.Type == ResultTypeError {
		return _aecg
	}
	return MakeNumberResult(_fbgg * _eca * _cdd)
}

var _gegec = [...]int{0, 1, 1, 2, 4, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 3, 1, 3, 1, 3, 1, 3, 1, 2, 1, 1, 1, 3, 4, 1, 1, 1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 3, 1, 3, 1, 1, 0}

func _dadd(_ecfe, _ddga float64, _eeb, _faefe int) float64 {
	_affa := _eeec(_ecfe)
	_dgcg := _eeec(_ddga)
	_cfgc := _dbad(_affa, _dgcg, _eeb)
	return _ddeg(_affa, _cfgc, _faefe)
}

// NewConstArrayExpr constructs a new constant array expression with a given data.
func NewConstArrayExpr(data [][]Expression) Expression { return &ConstArrayExpr{_cff: data} }
func _bbec(_faeb []Result) (float64, float64, Result) {
	_dcbdb := 0.0
	_dbef := 1.0
	for _, _dggfff := range _faeb {
		switch _dggfff.Type {
		case ResultTypeNumber:
			_dcbdb += _dggfff.ValueNumber
			_dbef *= _bagd(_dggfff.ValueNumber)
		case ResultTypeList, ResultTypeArray:
			_abeg, _efcfg, _gbbd := _bbec(_dggfff.ListValues())
			_dcbdb += _abeg
			_dbef *= _bagd(_efcfg)
			if _gbbd.Type == ResultTypeError {
				return 0, 0, _gbbd
			}
		case ResultTypeString:
			return 0, 0, MakeErrorResult("M\u0055\u004c\u0054\u0049\u004e\u004f\u004d\u0049\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
		case ResultTypeError:
			return 0, 0, _dggfff
		}
	}
	return _dcbdb, _dbef, _gaef
}

// Columns implements the Excel COLUMNS function.
func Columns(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0043\u004fL\u0055\u004d\u004e\u0053\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075me\u006e\u0074")
	}
	_bcab := args[0]
	if _bcab.Type != ResultTypeArray && _bcab.Type != ResultTypeList {
		return MakeErrorResult("\u0043O\u004c\u0055M\u004e\u0053\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_decg := _bcab.ValueArray
	if len(_decg) == 0 {
		return MakeErrorResult("\u0043\u004f\u004c\u0055\u004d\u004e\u0053\u0020r\u0065\u0071\u0075ir\u0065\u0073\u0020\u0061\u0072\u0072a\u0079\u0020\u0074\u006f\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0031\u0020r\u006f\u0077")
	}
	return MakeNumberResult(float64(len(_decg[0])))
}

var _eeea = map[string]*_ed.Regexp{}

// Now is an implementation of the Excel NOW() function.
func Now(args []Result) Result {
	if len(args) > 0 {
		return MakeErrorResult("\u004e\u004fW\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_edbc := _d.Now()
	_, _adfd := _edbc.Zone()
	_cea := _aagg + float64(_edbc.Unix()+int64(_adfd))/86400
	return MakeNumberResult(_cea)
}

// MakeErrorResultType makes an error result of a given type with a specified
// debug message
func MakeErrorResultType(t ErrorType, msg string) Result {
	switch t {
	case ErrorTypeNull:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0055\u004c\u004c\u0021", ErrorMessage: msg}
	case ErrorTypeValue:
		return Result{Type: ResultTypeError, ValueString: "\u0023V\u0041\u004c\u0055\u0045\u0021", ErrorMessage: msg}
	case ErrorTypeRef:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u0052\u0045F\u0021", ErrorMessage: msg}
	case ErrorTypeName:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0041\u004d\u0045\u003f", ErrorMessage: msg}
	case ErrorTypeNum:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u0055M\u0021", ErrorMessage: msg}
	case ErrorTypeSpill:
		return Result{Type: ResultTypeError, ValueString: "\u0023S\u0050\u0049\u004c\u004c\u0021", ErrorMessage: msg}
	case ErrorTypeNA:
		return Result{Type: ResultTypeError, ValueString: "\u0023\u004e\u002f\u0041", ErrorMessage: msg}
	case ErrorTypeDivideByZero:
		return Result{Type: ResultTypeError, ValueString: "\u0023D\u0049\u0056\u002f\u0030\u0021", ErrorMessage: msg}
	default:
		return Result{Type: ResultTypeError, ValueString: "\u0023V\u0041\u004c\u0055\u0045\u0021", ErrorMessage: msg}
	}
}

// Cumprinc implements the Excel CUMPRINC function.
func Cumprinc(args []Result) Result {
	_cgbe, _dgaf := _ggbac(args, "\u0043\u0055\u004d\u0050\u0052\u0049\u004e\u0043")
	if _dgaf.Type == ResultTypeError {
		return _dgaf
	}
	_dccea := _cgbe._cebf
	_fbccg := _cgbe._ccde
	_efgf := _cgbe._gbea
	_cdefe := _cgbe._dbec
	_aac := _cgbe._defe
	_aeba := _cgbe._bafc
	_bdad := _cbf(_dccea, _fbccg, _efgf, 0, _aeba)
	_aaaa := 0.0
	if _cdefe == 1 {
		if _aeba == 0 {
			_aaaa = _bdad + _efgf*_dccea
		} else {
			_aaaa = _bdad
		}
		_cdefe++
	}
	for _efbf := _cdefe; _efbf <= _aac; _efbf++ {
		if _aeba == 1 {
			_aaaa += _bdad - (_cdac(_dccea, _efbf-2, _bdad, _efgf, 1)-_bdad)*_dccea
		} else {
			_aaaa += _bdad - _cdac(_dccea, _efbf-1, _bdad, _efgf, 0)*_dccea
		}
	}
	return MakeNumberResult(_aaaa)
}

const (
	_eegf countMode = iota
	_dfgf
	_cebbf
)

// Dollarde implements the Excel DOLLARDE function.
func Dollarde(args []Result) Result {
	_agc, _agad, _ffee := _ebfd(args, "\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045")
	if _ffee.Type == ResultTypeError {
		return _ffee
	}
	if _agad < 1 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072a\u0063t\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u006f\u0072 \u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0031")
	}
	if _agc == 0 {
		return MakeNumberResult(0)
	}
	_adcg := _agc < 0
	if _adcg {
		_agc = -_agc
	}
	_afbg := args[0].Value()
	_gbce := _gg.Split(_afbg, "\u002e")
	_cefb := float64(int(_agc))
	_fcbd := _gbce[1]
	_bgfg := len(_fcbd)
	_fdaef := int(_gfc.Log10(_agad)) + 1
	_abf := float64(_fdaef - _bgfg)
	_bcgg, _abb := _ff.ParseFloat(_fcbd, 64)
	if _abb != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006fr \u0044\u004f\u004cL\u0041R\u0044\u0045")
	}
	_bcgg *= _gfc.Pow(10, _abf)
	_fccd := _cefb + _bcgg/_agad
	if _adcg {
		_fccd = -_fccd
	}
	return MakeNumberResult(_fccd)
}
func (_gegcg tokenType) String() string { return _addea(int(_gegcg)) }

// Text is an implementation of the Excel TEXT function.
func Text(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("T\u0045\u0058\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	_ebdd := args[0]
	if _ebdd.Type != ResultTypeNumber && _ebdd.Type != ResultTypeString && _ebdd.Type != ResultTypeEmpty {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	if args[1].Type != ResultTypeString {
		return MakeErrorResult("\u0054E\u0058\u0054 \u0072\u0065\u0071\u0075i\u0072\u0065\u0073 \u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072gu\u006d\u0065\u006et\u0020\u0074o\u0020\u0062\u0065\u0020\u0061\u0020s\u0074\u0072i\u006e\u0067")
	}
	_bcbaa := args[1].ValueString
	switch _ebdd.Type {
	case ResultTypeNumber:
		return MakeStringResult(_cd.Number(_ebdd.ValueNumber, _bcbaa))
	case ResultTypeString:
		return MakeStringResult(_cd.String(_ebdd.ValueString, _bcbaa))
	case ResultTypeEmpty:
		return MakeStringResult(_cd.Number(0, _bcbaa))
	case ResultTypeArray, ResultTypeList:
		return MakeErrorResultType(ErrorTypeSpill, "\u0054\u0045X\u0054\u0020\u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u0077\u006f\u0072\u006b\u0020\u0077\u0069\u0074\u0068\u0020\u0061\u0072ra\u0079\u0073")
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020T\u0045\u0058\u0054")
	}
}

// Update updates references in the PrefixHorizontalRange after removing a row/column.
func (_fagc PrefixHorizontalRange) Update(q *_de.UpdateQuery) Expression { return _fagc }
func _geae(_adg, _aebb Result, _ddbc string) (float64, float64, Result) {
	_egge, _abef := _bdea(_adg, "\u0073e\u0074t\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065", _ddbc)
	if _abef.Type == ResultTypeError {
		return 0, 0, _abef
	}
	_efbe, _abef := _bdea(_aebb, "\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065", _ddbc)
	if _abef.Type == ResultTypeError {
		return 0, 0, _abef
	}
	if _egge >= _efbe {
		return 0, 0, MakeErrorResultType(ErrorTypeNum, _ddbc+"\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u006cat\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065")
	}
	return _egge, _efbe, _gaef
}

// Count implements the COUNT function.
func Count(args []Result) Result { return MakeNumberResult(_aggc(args, _eegf)) }

const (
	_ byte = iota
	_fdff
	_cegbg
	_deeb
	_fgabb
	_bbfg
)

func (_cfdbe *noCache) GetFromCache(key string) (Result, bool) { return _gaef, false }

// EmptyExpr is an empty expression.
type EmptyExpr struct{}

// ISTEXT is an implementation of the Excel ISTEXT() function.
func IsText(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u0054EX\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070t\u0073 \u0061 \u0073i\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeString)
}

// Function is a standard function whose result only depends on its arguments.
type Function func(_becec []Result) Result

// IsDBCS returns false for the invalid reference context.
func (_fbgfb *ivr) IsDBCS() bool { return false }

// String returns a string representation of FunctionCall expression.
func (_bagf FunctionCall) String() string {
	_bfee := _gb.Buffer{}
	_bfee.WriteString(_bagf._bbfgf)
	_bfee.WriteString("\u0028")
	_gbdb := len(_bagf._ebbe) - 1
	for _cdaa, _gfaae := range _bagf._ebbe {
		_bfee.WriteString(_gfaae.String())
		if _cdaa != _gbdb {
			_bfee.WriteString("\u002c")
		}
	}
	_bfee.WriteString("\u0029")
	return _bfee.String()
}

// Error is called in the case of parsing error and saves an error to a plex.
func (_gafe *plex) Error(s string) {
	_ga.Log.Debug("\u0070a\u0072s\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020\u0025\u0073", s)
	_gafe._cegf = s
}
func _gdggf(_ccbed Result, _gada *criteriaParsed) bool {
	if _ccbed.Type == ResultTypeEmpty {
		return false
	}
	if _gada._dbde {
		return _ccbed.ValueNumber == _gada._bgfgb
	} else {
		_adee := _gg.ToLower(_ccbed.ValueString)
		return _gada._ecef == _adee || _ce.Match(_gada._ecef, _adee)
	}
}

// String returns a string representation of String.
func (_gfbba String) String() string { return "\u0022" + _gfbba._geef + "\u0022" }

// Or is an implementation of the Excel OR() function and takes a variable
// number of arguments.
func Or(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004f\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cafb := false
	for _, _cgab := range args {
		switch _cgab.Type {
		case ResultTypeList, ResultTypeArray:
			_eagga := Or(_cgab.ListValues())
			if _eagga.Type == ResultTypeError {
				return _eagga
			}
			if _eagga.ValueNumber != 0 {
				_cafb = true
			}
		case ResultTypeNumber:
			if _cgab.ValueNumber != 0 {
				_cafb = true
			}
		case ResultTypeString:
			return MakeErrorResult("\u004f\u0052 \u0064\u006f\u0065\u0073\u006e\u0027\u0074\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u0065\u0020\u006f\u006e\u0020\u0073\u0074\u0072in\u0067\u0073")
		case ResultTypeError:
			return _cgab
		default:
			return MakeErrorResult("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u004f\u0052")
		}
	}
	return MakeBoolResult(_cafb)
}

// Update returns the same object as updating sheet references does not affect SheetPrefixExpr.
func (_ccfe SheetPrefixExpr) Update(q *_de.UpdateQuery) Expression { return _ccfe }

// Update updates references in the BinaryExpr after removing a row/column.
func (_efe BinaryExpr) Update(q *_de.UpdateQuery) Expression {
	_dcc := _efe
	_dcc._bg = _efe._bg.Update(q)
	_dcc._fb = _efe._fb.Update(q)
	return _dcc
}

const _egcgc = 57347

// Update updates references in the VerticalRange after removing a row/column.
func (_aecce VerticalRange) Update(q *_de.UpdateQuery) Expression {
	if q.UpdateType == _de.UpdateActionRemoveColumn {
		_cfcgd := _aecce
		if q.UpdateCurrentSheet {
			_eaeacb := q.ColumnIdx
			_cfcgd._dcac = _gca(_aecce._dcac, _eaeacb)
			_cfcgd._ddef = _gca(_aecce._ddef, _eaeacb)
		}
		return _cfcgd
	}
	return _aecce
}
func _bgbe(_bcdb, _bfgg []float64, _cbfa float64) float64 {
	_ggfd := _cbfa + 1
	_ddd := _bcdb[0]
	_aca := len(_bcdb)
	_gega := _bfgg[0]
	for _edab := 1; _edab < _aca; _edab++ {
		_ddd += _bcdb[_edab] / _gfc.Pow(_ggfd, (_bfgg[_edab]-_gega)/365)
	}
	return _ddd
}

// Lower is an implementation of the Excel LOWER function that returns a lower
// case version of a string.
func Lower(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004c\u004f\u0057\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_egae := args[0]
	switch _egae.Type {
	case ResultTypeError:
		return _egae
	case ResultTypeNumber, ResultTypeString:
		return _dead(args[0])
	case ResultTypeList:
		_dfdb := _egae.ValueList
		_bce := []Result{}
		for _, _bgga := range _dfdb {
			_deedf := _dead(_bgga)
			if _deedf.Type == ResultTypeError {
				return _deedf
			}
			_bce = append(_bce, _deedf)
		}
		return MakeListResult(_bce)
	case ResultTypeArray:
		_beddb := _egae.ValueArray
		_fgdeef := [][]Result{}
		for _, _ggga := range _beddb {
			_fafa := []Result{}
			for _, _bfgbba := range _ggga {
				_fccfd := _dead(_bfgbba)
				if _fccfd.Type == ResultTypeError {
					return _fccfd
				}
				_fafa = append(_fafa, _fccfd)
			}
			_fgdeef = append(_fgdeef, _fafa)
		}
		return MakeArrayResult(_fgdeef)
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004c\u004fW\u0045\u0052")
	}
}

// Irr implements the Excel IRR function.
func Irr(args []Result) Result {
	_ebff := len(args)
	if _ebff == 0 || _ebff > 2 {
		return MakeErrorResult("\u0049\u0052\u0052\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u006f\u0072\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeList && args[0].Type != ResultTypeArray {
		return MakeErrorResult("\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020v\u0061\u006c\u0075\u0065\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0061\u0072\u0072\u0061\u0079 \u0074\u0079\u0070\u0065")
	}
	_fefe := _bbcd(args[0])
	_feeb := []float64{}
	for _, _bggg := range _fefe {
		for _, _cdacc := range _bggg {
			if _cdacc.Type == ResultTypeNumber && !_cdacc.IsBoolean {
				_feeb = append(_feeb, _cdacc.ValueNumber)
			}
		}
	}
	_cfdb := len(_feeb)
	if len(_feeb) < 2 {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	_gfedf := 0.1
	if _ebff == 2 && args[1].Type != ResultTypeEmpty {
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("I\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_gfedf = args[1].ValueNumber
		if _gfedf <= -1 {
			return MakeErrorResult("\u0049\u0052R\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020t\u006f\u0020\u0062\u0065\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068a\u006e\u0020\u002d\u0031")
		}
	}
	_ccdg := []float64{}
	for _gafce := 0; _gafce < _cfdb; _gafce++ {
		if _gafce == 0 {
			_ccdg = append(_ccdg, 0)
		} else {
			_ccdg = append(_ccdg, _ccdg[_gafce-1]+365)
		}
	}
	return _bcbf(_feeb, _ccdg, _gfedf)
}

// Findb is an implementation of the Excel FINDB().
func Findb(ctx Context, ev Evaluator, args []Result) Result {
	if !ctx.IsDBCS() {
		return Find(args)
	}
	_feac, _bdag := _bege("\u0046\u0049\u004e\u0044", args)
	if _bdag.Type != ResultTypeEmpty {
		return _bdag
	}
	_efac := _feac._ebda
	if _efac == "" {
		return MakeNumberResult(1.0)
	}
	_gbgef := _feac._effb
	_bedd := _feac._cbec - 1
	_dgba := 1
	_abaf := 0
	for _dcgc := range _gbgef {
		if _dcgc != 0 {
			_deceg := 1
			if _dcgc-_abaf > 1 {
				_deceg = 2
			}
			_dgba += _deceg
		}
		if _dgba > _bedd {
			_gbfb := _gg.Index(_gbgef[_dcgc:], _efac)
			if _gbfb == 0 {
				return MakeNumberResult(float64(_dgba))
			}
		}
		_abaf = _dcgc
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

// Disc implements the Excel DISC function.
func Disc(args []Result) Result {
	_adab := len(args)
	if _adab != 4 && _adab != 5 {
		return MakeErrorResult("\u0044\u0049SC\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s f\u006fur\u0020\u006f\u0072\u0020\u0066\u0069\u0076e \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_fbgf, _bae, _cbef := _geae(args[0], args[1], "\u0044\u0049\u0053\u0043")
	if _cbef.Type == ResultTypeError {
		return _cbef
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gaeg := args[2].ValueNumber
	if _gaeg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0070\u0072\u0020\u0074o \u0062\u0065\u0020\u0070o\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0049S\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gaga := args[3].ValueNumber
	if _gaga <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0049\u0053\u0043\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0072e\u0064\u0065m\u0070\u0074\u0069\u006f\u006e\u0020t\u006f b\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bbga := 0
	if _adab == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0049\u0053\u0043\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bbga = int(args[4].ValueNumber)
		if !_dfeg(_bbga) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0066\u006f\u0072 \u0044\u0049\u0053\u0043")
		}
	}
	_aeed, _cbef := _fbabb(_fbgf, _bae, _bbga)
	if _cbef.Type == ResultTypeError {
		return _cbef
	}
	return MakeNumberResult((_gaga - _gaeg) / _gaga / _aeed)
}

// Int is an implementation of the Excel INT() function that rounds a number
// down to an integer.
func Int(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("I\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_deaf := args[0].AsNumber()
	if _deaf.Type != ResultTypeNumber {
		return MakeErrorResult("I\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cfed, _dbggg := _gfc.Modf(_deaf.ValueNumber)
	if _dbggg < 0 {
		_cfed--
	}
	return MakeNumberResult(_cfed)
}
func _beg(_bff float64) bool { return _bff == 1 || _bff == 2 || _bff == 4 }

// Coupdaybs implements the Excel COUPDAYBS function.
func Coupdaybs(args []Result) Result {
	_fbe, _abea := _acdf(args, "\u0043O\u0055\u0050\u0044\u0041\u0059\u0042S")
	if _abea.Type == ResultTypeError {
		return _abea
	}
	return MakeNumberResult(_fecb(_fbe._fafb, _fbe._ecf, _fbe._gedd, _fbe._bgd))
}

// Sln implements the Excel SLN function.
func Sln(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0053\u004c\u004e\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gdga := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_adff := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cecb := args[2].ValueNumber
	if _cecb == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0053\u004c\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u007a\u0065\u0072\u006f")
	}
	return MakeNumberResult((_gdga - _adff) / _cecb)
}

// Log implements the Excel LOG function which returns the log of a number. By
// default the result is base 10, however the second argument to the function
// can specify a different base.
func Log(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 o\u006e\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("L\u004f\u0047\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u006d\u0061\u0078i\u006d\u0075\u006d\u0020\u006f\u0066\u0020\u0074\u0077\u006f a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_aebc := args[0].AsNumber()
	if _aebc.Type != ResultTypeNumber {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 o\u006e\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_fgcc := 10.0
	if len(args) > 1 {
		_gegg := args[1].AsNumber()
		if _gegg.Type != ResultTypeNumber {
			return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061rg\u0075\u006d\u0065n\u0074\u0020t\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0065r\u0069\u0063")
		}
		_fgcc = args[1].ValueNumber
	}
	if _aebc.ValueNumber == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072gu\u006d\u0065\u006et\u0020\u0074o\u0020\u0062\u0065\u0020\u006e\u006fn\u002d\u007ae\u0072\u006f")
	}
	if _fgcc == 0 {
		return MakeErrorResult("\u004cO\u0047\u0028)\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073e\u0063\u006f\u006e\u0064\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u002d\u007a\u0065\u0072\u006f")
	}
	return MakeNumberResult(_gfc.Log(_aebc.ValueNumber) / _gfc.Log(_fgcc))
}

// Floor is an implementation of the FlOOR function.
func Floor(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_fgfef := args[0].AsNumber()
	if _fgfef.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	var _gbcee float64
	_gbcb := args[1].AsNumber()
	if _gbcb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0046\u004c\u004f\u004f\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gbcee = _gbcb.ValueNumber
	if _gbcee < 0 && _fgfef.ValueNumber >= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0046L\u004f\u004f\u0052")
	}
	_eagae := _fgfef.ValueNumber
	_eagae, _bfgc := _gfc.Modf(_eagae / _gbcee)
	if _bfgc != 0 {
		if _fgfef.ValueNumber < 0 && _bfgc < 0 {
			_eagae--
		}
	}
	return MakeNumberResult(_eagae * _gbcee)
}

// IsBool returns false for the invalid reference context.
func (_bgacf *ivr) IsBool(cellRef string) bool { return false }
func init() {
	RegisterFunction("\u0041\u0043\u0043\u0052\u0049\u004e\u0054\u004d", Accrintm)
	RegisterFunction("\u0041M\u004f\u0052\u0044\u0045\u0047\u0052C", Amordegrc)
	RegisterFunction("\u0041\u004d\u004f\u0052\u004c\u0049\u004e\u0043", Amorlinc)
	RegisterFunction("\u0043O\u0055\u0050\u0044\u0041\u0059\u0042S", Coupdaybs)
	RegisterFunction("\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053", Coupdays)
	RegisterFunction("\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053\u004e\u0043", Coupdaysnc)
	RegisterFunction("\u0043O\u0055\u0050\u004e\u0055\u004d", Coupnum)
	RegisterFunction("\u0043O\u0055\u0050\u004e\u0043\u0044", Coupncd)
	RegisterFunction("\u0043O\u0055\u0050\u0050\u0043\u0044", Couppcd)
	RegisterFunction("\u0043U\u004d\u0049\u0050\u004d\u0054", Cumipmt)
	RegisterFunction("\u0043\u0055\u004d\u0050\u0052\u0049\u004e\u0043", Cumprinc)
	RegisterFunction("\u0044\u0042", Db)
	RegisterFunction("\u0044\u0044\u0042", Ddb)
	RegisterFunction("\u0044\u0049\u0053\u0043", Disc)
	RegisterFunction("\u0044\u004f\u004c\u004c\u0041\u0052\u0044\u0045", Dollarde)
	RegisterFunction("\u0044\u004f\u004c\u004c\u0041\u0052\u0046\u0052", Dollarfr)
	RegisterFunction("\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e", Duration)
	RegisterFunction("\u0045\u0046\u0046\u0045\u0043\u0054", Effect)
	RegisterFunction("\u0046\u0056", Fv)
	RegisterFunction("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045", Fvschedule)
	RegisterFunction("\u0049N\u0054\u0052\u0041\u0054\u0045", Intrate)
	RegisterFunction("\u0049\u0050\u004d\u0054", Ipmt)
	RegisterFunction("\u0049\u0052\u0052", Irr)
	RegisterFunction("\u0049\u0053\u0050M\u0054", Ispmt)
	RegisterFunction("\u004dD\u0055\u0052\u0041\u0054\u0049\u004fN", Mduration)
	RegisterFunction("\u004d\u0049\u0052\u0052", Mirr)
	RegisterFunction("\u004eO\u004d\u0049\u004e\u0041\u004c", Nominal)
	RegisterFunction("\u004e\u0050\u0045\u0052", Nper)
	RegisterFunction("\u004e\u0050\u0056", Npv)
	RegisterFunction("\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E", Oddlprice)
	RegisterFunction("\u004fD\u0044\u004c\u0059\u0049\u0045\u004cD", Oddlyield)
	RegisterFunction("\u0050D\u0055\u0052\u0041\u0054\u0049\u004fN", Pduration)
	RegisterFunction("\u005fx\u006cf\u006e\u002e\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e", Pduration)
	RegisterFunction("\u0050\u004d\u0054", Pmt)
	RegisterFunction("\u0050\u0050\u004d\u0054", Ppmt)
	RegisterFunction("\u0050\u0052\u0049C\u0045", Price)
	RegisterFunction("\u0050R\u0049\u0043\u0045\u0044\u0049\u0053C", Pricedisc)
	RegisterFunction("\u0050\u0052\u0049\u0043\u0045\u004d\u0041\u0054", Pricemat)
	RegisterFunction("\u0050\u0056", Pv)
	RegisterFunction("\u0052\u0041\u0054\u0045", Rate)
	RegisterFunction("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044", Received)
	RegisterFunction("\u0052\u0052\u0049", Rri)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0052\u0052I", Rri)
	RegisterFunction("\u0053\u004c\u004e", Sln)
	RegisterFunction("\u0053\u0059\u0044", Syd)
	RegisterFunction("\u0054B\u0049\u004c\u004c\u0045\u0051", Tbilleq)
	RegisterFunction("\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045", Tbillprice)
	RegisterFunction("\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044", Tbillyield)
	RegisterFunction("\u0056\u0044\u0042", Vdb)
	RegisterFunction("\u0058\u0049\u0052\u0052", Xirr)
	RegisterFunction("\u0058\u004e\u0050\u0056", Xnpv)
	RegisterFunction("\u0059\u0049\u0045L\u0044", Yield)
	RegisterFunction("\u0059I\u0045\u004c\u0044\u0044\u0049\u0053C", Yielddisc)
	RegisterFunction("\u0059\u0049\u0045\u004c\u0044\u004d\u0041\u0054", Yieldmat)
}

// Atan2 implements the Excel ATAN2 function.  It accepts two numeric arguments,
// and the arguments are (x,y), reversed from normal to match Excel's behaviour.
func Atan2(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0041\u0054\u0041\u004e2\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077o\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	_dbce := args[0].AsNumber()
	_ddba := args[1].AsNumber()
	if _dbce.Type == ResultTypeNumber && _ddba.Type == ResultTypeNumber {
		_eead := _gfc.Atan2(_ddba.ValueNumber, _dbce.ValueNumber)
		if _eead != _eead {
			return MakeErrorResult("\u0041T\u0041N\u0032\u0020\u0072\u0065\u0074u\u0072\u006ee\u0064\u0020\u004e\u0061\u004e")
		}
		return MakeNumberResult(_eead)
	}
	for _, _beggb := range []ResultType{_dbce.Type, _ddba.Type} {
		switch _beggb {
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult("\u0041\u0054\u0041\u004e\u0032\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		case ResultTypeError:
			return _dbce
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068an\u0064\u006c\u0065\u0064\u0020\u0041\u0054\u0041\u004e2\u0028)\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _beggb))
		}
	}
	return MakeErrorResult("u\u006e\u0068\u0061\u006e\u0064\u006ce\u0064\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0066o\u0072\u0020\u0041T\u0041N\u0032\u0028\u0029")
}

type xargs struct {
	_ccab []float64
	_fade []float64
}

const _ceafce = 57351

func (_fedbg PrefixHorizontalRange) horizontalRangeReference(_fddca string) string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0064\u003a\u0025\u0064", _fddca, _fedbg._abbf, _fedbg._fdcc)
}

// Mirr implements the Excel MIRR function.
func Mirr(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u004d\u0049R\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeList && args[0].Type != ResultTypeArray {
		return MakeErrorResult("M\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0076\u0061\u006c\u0075\u0065s\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020ar\u0072\u0061\u0079 \u0074y\u0070\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049\u0052\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0069\u006e\u0061\u006e\u0063e\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_bdaa := args[1].ValueNumber + 1
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049\u0052\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0069\u006e\u0076\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_aacc := args[2].ValueNumber + 1
	if _aacc == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_fac := _bbcd(args[0])
	_eegd := float64(len(_fac))
	_aacg, _dacg := 0.0, 0.0
	_bbf, _cebb := 1.0, 1.0
	_fdfec, _bddd := false, false
	for _, _fgfg := range _fac {
		for _, _cfef := range _fgfg {
			if _cfef.Type == ResultTypeNumber && !_cfef.IsBoolean {
				_dcfa := _cfef.ValueNumber
				if _dcfa == 0 {
					continue
				} else {
					if _dcfa > 0 {
						_fdfec = true
						_dacg += _cfef.ValueNumber * _cebb
					} else {
						_bddd = true
						_aacg += _cfef.ValueNumber * _bbf
					}
					_bbf /= _bdaa
					_cebb /= _aacc
				}
			}
		}
	}
	if !_fdfec || !_bddd {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_dbdff := -_dacg / _aacg
	_dbdff *= _gfc.Pow(_aacc, _eegd-1)
	_dbdff = _gfc.Pow(_dbdff, 1/(_eegd-1))
	return MakeNumberResult(_dbdff - 1)
}

// Round is an implementation of the Excel ROUND function that rounds a number
// to a specified number of digits.
func Round(args []Result) Result { return _dgbbg(args, _ggdce) }

// Time is an implementation of the Excel TIME() function.
func Time(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0049ME\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0068re\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_ffbd := args[0].ValueNumber
	_dff := args[1].ValueNumber
	_bebf := args[2].ValueNumber
	_bcgc := _acc(_ffbd, _dff, _bebf)
	if _bcgc >= 0 {
		return MakeNumberResult(_bcgc)
	} else {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
}

// GCD implements the Excel GCD() function which returns the greatest common
// divisor of a range of numbers.
func GCD(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0047\u0043D(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0061t \u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_dccdc := []float64{}
	for _, _cdga := range args {
		switch _cdga.Type {
		case ResultTypeString:
			_aggg := _cdga.AsNumber()
			if _aggg.Type != ResultTypeNumber {
				return MakeErrorResult("\u0047\u0043D(\u0029\u0020\u006fn\u006c\u0079\u0020\u0061cce\u0070ts\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
			}
			_dccdc = append(_dccdc, _aggg.ValueNumber)
		case ResultTypeList, ResultTypeArray:
			_bgaf := GCD(_cdga.ListValues())
			if _bgaf.Type != ResultTypeNumber {
				return _bgaf
			}
			_dccdc = append(_dccdc, _bgaf.ValueNumber)
		case ResultTypeNumber:
			_dccdc = append(_dccdc, _cdga.ValueNumber)
		case ResultTypeError:
			return _cdga
		default:
			return MakeErrorResult(_c.Sprintf("\u0047\u0043\u0044()\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072t\u0065d\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cdga.Type))
		}
	}
	if _dccdc[0] < 0 {
		return MakeErrorResult("\u0047\u0043D\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(_dccdc) == 1 {
		return MakeNumberResult(_dccdc[0])
	}
	_aaff := _dccdc[0]
	for _acbea := 1; _acbea < len(_dccdc); _acbea++ {
		if _dccdc[_acbea] < 0 {
			return MakeErrorResult("\u0047\u0043D\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
		}
		_aaff = _efcge(_aaff, _dccdc[_acbea])
	}
	return MakeNumberResult(_aaff)
}
func (_fed BinOpType) String() string {
	if _fed >= BinOpType(len(_bde)-1) {
		return _c.Sprintf("\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029", _fed)
	}
	return _bcf[_bde[_fed]:_bde[_fed+1]]
}

// Intrate implements the Excel INTRATE function.
func Intrate(args []Result) Result {
	_bbbb := len(args)
	if _bbbb != 4 && _bbbb != 5 {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0066\u006f\u0075r\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_ebag, _fdb, _ebbc := _geae(args[0], args[1], "\u0049N\u0054\u0052\u0041\u0054\u0045")
	if _ebbc.Type == ResultTypeError {
		return _ebbc
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006e\u0076\u0065\u0073\u0074\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_fdcda := args[2].ValueNumber
	if _fdcda <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006e\u0076e\u0073\u0074\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u004e\u0054\u0052\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_ffdbc := args[3].ValueNumber
	if _ffdbc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u004e\u0054\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064e\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	_ccgc := 0
	if _bbbb == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0049N\u0054\u0052A\u0054\u0045\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
		}
		_ccgc = int(args[4].ValueNumber)
		if !_dfeg(_ccgc) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006eco\u0072\u0072\u0065c\u0074\u0020\u0062\u0061sis\u0020ar\u0067\u0075\u006d\u0065\u006e\u0074\u0020fo\u0072\u0020\u0049\u004e\u0054\u0052\u0041T\u0045")
		}
	}
	_bafcb, _ebbc := _fbabb(_ebag, _fdb, _ccgc)
	if _ebbc.Type == ResultTypeError {
		return _ebbc
	}
	return MakeNumberResult((_ffdbc - _fdcda) / _fdcda / _bafcb)
}

// IfError is an implementation of the Excel IFERROR() function. It takes two arguments.
func IfError(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0049\u0046\u0045\u0052\u0052\u004f\u0052\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeError {
		if args[0].Type == ResultTypeEmpty {
			return MakeNumberResult(0)
		}
		return args[0]
	}
	return args[1]
}

// LookupFunction looks up and returns a standard function or nil.
func LookupFunction(name string) Function {
	_eadgg.Lock()
	defer _eadgg.Unlock()
	if _gedce, _cdgb := _bfgfa[name]; _cdgb {
		return _gedce
	}
	return nil
}
func _adgg(_eabac float64) float64 { return float64(int(_eabac + 0.5)) }

var _aee = []*_ed.Regexp{}
var _bgac = []ri{{1000, "\u004d"}, {999, "\u0049\u004d"}, {995, "\u0056\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {499, "\u0049\u0044"}, {495, "\u0056\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// RandBetween is an implementation of the Excel RANDBETWEEN() function that returns a random
// integer in the range specified.
func RandBetween(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0052A\u004e\u0044B\u0045\u0054\u0057\u0045E\u004e\u0028\u0029 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006eu\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_beafd := args[0].AsNumber()
	_fcccf := args[1].AsNumber()
	if _beafd.Type != ResultTypeNumber || _fcccf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052A\u004e\u0044B\u0045\u0054\u0057\u0045E\u004e\u0028\u0029 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020tw\u006f\u0020\u006eu\u006d\u0065r\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	if _fcccf.ValueNumber < _beafd.ValueNumber {
		return MakeErrorResult("\u0052\u0041\u004e\u0044\u0042E\u0054\u0057\u0045\u0045\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0061\u0072\u0067\u0065r")
	}
	_dcdda := int64(_beafd.ValueNumber)
	_egedg := int64(_fcccf.ValueNumber)
	return MakeNumberResult(float64(_fbbf.Int63n(_egedg-_dcdda+1) + _dcdda))
}

type couponArgs struct {
	_fafb float64
	_ecf  float64
	_gedd int
	_bgd  int
}

// Cumipmt implements the Excel CUMIPMT function.
func Cumipmt(args []Result) Result {
	_fcg, _fge := _ggbac(args, "\u0043U\u004d\u0049\u0050\u004d\u0054")
	if _fge.Type == ResultTypeError {
		return _fge
	}
	_edc := _fcg._cebf
	_fdab := _fcg._ccde
	_gfeb := _fcg._gbea
	_dggb := _fcg._dbec
	_dcbf := _fcg._defe
	_gbaf := _fcg._bafc
	_fgdee := _cbf(_edc, _fdab, _gfeb, 0, _gbaf)
	_fbd := 0.0
	if _dggb == 1 {
		if _gbaf == 0 {
			_fbd = -_gfeb
			_dggb++
		}
	}
	for _adcd := _dggb; _adcd <= _dcbf; _adcd++ {
		if _gbaf == 1 {
			_fbd += _cdac(_edc, _adcd-2, _fgdee, _gfeb, 1) - _fgdee
		} else {
			_fbd += _cdac(_edc, _adcd-1, _fgdee, _gfeb, 0)
		}
	}
	_fbd *= _edc
	return MakeNumberResult(_fbd)
}

// Update returns the same object as updating sheet references does not affect Number.
func (_bfbab Number) Update(q *_de.UpdateQuery) Expression { return _bfbab }
func _fgge(_cbfae []Result) (bool, Result) {
	for _, _ggcg := range _cbfae {
		if _ggcg.Type == ResultTypeError {
			return true, _ggcg
		}
	}
	return false, MakeEmptyResult()
}

const _bafa = 57355

// Eomonth is an implementation of the Excel EOMONTH() function.
func Eomonth(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u004f\u004d\u004f\u004e\u0054\u0048\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	_cfe := args[1].ValueNumber
	_dccb := args[0]
	var _geab float64
	switch _dccb.Type {
	case ResultTypeEmpty:
		_geab = 0
	case ResultTypeNumber:
		_geab = _dccb.ValueNumber
	case ResultTypeString:
		_aec := DateValue([]Result{args[0]})
		if _aec.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
		}
		_geab = _aec.ValueNumber
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	_dgf := _eeec(_geab)
	_bcc := _dgf.AddDate(0, int(_cfe+1), 0)
	_ffe, _gde, _ := _bcc.Date()
	_cceg := _gfea(_ffe, int(_gde), 0)
	if _cceg < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0045\u004f\u004d\u004f\u004e\u0054\u0048")
	}
	if _ffe == 1900 && _gde == 3 {
		_cceg--
	}
	return MakeNumberResult(_cceg)
}

const _egaf = 57367

// Radians is an implementation of the Excel function RADIANS() that converts
// degrees to radians.
func Radians(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0052\u0041\u0044I\u0041\u004e\u0053\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gafd := args[0].AsNumber()
	if _gafd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0044IA\u004e\u0053\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u006eu\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(_gfc.Pi / 180.0 * _gafd.ValueNumber)
}
func _acc(_adde, _ggg, _afd float64) float64 { return (_adde*3600 + _ggg*60 + _afd) / 86400 }

var _aagg float64 = 25569.0

// Nper implements the Excel NPER function.
func Nper(args []Result) Result {
	_ebaa := len(args)
	if _ebaa < 3 || _ebaa > 5 {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067e\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u0020\u0035")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("N\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cgad := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0070\u0061y\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fabb := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_dgbf := args[2].ValueNumber
	_adbf := 0.0
	if _ebaa >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u004e\u0050\u0045\u0052\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_adbf = args[3].ValueNumber
	}
	_cffb := 0.0
	if _ebaa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("N\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_cffb = args[4].ValueNumber
		if _cffb != 0 {
			_cffb = 1
		}
	}
	_geabc := _fabb*(1+_cgad*_cffb) - _adbf*_cgad
	_fdfef := (_dgbf*_cgad + _fabb*(1+_cgad*_cffb))
	return MakeNumberResult(_gfc.Log(_geabc/_fdfef) / _gfc.Log(1+_cgad))
}
func (_debe Result) AsString() Result {
	switch _debe.Type {
	case ResultTypeNumber:
		return MakeStringResult(_debe.Value())
	default:
		return _debe
	}
}

const _acfcb = 57352

// GetWidth returns 0 for the invalid reference context.
func (_afbge *ivr) GetWidth(colIdx int) float64 { return float64(0) }
func _bbcd(_ffbde Result) [][]Result {
	switch _ffbde.Type {
	case ResultTypeArray:
		return _ffbde.ValueArray
	case ResultTypeList:
		return [][]Result{_ffbde.ValueList}
	default:
		return [][]Result{}
	}
}
func _dggc(_gcdfb []Result) Result {
	_gfgg := _gcdfb[0].ValueArray
	if len(_gcdfb) == 1 {
		_fbfa := [][]Result{}
		for _, _cacb := range _gfgg {
			_fbfa = append(_fbfa, _beafa([]Result{MakeListResult(_cacb)}).ValueList)
		}
		return MakeArrayResult(_fbfa)
	} else if len(_gcdfb) == 2 {
		_dfeb := len(_gfgg)
		_edbfd := len(_gfgg[0])
		_aggd := _aaccg(_gcdfb[1], _dfeb, _edbfd)
		_aggbg := len(_aggd)
		_acbca := [][]Result{}
		var _dcge []Result
		for _cbbf, _beba := range _gfgg {
			if _cbbf < _aggbg {
				_dcge = _aggd[_cbbf]
			} else {
				_dcge = _abda(MakeErrorResultType(ErrorTypeNA, ""), _edbfd)
			}
			_acbca = append(_acbca, _beafa([]Result{MakeListResult(_beba), MakeListResult(_dcge)}).ValueList)
		}
		return MakeArrayResult(_acbca)
	} else if len(_gcdfb) == 3 {
		_cggee := len(_gfgg)
		_egaac := len(_gfgg[0])
		_agfdf := _aaccg(_gcdfb[1], _cggee, _egaac)
		_efba := _aaccg(_gcdfb[2], _cggee, _egaac)
		_dbcab := len(_agfdf)
		_ceeaa := len(_efba)
		_gbceg := [][]Result{}
		var _cdebe, _cecd []Result
		for _feee, _cbgeg := range _gfgg {
			if _feee < _dbcab {
				_cdebe = _agfdf[_feee]
			} else {
				_cdebe = _abda(MakeErrorResultType(ErrorTypeNA, ""), _egaac)
			}
			if _feee < _ceeaa {
				_cecd = _efba[_feee]
			} else {
				_cecd = _abda(MakeErrorResultType(ErrorTypeNA, ""), _egaac)
			}
			_gbceg = append(_gbceg, _beafa([]Result{MakeListResult(_cbgeg), MakeListResult(_cdebe), MakeListResult(_cecd)}).ValueList)
		}
		return MakeArrayResult(_gbceg)
	}
	return MakeErrorResultType(ErrorTypeValue, "")
}

var _eggg = [...]int{0, -2, 1, 2, 0, 0, 0, 0, 11, 12, 13, 14, 0, 16, 5, 6, 7, 8, 22, 0, 24, 46, 0, 26, 25, 29, 30, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 18, 20, 9, 10, 0, 0, 23, 32, 33, 47, 0, 49, 51, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 0, 17, 0, 0, 15, 27, 0, 48, 53, 4, 19, 21, 28, 50, 52}

// ISEVEN is an implementation of the Excel ISEVEN() function.
func IsEven(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u0045VE\u004e\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070t\u0073 \u0061 \u0073i\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0045\u0056\u0045\u004e \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bcaf := int(args[0].ValueNumber)
	return MakeBoolResult(_bcaf == _bcaf/2*2)
}
func _dbbg(_dcef, _fee float64, _gbag, _gad int) (float64, Result) {
	_gdc, _eddd := _eeec(_dcef), _eeec(_fee)
	if _eddd.After(_gdc) {
		_dgdf := _afa(_gdc, _eddd, _gbag, _gad)
		_faa := (_eddd.Year()-_dgdf.Year())*12 + int(_eddd.Month()) - int(_dgdf.Month())
		return float64(_faa*_gbag) / 12.0, _gaef
	}
	return 0, MakeErrorResultType(ErrorTypeNum, "\u0053\u0065t\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u006d\u0061\u0074\u0075\u0072\u0069\u0074\u0079\u0020\u0064\u0061\u0074\u0065")
}

type ri struct {
	_fdeaa float64
	_cdfc  string
}

func (_feddc *Lexer) nextRaw() *node {
	for len(_feddc._gbaba) != 0 {
		_fdegf := <-_feddc._gbaba[len(_feddc._gbaba)-1]
		if _fdegf != nil {
			return _fdegf
		}
		_feddc._gbaba = _feddc._gbaba[0 : len(_feddc._gbaba)-1]
	}
	return <-_feddc._fbfbd
}

const _deggb = 57361

// Combina is an implementation of the Excel COMBINA function whic returns the
// number of combinations with repetitions.
func Combina(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004dB\u0049\u004e\u0041\u0028)\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_abde := args[0].AsNumber()
	_dccc := args[1].AsNumber()
	if _abde.Type != ResultTypeNumber || _dccc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043\u004fMB\u0049\u004e\u0041(\u0029\u0020\u0072\u0065qui\u0072es\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_aabb := _gfc.Trunc(_abde.ValueNumber)
	_ecegf := _gfc.Trunc(_dccc.ValueNumber)
	if _aabb < _ecegf {
		return MakeErrorResult("\u0043O\u004d\u0042\u0049\u004e\u0041\u0028\u0029\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u006e\u0020\u003e\u0020\u006b")
	}
	if _aabb == 0 {
		return MakeNumberResult(0)
	}
	args[0] = MakeNumberResult(_aabb + _ecegf - 1)
	args[1] = MakeNumberResult(_aabb - 1)
	return Combin(args)
}
func _gffe(_gbad Context, _efbde, _aededd string) (string, string) {
	_dfaf := _efbde + "\u0031"
	_ddada := _gbad.LastRow(_efbde)
	_edce := _aededd + _ff.Itoa(_ddada)
	return _dfaf, _edce
}

// String returns a string representation of CellRef.
func (_ad CellRef) String() string { return _ad._acb }

const _egdgb = 57360

func (_eded *ivr) NamedRange(ref string) Reference { return ReferenceInvalid }

var _bcfbd = [...]int{-1, 1, 1, -1, -2, 0}

func _ccac(_bbegd, _fcdfg Expression) (Expression, Expression, error) {
	_dfed, _eece := _bbegd.(CellRef)
	if !_eece {
		return nil, nil, _e.New(_c.Sprintf("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020%\u0073", _bbegd.String()))
	}
	_cbff, _eece := _fcdfg.(CellRef)
	if !_eece {
		return nil, nil, _e.New(_c.Sprintf("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020%\u0073", _fcdfg.String()))
	}
	_badec, _dbaa := _ee.ParseCellReference(_dfed._acb)
	if _dbaa != nil {
		return nil, nil, _dbaa
	}
	_accfd, _eegeb := _ee.ParseCellReference(_cbff._acb)
	if _eegeb != nil {
		return nil, nil, _eegeb
	}
	_ecebe := false
	if _badec.RowIdx > _accfd.RowIdx {
		_ecebe = true
		_badec.RowIdx, _accfd.RowIdx = _accfd.RowIdx, _badec.RowIdx
	}
	if _badec.ColumnIdx > _accfd.ColumnIdx {
		_ecebe = true
		_badec.ColumnIdx, _accfd.ColumnIdx = _accfd.ColumnIdx, _badec.ColumnIdx
		_badec.Column, _accfd.Column = _accfd.Column, _badec.Column
	}
	if _ecebe {
		return NewCellRef(_badec.String()), NewCellRef(_accfd.String()), nil
	}
	return _bbegd, _fcdfg, nil
}

// Averagea implements the AVERAGEA function, AVERAGEA counts cells that contain
// text as a zero where AVERAGE ignores them entirely.
func Averagea(args []Result) Result {
	_defd, _eeadf := _bdfc(args, true)
	if _eeadf == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0041\u0056\u0045\u0052AG\u0045\u0020\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065r\u006f")
	}
	return MakeNumberResult(_defd / _eeadf)
}

// Code is an implementation of the Excel CODE function that returns the first
// character of the string as a number.
func Code(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u004f\u0044\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ffdbb := args[0].AsString()
	if _ffdbb.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u004f\u0044\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if len(_ffdbb.ValueString) == 0 {
		return MakeNumberResult(0)
	}
	return MakeNumberResult(float64(_ffdbb.ValueString[0]))
}

const _gbc = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0054\u0049\u004d\u0045\u0056\u0041\u004c\u0055\u0045"

// FloorMath implements _xlfn.FLOOR.MATH which rounds numbers down to the
// nearest multiple of the second argument, toward or away from zero as
// specified by the third argument.
func FloorMath(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u002e\u004dA\u0054\u0048\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0046\u004c\u004f\u004f\u0052\u002e\u004dA\u0054\u0048\u0028)\u0020\u0061\u006c\u006co\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_afgae := args[0].AsNumber()
	if _afgae.Type != ResultTypeNumber {
		return MakeErrorResult("f\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020FL\u004f\u004f\u0052\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073t \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ffac := float64(1)
	if _afgae.ValueNumber < 0 {
		_ffac = -1
	}
	if len(args) > 1 {
		_ebdb := args[1].AsNumber()
		if _ebdb.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061r\u0067\u0075\u006den\u0074\u0020\u0074\u006f\u0020\u0046L\u004f\u004f\u0052\u002e\u004d\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006db\u0065\u0072")
		}
		_ffac = _ebdb.ValueNumber
	}
	_fabbd := float64(1)
	if len(args) > 2 {
		_fegeg := args[2].AsNumber()
		if _fegeg.Type != ResultTypeNumber {
			return MakeErrorResult("t\u0068\u0069\u0072\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020FL\u004f\u004f\u0052\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073t \u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_fabbd = _fegeg.ValueNumber
	}
	if len(args) == 1 {
		return MakeNumberResult(_gfc.Floor(_afgae.ValueNumber))
	}
	_dgfgb := _afgae.ValueNumber
	_dgfgb, _aedf := _gfc.Modf(_dgfgb / _ffac)
	if _aedf != 0 && _afgae.ValueNumber < 0 && _fabbd > 0 {
		_dgfgb++
	}
	return MakeNumberResult(_dgfgb * _ffac)
}

// Reference returns an invalid reference for Error.
func (_gbdae Error) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// ReferenceType is a type of reference
//go:generate stringer -type=ReferenceType
type ReferenceType byte

// Trim is an implementation of the Excel TRIM function that removes leading,
// trailing and consecutive spaces.
func Trim(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0054\u0052\u0049\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gaefa := args[0].AsString()
	if _gaefa.Type != ResultTypeString {
		return MakeErrorResult("\u0054\u0052\u0049\u004d\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_bfae := _gb.Buffer{}
	_cbccf := false
	_cdcee := false
	_eabaa := 0
	for _, _cdbf := range _gaefa.ValueString {
		_dbcee := _cdbf == ' '
		if _dbcee {
			if !_cbccf {
				continue
			}
			if !_cdcee {
				_eabaa++
				_bfae.WriteRune(_cdbf)
			}
		} else {
			_eabaa = 0
			_cbccf = true
			_bfae.WriteRune(_cdbf)
		}
		_cdcee = _dbcee
	}
	_bfae.Truncate(_bfae.Len() - _eabaa)
	return MakeStringResult(_bfae.String())
}

// Ipmt implements the Excel IPMT function.
func Ipmt(args []Result) Result {
	_gab := len(args)
	if _gab < 4 || _gab > 6 {
		return MakeErrorResult("\u0049P\u004d\u0054\u0020\u0072\u0065\u0071\u0075ir\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074s\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065n\u0020\u0066ou\u0072\u0020\u0061n\u0064\u0020\u0073\u0069\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("I\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_deba := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004dT\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_efdd := args[1].ValueNumber
	if _efdd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0050\u004d\u0054\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cbac := args[2].ValueNumber
	if _cbac <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062er\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_gaec := args[3].ValueNumber
	_bdgd := 0.0
	if _gab > 4 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0049\u0050\u004d\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_bdgd = args[4].ValueNumber
	}
	_gdgg := 0
	if _gab == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("I\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_gdgg = int(args[5].ValueNumber)
		if _gdgg != 0 {
			_gdgg = 1
		}
	}
	return MakeNumberResult(_dgdfc(_deba, _efdd, _cbac, _gaec, _bdgd, _gdgg))
}

// ISERROR is an implementation of the Excel ISERROR() function.
func IsError(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("I\u0053\u0045\u0052\u0052\u004f\u0052(\u0029\u0020\u0061\u0063\u0063\u0065p\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError)
}
func _bfde(_eced _d.Time) bool { return _d.Now().Sub(_eced) >= _fbffc }

var _fdgg = [...]struct {
	_gfbeg int
	_ecfad int
	_eaeaf string
}{}

func _cfbbe(_ceadd float64, _cbeg *criteriaRegex) bool {
	_ddec, _fddf := _ff.ParseFloat(_cbeg._acdd, 64)
	if _fddf != nil {
		return false
	}
	switch _cbeg._cadca {
	case _fdff:
		return _ceadd == _ddec
	case _cegbg:
		return _ceadd <= _ddec
	case _deeb:
		return _ceadd >= _ddec
	case _fgabb:
		return _ceadd < _ddec
	case _bbfg:
		return _ceadd > _ddec
	}
	return false
}

// Update returns the same object as updating sheet references does not affect String.
func (_fbgfbd String) Update(q *_de.UpdateQuery) Expression { return _fbgfbd }

// Column implements the Excel COLUMN function.
func Column(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0043\u004f\u004c\u0055M\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_dfge := args[0].Ref
	if _dfge.Type != ReferenceTypeCell {
		return MakeErrorResult("\u0043\u004f\u004c\u0055\u004dN\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006e\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e")
	}
	_dbgg, _edggc := _ee.ParseCellReference(_dfge.Value)
	if _edggc != nil {
		return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _dfge.Value)
	}
	return MakeNumberResult(float64(_dbgg.ColumnIdx + 1))
}

// LastRow returns 0 for the invalid reference context.
func (_gcaba *ivr) LastRow(colFrom string) int { return 0 }

// MakeNumberResult constructs a number result.
func MakeNumberResult(v float64) Result {
	if v == _gfc.Copysign(0, -1) {
		v = 0
	}
	return Result{Type: ResultTypeNumber, ValueNumber: v}
}

// Ifs is an implementation of the Excel IFS() function.
func Ifs(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("I\u0046\u0053\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061t\u0020\u006c\u0065\u0061\u0073\u0074\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	for _ecfcf := 0; _ecfcf < len(args)-1; _ecfcf += 2 {
		if args[_ecfcf].ValueNumber == 1 {
			return args[_ecfcf+1]
		}
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

// Reference returns an invalid reference for Bool.
func (_ddc Bool) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

type amorArgs struct {
	_gddd float64
	_fdc  float64
	_aga  float64
	_bbd  float64
	_cada int
	_dfbc float64
	_ccbb int
}

func _acce(_ecc, _cfd, _aagf, _gcdg int) int {
	if _cfd > _aagf {
		return 0
	}
	if _dafg(_gcdg) {
		return (_aagf - _cfd + 1) * 30
	}
	_bfg := 0
	for _aeceg := _cfd; _aeceg <= _aagf; _aeceg++ {
		_bfg += _ebc(_ecc, _aeceg)
	}
	return _bfg
}

// Ispmt implements the Excel ISPMT function.
func Ispmt(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("\u0049\u0053P\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_geb := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0070e\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dede := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069o\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cega := args[2].ValueNumber
	if _cega <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049S\u0050\u004d\u0054\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072i\u006f\u0064\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062er\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065s\u0065\u006e\u0074\u0020\u0076\u0061\u006cu\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bfgf := args[3].ValueNumber
	return MakeNumberResult(_bfgf * _geb * (_dede/_cega - 1))
}

// LastEvalIsRef returns if last evaluation with the evaluator was a reference.
func (_eg *defEval) LastEvalIsRef() bool { return _eg._gba }
func (_cgg *defEval) checkLastEvalIsRef(_bbe Context, _dab Expression) {
	switch _dab.(type) {
	case FunctionCall:
		switch _dab.(FunctionCall)._bbfgf {
		case "\u0049\u0053\u0052E\u0046":
			for _, _agd := range _dab.(FunctionCall)._ebbe {
				switch _agd.(type) {
				case CellRef, Range, HorizontalRange, VerticalRange, NamedRangeRef, PrefixExpr, PrefixRangeExpr, PrefixHorizontalRange, PrefixVerticalRange:
					_deef := _agd.Eval(_bbe, _cgg)
					_cgg._gba = !(_deef.Type == ResultTypeError && _deef.ValueString == "\u0023\u004e\u0041\u004d\u0045\u003f")
				default:
					_cgg._gba = false
				}
			}
		}
	}
}

const _cgaca int = 30

func _gcae(_gefa []Result) []rangeIndex {
	_eacf := []rangeIndex{}
	_gcef := len(_gefa)
	for _bded := 0; _bded < _gcef-1; _bded += 2 {
		_dbebb := []rangeIndex{}
		_gggd := _bbcd(_gefa[_bded])
		_gede := _affeg(_gefa[_bded+1])
		if _bded == 0 {
			for _ceeae, _gedb := range _gggd {
				for _cggbf, _ebdf := range _gedb {
					if _cead(_ebdf, _gede) {
						_dbebb = append(_dbebb, rangeIndex{_ceeae, _cggbf})
					}
				}
			}
		} else {
			for _, _adabf := range _eacf {
				_degd := _gggd[_adabf._gefg][_adabf._facdg]
				if _cead(_degd, _gede) {
					_dbebb = append(_dbebb, _adabf)
				}
			}
		}
		if len(_dbebb) == 0 {
			return []rangeIndex{}
		}
		_eacf = _dbebb[:]
	}
	return _eacf
}

// Mod is an implementation of the Excel MOD function which returns the
// remainder after division. It requires two numeric argumnts.
func Mod(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004d\u004fD(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0074wo\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_eefe := args[0].AsNumber()
	_edafd := args[1].AsNumber()
	if _eefe.Type != ResultTypeNumber || _edafd.Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u004fD(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0074wo\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	if _edafd.ValueNumber == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "M\u004fD\u0028\u0029\u0020\u0064\u0069\u0076\u0069\u0064e\u0020\u0062\u0079\u0020ze\u0072\u006f")
	}
	_afcg, _abgee := _gfc.Modf(_eefe.ValueNumber / _edafd.ValueNumber)
	if _abgee < 0 {
		_afcg--
	}
	return MakeNumberResult(_eefe.ValueNumber - _edafd.ValueNumber*_afcg)
}

// Amorlinc implements the Excel AMORLINC function.
func Amorlinc(args []Result) Result {
	_affac, _ccbef := _gcab(args, "\u0041\u004d\u004f\u0052\u004c\u0049\u004e\u0043")
	if _ccbef.Type == ResultTypeError {
		return _ccbef
	}
	_acg := _affac._gddd
	_ecfc := _affac._fdc
	_ccfd := _affac._aga
	_aceaa := _affac._bbd
	_dabf := _affac._cada
	_efcd := _affac._dfbc
	_bace := _affac._ccbb
	_bcff, _fgd := _fbabb(_ecfc, _ccfd, _bace)
	if _fgd.Type == ResultTypeError {
		return MakeErrorResult("\u0069\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0064\u0061\u0074\u0065\u0073 \u0066o\u0072\u0020\u0041\u004d\u004f\u0052\u004cI\u004e\u0043")
	}
	_ccgd := _bcff * _efcd * _acg
	if _dabf == 0 {
		return MakeNumberResult(_ccgd)
	}
	_fbggd := _acg * _efcd
	_fbbb := _acg - _aceaa
	_deefg := int((_fbbb - _ccgd) / _fbggd)
	if _dabf <= _deefg {
		return MakeNumberResult(_fbggd)
	} else if _dabf == _deefg+1 {
		return MakeNumberResult(_fbbb - _fbggd*float64(_deefg) - _ccgd)
	} else {
		return MakeNumberResult(0)
	}
}

// False is an implementation of the Excel FALSE() function. It takes no
// arguments.
func False(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0046A\u004c\u0053\u0045\u0020\u0074\u0061\u006b\u0065\u0073\u0020\u006eo\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(false)
}

// ConstArrayExpr is a constant array expression.
type ConstArrayExpr struct{ _cff [][]Expression }

var _fbbf *_gf.Rand

// NewString constructs a new string expression.
func NewString(v string) Expression {
	v = _gg.Replace(v, "\u0022\u0022", "\u0022", -1)
	return String{_geef: v}
}
func (_faddg *Lexer) lex(_gdded _ef.Reader) {
	_bbfgd, _agfa, _acgc := 0, 0, 0
	_bffe := -1
	_degge, _ccegbc, _bdfb := 0, 0, 0
	_ = _bdfb
	_fbgae := 1
	_ = _fbgae
	_befea := make([]byte, 4096)
	_ddde := false
	for !_ddde {
		_caebc := 0
		if _degge > 0 {
			_caebc = _agfa - _degge
		}
		_agfa = 0
		_edecfc, _adfag := _gdded.Read(_befea[_caebc:])
		if _edecfc == 0 || _adfag != nil {
			_ddde = true
		}
		_acgc = _edecfc + _caebc
		if _acgc < len(_befea) {
			_bffe = _acgc
		}
		{
			_bbfgd = _bfaef
			_degge = 0
			_ccegbc = 0
			_bdfb = 0
		}
		{
			var _gecce int
			var _ffgd uint
			if _agfa == _acgc {
				goto _eggdf
			}
			if _bbfgd == 0 {
				goto _eegc
			}
		_gcagf:
			_gecce = int(_adfcc[_bbfgd])
			_ffgd = uint(_dfbff[_gecce])
			_gecce++
			for ; _ffgd > 0; _ffgd-- {
				_gecce++
				switch _dfbff[_gecce-1] {
				case 2:
					_degge = _agfa
				}
			}
			switch _bbfgd {
			case 30:
				switch _befea[_agfa] {
				case 34:
					goto _cagge
				case 35:
					goto _dbdgd
				case 36:
					goto _ffaec
				case 38:
					goto _bdde
				case 39:
					goto _cdec
				case 40:
					goto _gdfe
				case 41:
					goto _eefg
				case 42:
					goto _cebg
				case 43:
					goto _dcccd
				case 44:
					goto _gbcg
				case 45:
					goto _debda
				case 47:
					goto _bdfaf
				case 58:
					goto _ebfcd
				case 59:
					goto _ffgbe
				case 60:
					goto _aggca
				case 61:
					goto _bcdd
				case 62:
					goto _cdcgbb
				case 63:
					goto _agdaf
				case 70:
					goto _cdcef
				case 84:
					goto _cgffd
				case 92:
					goto _acede
				case 94:
					goto _effbf
				case 95:
					goto _dcgad
				case 123:
					goto _dgged
				case 125:
					goto _dcafd
				}
				switch {
				case _befea[_agfa] < 65:
					switch {
					case _befea[_agfa] > 37:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _eceb
						}
					case _befea[_agfa] >= 33:
						goto _agdaf
					}
				case _befea[_agfa] > 90:
					switch {
					case _befea[_agfa] > 93:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _abdg
						}
					case _befea[_agfa] >= 91:
						goto _agdaf
					}
				default:
					goto _gcefg
				}
				goto _cedaf
			case 1:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _faae
				case 123:
					goto _faae
				case 125:
					goto _faae
				}
				switch {
				case _befea[_agfa] < 37:
					if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
						goto _faae
					}
				case _befea[_agfa] > 45:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _faae
						}
					case _befea[_agfa] >= 58:
						goto _faae
					}
				default:
					goto _faae
				}
				goto _cedaf
			case 0:
				goto _eegc
			case 2:
				if _befea[_agfa] == 34 {
					goto _aeadf
				}
				goto _cagge
			case 31:
				if _befea[_agfa] == 34 {
					goto _cagge
				}
				goto _fgfda
			case 3:
				switch _befea[_agfa] {
				case 78:
					goto _fbbfc
				case 82:
					goto _fbfe
				}
				goto _agdaf
			case 4:
				switch _befea[_agfa] {
				case 47:
					goto _bdbab
				case 85:
					goto _gfbdg
				}
				goto _agdaf
			case 5:
				if _befea[_agfa] == 65 {
					goto _cecag
				}
				goto _agdaf
			case 6:
				switch _befea[_agfa] {
				case 76:
					goto _agacd
				case 77:
					goto _fdfbg
				}
				goto _agdaf
			case 7:
				if _befea[_agfa] == 76 {
					goto _fdfbg
				}
				goto _agdaf
			case 8:
				if _befea[_agfa] == 33 {
					goto _cecag
				}
				goto _agdaf
			case 9:
				if _befea[_agfa] == 69 {
					goto _ffgcdd
				}
				goto _agdaf
			case 10:
				if _befea[_agfa] == 70 {
					goto _cfbec
				}
				goto _agdaf
			case 11:
				if _befea[_agfa] == 33 {
					goto _dcfce
				}
				goto _agdaf
			case 12:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _agdaf
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _agdaf
						}
					case _befea[_agfa] >= 34:
						goto _agdaf
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] < 65:
						if 58 <= _befea[_agfa] && _befea[_agfa] <= 63 {
							goto _agdaf
						}
					case _befea[_agfa] > 90:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _agdaf
						}
					default:
						goto _gebf
					}
				default:
					goto _bceb
				}
				goto _cedaf
			case 13:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _agdaf
				case 58:
					goto _dgabf
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _agdaf
						}
					case _befea[_agfa] >= 34:
						goto _agdaf
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _agdaf
						}
					case _befea[_agfa] >= 59:
						goto _agdaf
					}
				default:
					goto _bceb
				}
				goto _cedaf
			case 14:
				if _befea[_agfa] == 36 {
					goto _fbcd
				}
				if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
					goto _gead
				}
				goto _faae
			case 15:
				if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
					goto _gead
				}
				goto _faae
			case 32:
				if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
					goto _gead
				}
				goto _cgefgb
			case 16:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 47:
					goto _agdaf
				case 58:
					goto _adae
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 45:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _bcbfd
						}
					case _befea[_agfa] >= 34:
						goto _agdaf
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] > 90:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _agdaf
						}
					case _befea[_agfa] >= 65:
						goto _gebf
					}
				default:
					goto _agdaf
				}
				goto _cedaf
			case 17:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _faae
				case 123:
					goto _faae
				case 125:
					goto _faae
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _faae
						}
					case _befea[_agfa] >= 34:
						goto _faae
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _faae
						}
					case _befea[_agfa] >= 58:
						goto _faae
					}
				default:
					goto _bcbfd
				}
				goto _cedaf
			case 33:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _deae
				case 123:
					goto _deae
				case 125:
					goto _deae
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _deae
						}
					case _befea[_agfa] >= 34:
						goto _deae
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _deae
						}
					case _befea[_agfa] >= 58:
						goto _deae
					}
				default:
					goto _bcbfd
				}
				goto _cedaf
			case 18:
				if _befea[_agfa] == 36 {
					goto _addb
				}
				if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
					goto _fdeda
				}
				goto _faae
			case 19:
				if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
					goto _fdeda
				}
				goto _faae
			case 34:
				if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
					goto _fdeda
				}
				goto _addgd
			case 20:
				switch _befea[_agfa] {
				case 39:
					goto _agdaf
				case 42:
					goto _agdaf
				case 47:
					goto _agdaf
				case 58:
					goto _agdaf
				case 63:
					goto _agdaf
				}
				if 91 <= _befea[_agfa] && _befea[_agfa] <= 93 {
					goto _agdaf
				}
				goto _ccgbeg
			case 21:
				switch _befea[_agfa] {
				case 39:
					goto _cdebca
				case 42:
					goto _agdaf
				case 47:
					goto _agdaf
				case 58:
					goto _agdaf
				case 63:
					goto _agdaf
				}
				if 91 <= _befea[_agfa] && _befea[_agfa] <= 93 {
					goto _agdaf
				}
				goto _ccgbeg
			case 22:
				if _befea[_agfa] == 33 {
					goto _gegcd
				}
				goto _agdaf
			case 35:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _afae
				case 58:
					goto _dgabf
				case 101:
					goto _dced
				case 123:
					goto _cbaag
				case 125:
					goto _cbaag
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 47 {
							goto _cbaag
						}
					case _befea[_agfa] >= 34:
						goto _cbaag
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _cbaag
						}
					case _befea[_agfa] >= 59:
						goto _cbaag
					}
				default:
					goto _eceb
				}
				goto _cedaf
			case 36:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _cbaag
				case 101:
					goto _dced
				case 123:
					goto _cbaag
				case 125:
					goto _cbaag
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _cbaag
						}
					case _befea[_agfa] >= 34:
						goto _cbaag
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _cbaag
						}
					case _befea[_agfa] >= 58:
						goto _cbaag
					}
				default:
					goto _afae
				}
				goto _cedaf
			case 23:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _geedc
				case 123:
					goto _geedc
				case 125:
					goto _geedc
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _geedc
						}
					case _befea[_agfa] >= 34:
						goto _geedc
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _geedc
						}
					case _befea[_agfa] >= 58:
						goto _geedc
					}
				default:
					goto _adcda
				}
				goto _cedaf
			case 37:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 47:
					goto _cbaag
				case 123:
					goto _cbaag
				case 125:
					goto _cbaag
				}
				switch {
				case _befea[_agfa] < 48:
					switch {
					case _befea[_agfa] > 35:
						if 37 <= _befea[_agfa] && _befea[_agfa] <= 45 {
							goto _cbaag
						}
					case _befea[_agfa] >= 34:
						goto _cbaag
					}
				case _befea[_agfa] > 57:
					switch {
					case _befea[_agfa] > 63:
						if 91 <= _befea[_agfa] && _befea[_agfa] <= 94 {
							goto _cbaag
						}
					case _befea[_agfa] >= 58:
						goto _cbaag
					}
				default:
					goto _adcda
				}
				goto _cedaf
			case 38:
				switch _befea[_agfa] {
				case 61:
					goto _efged
				case 62:
					goto _agaa
				}
				goto _bdcc
			case 39:
				if _befea[_agfa] == 61 {
					goto _cdgc
				}
				goto _dbeg
			case 24:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _agdaf
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				default:
					goto _agdaf
				}
				goto _cedaf
			case 40:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _fcda
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fcda
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 41:
				switch _befea[_agfa] {
				case 46:
					goto _ffcb
				case 92:
					goto _ffcb
				case 95:
					goto _ffcb
				}
				switch {
				case _befea[_agfa] < 65:
					if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
						goto _ffcb
					}
				case _befea[_agfa] > 90:
					if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
						goto _ffcb
					}
				default:
					goto _ffcb
				}
				goto _gebd
			case 42:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 43:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _deae
				case 125:
					goto _deae
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _deae
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					default:
						goto _deae
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fcda
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _deae
					}
				default:
					goto _deae
				}
				goto _cedaf
			case 44:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _faae
				case 125:
					goto _faae
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _faae
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _faae
					}
				default:
					goto _faae
				}
				goto _cedaf
			case 25:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 65:
					goto _dbda
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _agdaf
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 66 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				default:
					goto _agdaf
				}
				goto _cedaf
			case 45:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 76:
					goto _badga
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 46:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 83:
					goto _abff
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 47:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 69:
					goto _bccca
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 26:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 79:
					goto _begde
				case 82:
					goto _eafga
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _agdaf
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				default:
					goto _agdaf
				}
				goto _cedaf
			case 48:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 68:
					goto _bfgbbf
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 49:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 79:
					goto _beecf
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 50:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 36:
					goto _daba
				case 40:
					goto _eeddg
				case 46:
					goto _fcda
				case 58:
					goto _adae
				case 85:
					goto _abff
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 59:
					switch {
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _cbgba
						}
					case _befea[_agfa] >= 34:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _fbffe
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 27:
				switch _befea[_agfa] {
				case 46:
					goto _ffcb
				case 92:
					goto _ffcb
				case 95:
					goto _ffcb
				}
				switch {
				case _befea[_agfa] < 65:
					if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
						goto _ffcb
					}
				case _befea[_agfa] > 90:
					if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
						goto _ffcb
					}
				default:
					goto _ffcb
				}
				goto _agdaf
			case 28:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 120:
					goto _cfff
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _agdaf
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				default:
					goto _agdaf
				}
				goto _cedaf
			case 51:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 108:
					goto _efbda
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 52:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 102:
					goto _cbcbc
				case 110:
					goto _fagd
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 53:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 110:
					goto _eddgb
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 54:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _dbdgg
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 55:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _adfgb
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _adfgb
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 56:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 40:
					goto _cagbf
				case 46:
					goto _adfgb
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _adfgb
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _adfgb
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 57:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 109:
					goto _eddee
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 58:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _bcccd
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _gebd
				case 125:
					goto _gebd
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _gebd
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _gebd
					}
				default:
					goto _gebd
				}
				goto _cedaf
			case 59:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ebfgf
				case 123:
					goto _faae
				case 125:
					goto _faae
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _faae
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _faae
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ebfgf
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _faae
					}
				default:
					goto _faae
				}
				goto _cedaf
			case 29:
				switch _befea[_agfa] {
				case 33:
					goto _dfac
				case 46:
					goto _ccbfa
				case 92:
					goto _ffcb
				case 95:
					goto _ccbfa
				case 123:
					goto _agdaf
				case 125:
					goto _agdaf
				}
				switch {
				case _befea[_agfa] < 58:
					switch {
					case _befea[_agfa] < 37:
						if 34 <= _befea[_agfa] && _befea[_agfa] <= 35 {
							goto _agdaf
						}
					case _befea[_agfa] > 47:
						if 48 <= _befea[_agfa] && _befea[_agfa] <= 57 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				case _befea[_agfa] > 63:
					switch {
					case _befea[_agfa] < 91:
						if 65 <= _befea[_agfa] && _befea[_agfa] <= 90 {
							goto _ccbfa
						}
					case _befea[_agfa] > 94:
						if 97 <= _befea[_agfa] && _befea[_agfa] <= 122 {
							goto _ccbfa
						}
					default:
						goto _agdaf
					}
				default:
					goto _agdaf
				}
				goto _cedaf
			}
		_agdaf:
			_bbfgd = 0
			goto _geadc
		_cedaf:
			_bbfgd = 1
			goto _geadc
		_cagge:
			_bbfgd = 2
			goto _geadc
		_dbdgd:
			_bbfgd = 3
			goto _geadc
		_fbbfc:
			_bbfgd = 4
			goto _geadc
		_bdbab:
			_bbfgd = 5
			goto _geadc
		_gfbdg:
			_bbfgd = 6
			goto _geadc
		_agacd:
			_bbfgd = 7
			goto _geadc
		_fdfbg:
			_bbfgd = 8
			goto _geadc
		_fbfe:
			_bbfgd = 9
			goto _geadc
		_ffgcdd:
			_bbfgd = 10
			goto _geadc
		_cfbec:
			_bbfgd = 11
			goto _geadc
		_ffaec:
			_bbfgd = 12
			goto _geadc
		_bceb:
			_bbfgd = 13
			goto _geadc
		_dgabf:
			_bbfgd = 14
			goto _geadc
		_fbcd:
			_bbfgd = 15
			goto _geadc
		_gebf:
			_bbfgd = 16
			goto _geadc
		_daba:
			_bbfgd = 17
			goto _geadc
		_adae:
			_bbfgd = 18
			goto _geadc
		_addb:
			_bbfgd = 19
			goto _geadc
		_cdec:
			_bbfgd = 20
			goto _geadc
		_ccgbeg:
			_bbfgd = 21
			goto _geadc
		_cdebca:
			_bbfgd = 22
			goto _geadc
		_dced:
			_bbfgd = 23
			goto _geadc
		_gcefg:
			_bbfgd = 24
			goto _geadc
		_cdcef:
			_bbfgd = 25
			goto _geadc
		_cgffd:
			_bbfgd = 26
			goto _geadc
		_acede:
			_bbfgd = 27
			goto _geadc
		_dcgad:
			_bbfgd = 28
			goto _geadc
		_abdg:
			_bbfgd = 29
			goto _geadc
		_faae:
			_bbfgd = 30
			goto _eacgf
		_dfac:
			_bbfgd = 30
			goto _cecdb
		_cecag:
			_bbfgd = 30
			goto _dccdd
		_dcfce:
			_bbfgd = 30
			goto _aefd
		_gegcd:
			_bbfgd = 30
			goto _aedfa
		_geedc:
			_bbfgd = 30
			goto _abdea
		_eeddg:
			_bbfgd = 30
			goto _egadg
		_bdde:
			_bbfgd = 30
			goto _ggbf
		_gdfe:
			_bbfgd = 30
			goto _fbgcg
		_eefg:
			_bbfgd = 30
			goto _caaf
		_cebg:
			_bbfgd = 30
			goto _cdfb
		_dcccd:
			_bbfgd = 30
			goto _eafbf
		_gbcg:
			_bbfgd = 30
			goto _fegbf
		_debda:
			_bbfgd = 30
			goto _dfea
		_bdfaf:
			_bbfgd = 30
			goto _fbcde
		_ebfcd:
			_bbfgd = 30
			goto _gcabg
		_ffgbe:
			_bbfgd = 30
			goto _fabda
		_bcdd:
			_bbfgd = 30
			goto _ageef
		_effbf:
			_bbfgd = 30
			goto _dacab
		_dgged:
			_bbfgd = 30
			goto _cbccc
		_dcafd:
			_bbfgd = 30
			goto _gedfb
		_fgfda:
			_bbfgd = 30
			goto _agdf
		_cgefgb:
			_bbfgd = 30
			goto _eabag
		_deae:
			_bbfgd = 30
			goto _eedf
		_addgd:
			_bbfgd = 30
			goto _ggaa
		_cbaag:
			_bbfgd = 30
			goto _gaecea
		_bdcc:
			_bbfgd = 30
			goto _bgggc
		_efged:
			_bbfgd = 30
			goto _acbgf
		_agaa:
			_bbfgd = 30
			goto _cfgf
		_dbeg:
			_bbfgd = 30
			goto _bgbde
		_cdgc:
			_bbfgd = 30
			goto _bbge
		_gebd:
			_bbfgd = 30
			goto _cbbae
		_cagbf:
			_bbfgd = 30
			goto _edeaa
		_aeadf:
			_bbfgd = 31
			goto _fbagb
		_gead:
			_bbfgd = 32
			goto _geadc
		_bcbfd:
			_bbfgd = 33
			goto _aegce
		_fdeda:
			_bbfgd = 34
			goto _geadc
		_eceb:
			_bbfgd = 35
			goto _fbed
		_afae:
			_bbfgd = 36
			goto _fbed
		_adcda:
			_bbfgd = 37
			goto _fbed
		_aggca:
			_bbfgd = 38
			goto _geadc
		_cdcgbb:
			_bbfgd = 39
			goto _geadc
		_fcda:
			_bbfgd = 40
			goto _dgag
		_ffcb:
			_bbfgd = 41
			goto _geadc
		_ccbfa:
			_bbfgd = 42
			goto _dgag
		_cbgba:
			_bbfgd = 43
			goto _aegce
		_fbffe:
			_bbfgd = 44
			goto _dgag
		_bccca:
			_bbfgd = 44
			goto _gcacd
		_beecf:
			_bbfgd = 44
			goto _ccae
		_dbda:
			_bbfgd = 45
			goto _dgag
		_badga:
			_bbfgd = 46
			goto _dgag
		_abff:
			_bbfgd = 47
			goto _dgag
		_begde:
			_bbfgd = 48
			goto _dgag
		_bfgbbf:
			_bbfgd = 49
			goto _dgag
		_eafga:
			_bbfgd = 50
			goto _dgag
		_cfff:
			_bbfgd = 51
			goto _dgag
		_efbda:
			_bbfgd = 52
			goto _dgag
		_cbcbc:
			_bbfgd = 53
			goto _dgag
		_eddgb:
			_bbfgd = 54
			goto _dgag
		_dbdgg:
			_bbfgd = 55
			goto _dgag
		_adfgb:
			_bbfgd = 56
			goto _dgag
		_fagd:
			_bbfgd = 57
			goto _dgag
		_eddee:
			_bbfgd = 58
			goto _dgag
		_bcccd:
			_bbfgd = 59
			goto _dgag
		_ebfgf:
			_bbfgd = 59
			goto _ccea
		_dccdd:
			_gecce = 3
			goto _bcggb
		_aefd:
			_gecce = 5
			goto _bcggb
		_cecdb:
			_gecce = 7
			goto _bcggb
		_aedfa:
			_gecce = 9
			goto _bcggb
		_egadg:
			_gecce = 11
			goto _bcggb
		_edeaa:
			_gecce = 13
			goto _bcggb
		_ggbf:
			_gecce = 15
			goto _bcggb
		_cbccc:
			_gecce = 17
			goto _bcggb
		_gedfb:
			_gecce = 19
			goto _bcggb
		_fbgcg:
			_gecce = 21
			goto _bcggb
		_caaf:
			_gecce = 23
			goto _bcggb
		_eafbf:
			_gecce = 25
			goto _bcggb
		_dfea:
			_gecce = 27
			goto _bcggb
		_cdfb:
			_gecce = 29
			goto _bcggb
		_fbcde:
			_gecce = 31
			goto _bcggb
		_dacab:
			_gecce = 33
			goto _bcggb
		_ageef:
			_gecce = 35
			goto _bcggb
		_acbgf:
			_gecce = 37
			goto _bcggb
		_bbge:
			_gecce = 39
			goto _bcggb
		_cfgf:
			_gecce = 41
			goto _bcggb
		_gcabg:
			_gecce = 43
			goto _bcggb
		_fabda:
			_gecce = 45
			goto _bcggb
		_fegbf:
			_gecce = 47
			goto _bcggb
		_gaecea:
			_gecce = 49
			goto _bcggb
		_eedf:
			_gecce = 51
			goto _bcggb
		_eabag:
			_gecce = 53
			goto _bcggb
		_ggaa:
			_gecce = 55
			goto _bcggb
		_cbbae:
			_gecce = 57
			goto _bcggb
		_agdf:
			_gecce = 59
			goto _bcggb
		_bgggc:
			_gecce = 61
			goto _bcggb
		_bgbde:
			_gecce = 63
			goto _bcggb
		_abdea:
			_gecce = 65
			goto _bcggb
		_eacgf:
			_gecce = 67
			goto _bcggb
		_gcacd:
			_gecce = 72
			goto _bcggb
		_fbed:
			_gecce = 75
			goto _bcggb
		_aegce:
			_gecce = 78
			goto _bcggb
		_ccae:
			_gecce = 81
			goto _bcggb
		_ccea:
			_gecce = 84
			goto _bcggb
		_dgag:
			_gecce = 87
			goto _bcggb
		_fbagb:
			_gecce = 90
			goto _bcggb
		_bcggb:
			_ffgd = uint(_dfbff[_gecce])
			_gecce++
			for ; _ffgd > 0; _ffgd-- {
				_gecce++
				switch _dfbff[_gecce-1] {
				case 3:
					_ccegbc = _agfa + 1
				case 4:
					_bdfb = 1
				case 5:
					_bdfb = 2
				case 6:
					_bdfb = 3
				case 7:
					_bdfb = 4
				case 8:
					_bdfb = 11
				case 9:
					_bdfb = 14
				case 10:
					_bdfb = 15
				case 11:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_bafa, _befea[_degge:_ccegbc])
					}
				case 12:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_gdce, _befea[_degge:_ccegbc])
					}
				case 13:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_eebc, _befea[_degge:_ccegbc-1])
					}
				case 14:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_eebc, _befea[_degge+1:_ccegbc-2])
					}
				case 15:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_deggf, _befea[_degge:_ccegbc-1])
					}
				case 16:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_deggf, _befea[_degge:_ccegbc-1])
					}
				case 17:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_dbcdd, _befea[_degge:_ccegbc])
					}
				case 18:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_egdgb, _befea[_degge:_ccegbc])
					}
				case 19:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_deggb, _befea[_degge:_ccegbc])
					}
				case 20:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_dagc, _befea[_degge:_ccegbc])
					}
				case 21:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_dbdg, _befea[_degge:_ccegbc])
					}
				case 22:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_bdcb, _befea[_degge:_ccegbc])
					}
				case 23:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_aead, _befea[_degge:_ccegbc])
					}
				case 24:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_gcafg, _befea[_degge:_ccegbc])
					}
				case 25:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_egaf, _befea[_degge:_ccegbc])
					}
				case 26:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_gbagf, _befea[_degge:_ccegbc])
					}
				case 27:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_gfce, _befea[_degge:_ccegbc])
					}
				case 28:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_cdbc, _befea[_degge:_ccegbc])
					}
				case 29:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_eagab, _befea[_degge:_ccegbc])
					}
				case 30:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_bddgc, _befea[_degge:_ccegbc])
					}
				case 31:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_gdeeee, _befea[_degge:_ccegbc])
					}
				case 32:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_edfc, _befea[_degge:_ccegbc])
					}
				case 33:
					_ccegbc = _agfa + 1
					{
						_faddg.emit(_degb, _befea[_degge:_ccegbc])
					}
				case 34:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_gbca, _befea[_degge:_ccegbc])
					}
				case 35:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_afec, _befea[_degge:_ccegbc])
					}
				case 36:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_daga, _befea[_degge:_ccegbc])
					}
				case 37:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_egcgc, _befea[_degge:_ccegbc])
					}
				case 38:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_ceafce, _befea[_degge:_ccegbc])
					}
				case 39:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_feffe, _befea[_degge+1:_ccegbc-1])
					}
				case 40:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_aecf, _befea[_degge:_ccegbc])
					}
				case 41:
					_ccegbc = _agfa
					_agfa--
					{
						_faddg.emit(_gbdfc, _befea[_degge:_ccegbc])
					}
				case 42:
					_agfa = (_ccegbc) - 1
					{
						_faddg.emit(_gbca, _befea[_degge:_ccegbc])
					}
				case 43:
					switch _bdfb {
					case 0:
						{
							_bbfgd = 0
							goto _geadc
						}
					case 1:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_acfcb, _befea[_degge:_ccegbc])
						}
					case 2:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_gbca, _befea[_degge:_ccegbc])
						}
					case 3:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_afec, _befea[_degge:_ccegbc])
						}
					case 4:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_adbge, _befea[_degge:_ccegbc])
						}
					case 11:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_eabcg, _befea[_degge:_ccegbc])
						}
					case 14:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_ceafce, _befea[_degge:_ccegbc])
						}
					case 15:
						{
							_agfa = (_ccegbc) - 1
							_faddg.emit(_feffe, _befea[_degge+1:_ccegbc-1])
						}
					}
				}
			}
			goto _geadc
		_geadc:
			_gecce = int(_dbea[_bbfgd])
			_ffgd = uint(_dfbff[_gecce])
			_gecce++
			for ; _ffgd > 0; _ffgd-- {
				_gecce++
				switch _dfbff[_gecce-1] {
				case 0:
					_degge = 0
				case 1:
					_bdfb = 0
				}
			}
			if _bbfgd == 0 {
				goto _eegc
			}
			if _agfa++; _agfa != _acgc {
				goto _gcagf
			}
		_eggdf:
			{
			}
			if _agfa == _bffe {
				switch _bbfgd {
				case 1:
					goto _faae
				case 2:
					goto _faae
				case 31:
					goto _fgfda
				case 14:
					goto _faae
				case 15:
					goto _faae
				case 32:
					goto _cgefgb
				case 17:
					goto _faae
				case 33:
					goto _deae
				case 18:
					goto _faae
				case 19:
					goto _faae
				case 34:
					goto _addgd
				case 35:
					goto _cbaag
				case 36:
					goto _cbaag
				case 23:
					goto _geedc
				case 37:
					goto _cbaag
				case 38:
					goto _bdcc
				case 39:
					goto _dbeg
				case 40:
					goto _gebd
				case 41:
					goto _gebd
				case 42:
					goto _gebd
				case 43:
					goto _deae
				case 44:
					goto _faae
				case 45:
					goto _gebd
				case 46:
					goto _gebd
				case 47:
					goto _gebd
				case 48:
					goto _gebd
				case 49:
					goto _gebd
				case 50:
					goto _gebd
				case 51:
					goto _gebd
				case 52:
					goto _gebd
				case 53:
					goto _gebd
				case 54:
					goto _gebd
				case 55:
					goto _gebd
				case 56:
					goto _gebd
				case 57:
					goto _gebd
				case 58:
					goto _gebd
				case 59:
					goto _faae
				}
			}
		_eegc:
			{
			}
		}
		if _degge > 0 {
			copy(_befea[0:], _befea[_degge:])
		}
	}
	_ = _bffe
	if _bbfgd == _adaa {
		_faddg.emit(_egegf, nil)
	}
	close(_faddg._fbfbd)
}

const _dba = "(\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002d" + _dfb + "-\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"
const (
	BinOpTypeUnknown BinOpType = iota
	BinOpTypePlus
	BinOpTypeMinus
	BinOpTypeMult
	BinOpTypeDiv
	BinOpTypeExp
	BinOpTypeLT
	BinOpTypeGT
	BinOpTypeEQ
	BinOpTypeLEQ
	BinOpTypeGEQ
	BinOpTypeNE
	BinOpTypeConcat
)

// And is an implementation of the Excel AND() function.
func And(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0041\u004e\u0044 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061t\u0020l\u0065a\u0073t\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dfbg := true
	for _, _bgdf := range args {
		_bgdf = _bgdf.AsNumber()
		switch _bgdf.Type {
		case ResultTypeList, ResultTypeArray:
			_egaa := And(_bgdf.ListValues())
			if _egaa.Type == ResultTypeError {
				return _egaa
			}
			if _egaa.ValueNumber == 0 {
				_dfbg = false
			}
		case ResultTypeNumber:
			if _bgdf.ValueNumber == 0 {
				_dfbg = false
			}
		case ResultTypeString:
			return MakeErrorResult("\u0041\u004e\u0044\u0020\u0064\u006f\u0065\u0073\u006e\u0027t\u0020\u006f\u0070\u0065\u0072\u0061\u0074e\u0020\u006f\u006e\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0073")
		case ResultTypeError:
			return _bgdf
		default:
			return MakeErrorResult("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0061\u0072\u0067u\u006de\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0041\u004e\u0044")
		}
	}
	return MakeBoolResult(_dfbg)
}
func _gfdb(_cgdd []Result, _eddf string) (*durationArgs, Result) {
	_cgae := len(_cgdd)
	if _cgae != 5 && _cgae != 6 {
		return nil, MakeErrorResult(_eddf + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0066\u0069\u0076\u0065\u0020\u006fr\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gdbb, _abgg, _feg := _geae(_cgdd[0], _cgdd[1], _eddf)
	if _feg.Type == ResultTypeError {
		return nil, _feg
	}
	_eea := _cgdd[2]
	if _eea.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eddf + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0063\u006fupo\u006e r\u0061\u0074\u0065\u0020\u006f\u0066\u0020ty\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_bfbb := _eea.ValueNumber
	if _bfbb < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0043\u006f\u0075po\u006e\u0020\u0072\u0061\u0074\u0065\u0020\u0073\u0068o\u0075l\u0064 \u006eo\u0074\u0020\u0062\u0065\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_eabd := _cgdd[3]
	if _eabd.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eddf + " \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0079\u0069\u0065\u006cd\u0020\u0072\u0061\u0074\u0065\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_gaacg := _eabd.ValueNumber
	if _gaacg < 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006c\u0064\u0020r\u0061\u0074\u0065\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u006ft\u0020\u0062\u0065\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	_edg := _cgdd[4]
	if _edg.Type != ResultTypeNumber {
		return nil, MakeErrorResult(_eddf + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u0065\u0071u\u0065n\u0063y\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_beceg := float64(int(_edg.ValueNumber))
	if !_beg(_beceg) {
		return nil, MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_gcdf := 0
	if _cgae == 6 && _cgdd[5].Type != ResultTypeEmpty {
		_afee := _cgdd[5]
		if _afee.Type != ResultTypeNumber {
			return nil, MakeErrorResult(_eddf + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020b\u0061\u0073\u0069\u0073\u0020\u006f\u0066 \u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_gcdf = int(_afee.ValueNumber)
		if !_dfeg(_gcdf) {
			return nil, MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062a\u0073\u0069\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020"+_eddf)
		}
	}
	return &durationArgs{_gdbb, _abgg, _bfbb, _gaacg, _beceg, _gcdf}, _gaef
}
func (_caeb *yyParserImpl) Lookahead() int { return _caeb._bgbfg }

// Median implements the MEDIAN function that returns the median of a range of
// values.
func Median(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004d\u0045D\u0049\u0041\u004e\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020l\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cfcgf := _cgef(args)
	_eaf.Float64s(_cfcgf)
	var _gbbgg float64
	if len(_cfcgf)%2 == 0 {
		_gbbgg = (_cfcgf[len(_cfcgf)/2-1] + _cfcgf[len(_cfcgf)/2]) / 2
	} else {
		_gbbgg = _cfcgf[len(_cfcgf)/2]
	}
	return MakeNumberResult(_gbbgg)
}

// CeilingPrecise is an implementation of the CEILING.PRECISE function which
// returns the ceiling of a number.
func CeilingPrecise(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002eP\u0052\u0045\u0043IS\u0045\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020o\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0043\u0045I\u004c\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_gdgga := args[0].AsNumber()
	if _gdgga.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069r\u0073\u0074\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_aadbe := float64(1)
	if _gdgga.ValueNumber < 0 {
		_aadbe = -1
	}
	if len(args) > 1 {
		_daab := args[1].AsNumber()
		if _daab.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043E\u0049L\u0049\u004e\u0047\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_aadbe = _gfc.Abs(_daab.ValueNumber)
	}
	if len(args) == 1 {
		return MakeNumberResult(_gfc.Ceil(_gdgga.ValueNumber))
	}
	_bgaeb := _gdgga.ValueNumber
	_bgaeb, _egag := _gfc.Modf(_bgaeb / _aadbe)
	if _egag != 0 {
		if _gdgga.ValueNumber > 0 {
			_bgaeb++
		}
	}
	return MakeNumberResult(_bgaeb * _aadbe)
}
func init() {
	RegisterFunction("\u0043\u0048\u004f\u004f\u0053\u0045", Choose)
	RegisterFunction("\u0043\u004f\u004c\u0055\u004d\u004e", Column)
	RegisterFunction("\u0043O\u004c\u0055\u004d\u004e\u0053", Columns)
	RegisterFunction("\u0049\u004e\u0044E\u0058", Index)
	RegisterFunctionComplex("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054", Indirect)
	RegisterFunctionComplex("\u004f\u0046\u0046\u0053\u0045\u0054", Offset)
	RegisterFunction("\u004d\u0041\u0054C\u0048", Match)
	RegisterFunction("\u0048L\u004f\u004f\u004b\u0055\u0050", HLookup)
	RegisterFunction("\u004c\u0041\u0052G\u0045", Large)
	RegisterFunction("\u004c\u004f\u004f\u004b\u0055\u0050", Lookup)
	RegisterFunction("\u0052\u004f\u0057", Row)
	RegisterFunction("\u0052\u004f\u0057\u0053", Rows)
	RegisterFunction("\u0053\u004d\u0041L\u004c", Small)
	RegisterFunction("\u0056L\u004f\u004f\u004b\u0055\u0050", VLookup)
	RegisterFunction("\u0054R\u0041\u004e\u0053\u0050\u004f\u0053E", Transpose)
}
func _eadg(_dgbb []string, _egfb int) string { return _ff.Itoa(len(_dgbb[len(_dgbb)-1-_egfb])) }

// MakeArrayResult constructs an array result (matrix).
func MakeArrayResult(arr [][]Result) Result { return Result{Type: ResultTypeArray, ValueArray: arr} }

// Today is an implementation of the Excel TODAY() function.
func Today(args []Result) Result {
	if len(args) > 0 {
		return MakeErrorResult("\u0054\u004f\u0044A\u0059\u0020\u0064\u006fe\u0073\u006e\u0027\u0074\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_agfd := _d.Now()
	_, _gcb := _agfd.Zone()
	_bec := _fccg(_eec, _agfd.Unix()+int64(_gcb)) + 1
	return MakeNumberResult(_bec)
}
func _fded() {
	_eedd = _ed.MustCompile("\u005e\u0030\u002b\u0024")
	_aafg = _ed.MustCompile("\u005e\u0028\u0028\u0023|0\u0029\u002b\u002c\u0029\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u0028\u003b\u007c$\u0029")
	_cdce = _ed.MustCompile("\u005e\u0028\u0023\u007c\u0030\u007c\u002c\u0029\u002a\u005f\u005c\u0029\u003b")
	_dedac = _ed.MustCompile("\u005e\u0030\u002b\u005c\u002e\u0028\u0030\u002b\u0029\u0024")
	_ggee = _ed.MustCompile("\u005e\u0028\u0028\u0023\u007c\u0030\u0029\u002b\u002c\u0029+\u0028\u0023\u007c\u0030\u0029\u002b\u005c.\u0028\u0030\u002b\u0029\u002e\u002a\u0028\u003b\u007c\u0024\u0029")
	_eccc = _ed.MustCompile("^\u0028\u005f\u007c\u002d\u007c\u0020)\u002b\u005c\u002a\u0020\u0023\u002b\u002c\u0023\u002b0\u005c\u002e\u00280\u002b)\u002e\u002a\u003b")
	_afbf = _ed.MustCompile("\u005e\u0028\u0028\u0023\u007c\u0030)\u002b\u002c\u0029\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u005c\u002e\u0028(\u0023\u007c\u0030\u0029\u002b\u0029\u005f\\\u0029\u002e\u002a\u003b")
	_ddfad = _ed.MustCompile("\u005e\u0028\u0023\u007c0)\u002b\u005c\u002e\u0028\u0028\u0023\u007c\u0030\u0029\u002b\u0029\u0025\u0024")
	_edcb = _ed.MustCompile("\u005c\u005b\u005c$\u005c\u0024\u002d\u002e+\u005c\u005d\u0028\u005c\u002a\u0020\u0029?\u0028\u0023\u007c\u0030\u0029\u002b\u002c\u0028\u0023\u007c\u0030\u0029\u002b\u003b")
	_agdbg = _ed.MustCompile("\u005c[\u005c\u0024\\\u0024\u002d\u002e+\u005c\u005d\u0028\u005c\u002a\u0020\u0029?\u0028\u0023\u007c\u0030\u0029\u002b,\u0028\u0023\u007c\u0030\u0029\u002b\u005c\u002e\u0028\u0028\u0023|\u0030\u007c\u002d\u0029\u002b\u0029\u002e\u002a\u003b")
	_egff = _ed.MustCompile("\u005e(\u0028\u0023|\u0030\u0029\u002b,\u0029\u002b\u0028\u0023\u007c\u0030\u0029+\u0028\u005c\u002e\u0028\u0028\u0023|\u0030\u007c\u002d\u0029\u002b\u0029\u0029\u003f\u002e\u002b\u005c[\u005c\u0024\u002e\u002b\u005c\u005d\u002e\u002a\u003b")
	_ddce = _ed.MustCompile("\u005e\u004d\u002b(\u002f\u007c\u0020\u007c\u002c\u007c\u0022\u007c" + _cgga + _cgga + "\u0029\u002b\u0044\u002b\u0028\u002f\u007c\u0020\u007c\u002c\u007c\u0022\u007c" + _cgga + _cgga + "\u0029\u002b\u0059+\u0024")
	_bcfb = _ed.MustCompile("\u005e\u0044\u002b\u0028\u002f\u007c\u0020\u007c\u005c\u002e\u007c\u0022\u007c" + _cgga + _cgga + "\u0029\u002b\u004d\u002b\u0028\u002f\u007c\u0020\u007c\\\u002e\u007c\u0022\u007c" + _cgga + _cgga + "\u0029\u002b\u0059+\u0024")
	_bbdf = _ed.MustCompile("\u005e\u0028\u0023|\u0030\u0029\u002b\u005c.\u0028\u0028\u0023\u007c\u0030\u0029\u002a)\u0045\u005c\u002b\u0028\u0023\u007c\u0030\u0029\u002b\u0028\u003b\u007c\u0024\u0029")
	_eaga = _ed.MustCompile("\u005e.\u002a\u005f\u005c\u0029\u002e\u002a;")
}

// NewPrefixHorizontalRange constructs a new full rows range with prefix.
func NewPrefixHorizontalRange(pfx Expression, v string) Expression {
	_gdfbe := _gg.Split(v, "\u003a")
	if len(_gdfbe) != 2 {
		return nil
	}
	_cebc, _ := _ff.Atoi(_gdfbe[0])
	_ffdf, _ := _ff.Atoi(_gdfbe[1])
	if _cebc > _ffdf {
		_cebc, _ffdf = _ffdf, _cebc
	}
	return PrefixHorizontalRange{_bbff: pfx, _abbf: _cebc, _fdcc: _ffdf}
}
func _addea(_ecbb int) string {
	if _ecbb >= 1 && _ecbb-1 < len(_acad) {
		if _acad[_ecbb-1] != "" {
			return _acad[_ecbb-1]
		}
	}
	return _c.Sprintf("\u0074\u006f\u006b\u002d\u0025\u0076", _ecbb)
}

const _cdbc = 57372

func _dgad(_dffeb []Result, _acgd bool) Result {
	_fdbd := "\u004d\u0049\u004e"
	if _acgd {
		_fdbd = "\u004d\u0049\u004e\u0041"
	}
	if len(_dffeb) == 0 {
		return MakeErrorResult(_fdbd + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061s\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgdb := _gfc.MaxFloat64
	for _, _dfadb := range _dffeb {
		switch _dfadb.Type {
		case ResultTypeNumber:
			if (_acgd || !_dfadb.IsBoolean) && _dfadb.ValueNumber < _dgdb {
				_dgdb = _dfadb.ValueNumber
			}
		case ResultTypeList, ResultTypeArray:
			_afgbe := _dgad(_dfadb.ListValues(), _acgd)
			if _afgbe.ValueNumber < _dgdb {
				_dgdb = _afgbe.ValueNumber
			}
		case ResultTypeEmpty:
		case ResultTypeString:
			_baaf := 0.0
			if _acgd {
				_baaf = _dfadb.AsNumber().ValueNumber
			}
			if _baaf < _dgdb {
				_dgdb = _baaf
			}
		default:
			_ga.Log.Debug("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020"+_fdbd+"\u0028\u0029\u0020\u0061rg\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dfadb.Type)
		}
	}
	if _dgdb == _gfc.MaxFloat64 {
		_dgdb = 0
	}
	return MakeNumberResult(_dgdb)
}

const (
	_ggdce rmode = iota
	_cbfe
	_dfddc
)

func _gfd(_abe BinOpType, _fd []Result, _bf Result) Result {
	_deca := []Result{}
	switch _bf.Type {
	case ResultTypeNumber:
		_gbda := _bf.ValueNumber
		for _gae := range _fd {
			_fe := _fd[_gae].AsNumber()
			if _fe.Type != ResultTypeNumber {
				return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
			}
			switch _abe {
			case BinOpTypePlus:
				_deca = append(_deca, MakeNumberResult(_fe.ValueNumber+_gbda))
			case BinOpTypeMinus:
				_deca = append(_deca, MakeNumberResult(_fe.ValueNumber-_gbda))
			case BinOpTypeMult:
				_deca = append(_deca, MakeNumberResult(_fe.ValueNumber*_gbda))
			case BinOpTypeDiv:
				if _gbda == 0 {
					return MakeErrorResultType(ErrorTypeDivideByZero, "")
				}
				_deca = append(_deca, MakeNumberResult(_fe.ValueNumber/_gbda))
			case BinOpTypeExp:
				_deca = append(_deca, MakeNumberResult(_gfc.Pow(_fe.ValueNumber, _gbda)))
			case BinOpTypeLT:
				_deca = append(_deca, MakeBoolResult(_fe.ValueNumber < _gbda))
			case BinOpTypeGT:
				_deca = append(_deca, MakeBoolResult(_fe.ValueNumber > _gbda))
			case BinOpTypeEQ:
				_deca = append(_deca, MakeBoolResult(_fe.ValueNumber == _gbda))
			case BinOpTypeLEQ:
				_deca = append(_deca, MakeBoolResult(_fe.ValueNumber <= _gbda))
			case BinOpTypeGEQ:
				_deca = append(_deca, MakeBoolResult(_fe.ValueNumber >= _gbda))
			case BinOpTypeNE:
				_deca = append(_deca, MakeBoolResult(_fe.ValueNumber != _gbda))
			default:
				return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _abe))
			}
		}
	case ResultTypeString:
		_bc := _bf.ValueString
		for _bdc := range _fd {
			_ca := _fd[_bdc].AsString()
			if _ca.Type != ResultTypeString {
				return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
			}
			switch _abe {
			case BinOpTypeLT:
				_deca = append(_deca, MakeBoolResult(_ca.ValueString < _bc))
			case BinOpTypeGT:
				_deca = append(_deca, MakeBoolResult(_ca.ValueString > _bc))
			case BinOpTypeEQ:
				_deca = append(_deca, MakeBoolResult(_ca.ValueString == _bc))
			case BinOpTypeLEQ:
				_deca = append(_deca, MakeBoolResult(_ca.ValueString <= _bc))
			case BinOpTypeGEQ:
				_deca = append(_deca, MakeBoolResult(_ca.ValueString >= _bc))
			case BinOpTypeNE:
				_deca = append(_deca, MakeBoolResult(_ca.ValueString != _bc))
			default:
				return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _abe))
			}
		}
	default:
		return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069c\u0020\u0061\u006e\u0064\u0020\u006e\u006f\u006e-\u0073t\u0072\u0069\u006e\u0067\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069\u006e\u0061r\u0079\u0020\u006f\u0070\u0065\u0072\u0061\u0074\u0069\u006f\u006e")
	}
	return MakeListResult(_deca)
}

// Eval evaluates and returns an expression with prefix.
func (_cedbg PrefixExpr) Eval(ctx Context, ev Evaluator) Result {
	_cdcdd := _cedbg._dcfga.Reference(ctx, ev)
	switch _cdcdd.Type {
	case ReferenceTypeSheet:
		if _fggd(_cdcdd, ctx) {
			return MakeErrorResultType(ErrorTypeName, _c.Sprintf("\u0053h\u0065e\u0074\u0020\u0025\u0073\u0020n\u006f\u0074 \u0066\u006f\u0075\u006e\u0064", _cdcdd.Value))
		}
		_geded := ctx.Sheet(_cdcdd.Value)
		return _cedbg._bcbe.Eval(_geded, ev)
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cdcdd.Type))
	}
}

var _fba = map[string]*_ed.Regexp{}

// Month is an implementation of the Excel MONTH() function.
func Month(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("M\u004f\u004e\u0054\u0048\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006ee\u0020\u0061\u0072g\u0075m\u0065\u006e\u0074")
	}
	_ege := args[0]
	switch _ege.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(1)
	case ResultTypeNumber:
		_gef := _eeec(_ege.ValueNumber)
		return MakeNumberResult(float64(_gef.Month()))
	case ResultTypeString:
		_aba := _gg.ToLower(_ege.ValueString)
		if !_cef(_aba) {
			_, _, _, _, _agb, _dfbb := _cefg(_aba)
			if _dfbb.Type == ResultTypeError {
				_dfbb.ErrorMessage = "\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u004dON\u0054\u0048"
				return _dfbb
			}
			if _agb {
				return MakeNumberResult(1)
			}
		}
		_, _bgg, _, _, _acbd := _agda(_aba)
		if _acbd.Type == ResultTypeError {
			return _acbd
		}
		return MakeNumberResult(float64(_bgg))
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004d\u004fN\u0054\u0048")
	}
}

// Right implements the Excel RIGHT(string,[n]) function which returns the
// rightmost n characters.
func Right(args []Result) Result {
	_dbac := 1
	switch len(args) {
	case 1:
	case 2:
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0049\u0047\u0048\u0054\u0020\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_dbac = int(args[1].ValueNumber)
		if _dbac < 0 {
			return MakeErrorResult("R\u0049\u0047\u0048\u0054\u0020\u0065x\u0070\u0065\u0063\u0074\u0065\u0064 \u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u003e\u003d \u0030")
		}
		if _dbac == 0 {
			return MakeStringResult("")
		}
	default:
		return MakeErrorResult("\u0052\u0049\u0047HT\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeList {
		return MakeErrorResult("\u0052\u0049\u0047\u0048\u0054\u0020\u0063\u0061\u006e\u0027\u0074\u0020\u0062\u0065\u0020c\u0061l\u006c\u0065\u0064\u0020\u006f\u006e\u0020\u0061\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_dggeg := args[0].Value()
	_cebe := len(_dggeg)
	if _dbac > _cebe {
		return MakeStringResult(_dggeg)
	}
	return MakeStringResult(_dggeg[_cebe-_dbac : _cebe])
}

const _dagc = 57362

func _eggbe(_geaa [][]Result) float64 {
	if len(_geaa) == 2 {
		_gcgb := _geaa[0][0].AsNumber()
		_afbbf := _geaa[0][1].AsNumber()
		_dcaf := _geaa[1][0].AsNumber()
		_egce := _geaa[1][1].AsNumber()
		if _gcgb.Type != ResultTypeNumber || _afbbf.Type != ResultTypeNumber || _dcaf.Type != ResultTypeNumber || _egce.Type != ResultTypeNumber {
			return _gfc.NaN()
		}
		return _gcgb.ValueNumber*_egce.ValueNumber - _dcaf.ValueNumber*_afbbf.ValueNumber
	}
	_cfgb := float64(0)
	_eecg := float64(1)
	for _bfcac := range _geaa {
		_cfgb += _eecg * _geaa[0][_bfcac].ValueNumber * _eggbe(_gdbg(_geaa, _bfcac))
		_eecg *= -1
	}
	return _cfgb
}

// Pmt implements the Excel PMT function.
func Pmt(args []Result) Result {
	_fbfb := len(args)
	if _fbfb < 3 || _fbfb > 5 {
		return MakeErrorResult("\u0050\u004dT\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u0020\u0035")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_faegc := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004dT\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_beed := args[1].ValueNumber
	if _beed == 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u00200")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065\u006e\u0074 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_ebd := args[2].ValueNumber
	_gbbg := 0.0
	if _fbfb >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("P\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0075\u0074\u0075\u0072e \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gbbg = args[3].ValueNumber
	}
	_acfd := 0.0
	if _fbfb == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0079\u0070\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_acfd = args[4].ValueNumber
		if _acfd != 0 {
			_acfd = 1
		}
	}
	var _bgde float64
	if _faegc == 0 {
		_bgde = (_ebd + _gbbg) / _beed
	} else {
		_ccfda := _gfc.Pow(1+_faegc, _beed)
		if _acfd == 1 {
			_bgde = (_gbbg*_faegc/(_ccfda-1) + _ebd*_faegc/(1-1/_ccfda)) / (1 + _faegc)
		} else {
			_bgde = _gbbg*_faegc/(_ccfda-1) + _ebd*_faegc/(1-1/_ccfda)
		}
	}
	return MakeNumberResult(-_bgde)
}

// Eval evaluates a vertical range returning a list of results or an error.
func (_acfga VerticalRange) Eval(ctx Context, ev Evaluator) Result {
	_ebbd := _acfga.verticalRangeReference()
	if _ceada, _bfbbe := ev.GetFromCache(_ebbd); _bfbbe {
		return _ceada
	}
	_dccbg, _ffcgfg := _gffe(ctx, _acfga._dcac, _acfga._ddef)
	_bccbg := _efagg(ctx, ev, _dccbg, _ffcgfg)
	ev.SetCache(_ebbd, _bccbg)
	return _bccbg
}

// NewEmptyExpr constructs a new empty expression.
func NewEmptyExpr() Expression          { return EmptyExpr{} }
func LexReader(r _ef.Reader) chan *node { _gceb := NewLexer(); go _gceb.lex(r); return _gceb._fbfbd }
func _egdg(_bdged []Result, _cddf bool) Result {
	var _aeafg string
	if _cddf {
		_aeafg = "\u004c\u0041\u0052G\u0045"
	} else {
		_aeafg = "\u0053\u004d\u0041L\u004c"
	}
	if len(_bdged) != 2 {
		return MakeErrorResult(_aeafg + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_fbga := _bdged[0]
	var _ddbe [][]Result
	switch _fbga.Type {
	case ResultTypeArray:
		_ddbe = _fbga.ValueArray
	case ResultTypeList:
		_ddbe = [][]Result{_fbga.ValueList}
	default:
		return MakeErrorResult(_aeafg + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u006f\u0066\u0020\u0074\u0079p\u0065\u0020a\u0072\u0072\u0061\u0079")
	}
	if len(_ddbe) == 0 {
		return MakeErrorResult(_aeafg + "\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0074\u006f\u0020c\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u0031\u0020\u0072\u006f\u0077")
	}
	if _bdged[1].Type != ResultTypeNumber {
		return MakeErrorResult(_aeafg + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074yp\u0065\u0020\u006eu\u006db\u0065\u0072")
	}
	_begg := _bdged[1].ValueNumber
	if _begg < 1 {
		return MakeErrorResultType(ErrorTypeNum, _aeafg+"\u0020\u0072e\u0071\u0075\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006fn\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
	}
	_bbdb := int(_begg)
	if float64(_bbdb) != _begg {
		return MakeErrorResultType(ErrorTypeNum, _aeafg+"\u0020\u0072e\u0071\u0075\u0069\u0072\u0065s\u0020\u0073\u0065\u0063\u006fn\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u0030")
	}
	_becee := []float64{}
	for _, _gffc := range _ddbe {
		for _, _cbbd := range _gffc {
			if _cbbd.Type == ResultTypeNumber {
				_becee = append(_becee, _cbbd.ValueNumber)
			}
		}
	}
	if _bbdb > len(_becee) {
		return MakeErrorResultType(ErrorTypeNum, _aeafg+" \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u006c\u0065s\u0073\u0020\u006f\u0072\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u0068\u0061\u006e\u0020t\u0068\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072s\u0020\u0069\u006e\u0020t\u0068\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_gbfd := _b.MergeSort(_becee)
	if _cddf {
		return MakeNumberResult(_gbfd[len(_gbfd)-_bbdb])
	} else {
		return MakeNumberResult(_gbfd[_bbdb-1])
	}
}
func init() {
	_fded()
	RegisterFunction("\u004e\u0041", NA)
	RegisterFunction("\u0049S\u0042\u004c\u0041\u004e\u004b", IsBlank)
	RegisterFunction("\u0049\u0053\u0045R\u0052", IsErr)
	RegisterFunction("\u0049S\u0045\u0052\u0052\u004f\u0052", IsError)
	RegisterFunction("\u0049\u0053\u0045\u0056\u0045\u004e", IsEven)
	RegisterFunctionComplex("\u005fx\u006cf\u006e\u002e\u0049\u0053\u0046\u004f\u0052\u004d\u0055\u004c\u0041", IsFormula)
	RegisterFunctionComplex("\u004fR\u0047\u002e\u004f\u0050E\u004e\u004f\u0046\u0046\u0049C\u0045.\u0049S\u004c\u0045\u0041\u0050\u0059\u0045\u0041R", IsLeapYear)
	RegisterFunctionComplex("\u0049S\u004c\u004f\u0047\u0049\u0043\u0041L", IsLogical)
	RegisterFunction("\u0049\u0053\u004e\u0041", IsNA)
	RegisterFunction("\u0049S\u004e\u004f\u004e\u0054\u0045\u0058T", IsNonText)
	RegisterFunction("\u0049\u0053\u004e\u0055\u004d\u0042\u0045\u0052", IsNumber)
	RegisterFunction("\u0049\u0053\u004fD\u0044", IsOdd)
	RegisterFunctionComplex("\u0049\u0053\u0052E\u0046", IsRef)
	RegisterFunction("\u0049\u0053\u0054\u0045\u0058\u0054", IsText)
	RegisterFunctionComplex("\u0043\u0045\u004c\u004c", Cell)
}
func _bdda(_ffbgc Context, _gagb, _fbfff int) (string, string) {
	_bfgbe := "\u0041" + _ff.Itoa(_gagb)
	_efbgd := _ffbgc.LastColumn(_gagb, _fbfff)
	_cggfb := _efbgd + _ff.Itoa(_fbfff)
	return _bfgbe, _cggfb
}

// MakeErrorResult constructs a #VALUE! error with a given extra error message.
// The error message is for debugging formula evaluation only and is not stored
// in the sheet.
func MakeErrorResult(msg string) Result { return MakeErrorResultType(ErrorTypeValue, msg) }
func NewLexer() *Lexer                  { return &Lexer{_fbfbd: make(chan *node)} }

type defEval struct {
	evCache
	_gba bool
}

func Sign(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0053\u0049\u0047\u004e(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_fafg := args[0].AsNumber()
	if _fafg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0049\u0047N(\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020a\u0020n\u0075m\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _fafg.ValueNumber < 0 {
		return MakeNumberResult(-1)
	} else if _fafg.ValueNumber > 0 {
		return MakeNumberResult(1)
	}
	return MakeNumberResult(0)
}
func _acag(_dcecf, _ffbg Result, _dacdc string) (*xargs, Result) {
	if _dcecf.Type != ResultTypeList && _dcecf.Type != ResultTypeArray {
		return nil, MakeErrorResult(_dacdc + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0076\u0061lue\u0073 t\u006f\u0020\u0062\u0065\u0020\u006f\u0066 a\u0072\u0072\u0061\u0079\u0020\u0074\u0079p\u0065")
	}
	_gdbed := _bbcd(_dcecf)
	_gabd := []float64{}
	for _, _deee := range _gdbed {
		for _, _eggf := range _deee {
			if _eggf.Type == ResultTypeNumber && !_eggf.IsBoolean {
				_gabd = append(_gabd, _eggf.ValueNumber)
			} else {
				return nil, MakeErrorResult(_dacdc + "\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0076\u0061\u006c\u0075\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0073")
			}
		}
	}
	_acgg := len(_gabd)
	if len(_gabd) < 2 {
		return nil, MakeErrorResultType(ErrorTypeNum, "")
	}
	if _ffbg.Type != ResultTypeList && _ffbg.Type != ResultTypeArray {
		return nil, MakeErrorResult(_dacdc + " \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0064\u0061\u0074\u0065s\u0020\u0074\u006f\u0020\u0062\u0065\u0020o\u0066\u0020\u0061\u0072\u0072\u0061\u0079\u0020\u0074\u0079p\u0065")
	}
	_dfbbge := _bbcd(_ffbg)
	_feb := []float64{}
	_fege := 0.0
	for _, _fdbg := range _dfbbge {
		for _, _agfda := range _fdbg {
			if _agfda.Type == ResultTypeNumber && !_agfda.IsBoolean {
				_gbbe := float64(int(_agfda.ValueNumber))
				if _gbbe < _fege {
					return nil, MakeErrorResultType(ErrorTypeNum, _dacdc+" \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0061\u0074\u0065\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u0069\u006e\u0020\u0061\u0073\u0063\u0065\u006edi\u006e\u0067\u0020o\u0072d\u0065\u0072")
				}
				_feb = append(_feb, _gbbe)
				_fege = _gbbe
			} else {
				return nil, MakeErrorResult(_dacdc + "\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0064\u0061\u0074\u0065\u0073\u0020t\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0073")
			}
		}
	}
	if len(_feb) != _acgg {
		return nil, MakeErrorResultType(ErrorTypeNum, "")
	}
	return &xargs{_gabd, _feb}, MakeEmptyResult()
}

var _cgfab = [...]string{}

// PrefixVerticalRange is a range expression that when evaluated returns a list of Results from references like Sheet1!AA:IJ (all cells from columns AA to IJ of sheet 'Sheet1').
type PrefixVerticalRange struct {
	_ggdbe        Expression
	_cagbb, _baae string
}

// IfNA is an implementation of the Excel IFNA() function. It takes two arguments.
func IfNA(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("I\u0046\u004e\u0041\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeError && args[0].ValueString == "\u0023\u004e\u002f\u0041" {
		return args[1]
	}
	return args[0]
}

// NewSheetPrefixExpr constructs a new prefix expression.
func NewSheetPrefixExpr(s string) Expression { return &SheetPrefixExpr{_gegeg: s} }
func _dggff(_ebce _d.Time) _d.Time {
	_ebce = _ebce.UTC()
	return _d.Date(_ebce.Year(), _ebce.Month(), _ebce.Day(), _ebce.Hour(), _ebce.Minute(), _ebce.Second(), _ebce.Nanosecond(), _d.Local)
}

type cumulArgs struct {
	_cebf float64
	_ccde float64
	_gbea float64
	_dbec float64
	_defe float64
	_bafc int
}

// Quotient is an implementation of the Excel QUOTIENT function that returns the
// integer portion of division.
func Quotient(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0051\u0055\u004f\u0054\u0049E\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_bdgfc := args[0].AsNumber()
	_dbcd := args[1].AsNumber()
	if _bdgfc.Type != ResultTypeNumber || _dbcd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0051\u0055\u004f\u0054\u0049E\u004e\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _dbcd.ValueNumber == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0051U\u004f\u0054\u0049\u0045N\u0054\u0028\u0029\u0020\u0064i\u0076i\u0064e\u0020\u0062\u0079\u0020\u007a\u0065\u0072o")
	}
	return MakeNumberResult(_gfc.Trunc(_bdgfc.ValueNumber / _dbcd.ValueNumber))
}

// ISNONTEXT is an implementation of the Excel ISNONTEXT() function.
func IsNonText(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053N\u004f\u004e\u0054\u0045X\u0054\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073 \u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type != ResultTypeString)
}

type evCache struct {
	_agf map[string]Result
	_cgb *_f.Mutex
}

// T is an implementation of the Excel T function that returns whether the
// argument is text.
func T(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("T\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074r\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_cfaf := args[0]
	if _cfaf.Type == ResultTypeError || _cfaf.Type == ResultTypeString {
		return _cfaf
	}
	return _gaef
}
func _aggc(_facd []Result, _efce countMode) float64 {
	_adda := 0.0
	for _, _ebacc := range _facd {
		switch _ebacc.Type {
		case ResultTypeNumber:
			if _efce == _dfgf || (_efce == _eegf && !_ebacc.IsBoolean) {
				_adda++
			}
		case ResultTypeList, ResultTypeArray:
			_adda += _aggc(_ebacc.ListValues(), _efce)
		case ResultTypeString:
			if _efce == _dfgf {
				_adda++
			}
		case ResultTypeEmpty:
			if _efce == _cebbf {
				_adda++
			}
		}
	}
	return _adda
}

// If is an implementation of the Excel IF() function. It takes one, two or
// three arguments.
func If(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0049\u0046\u0020re\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006ce\u0061s\u0074 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0049\u0046\u0020ac\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0074\u0020m\u006fs\u0074 \u0074h\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dacca := args[0]
	switch _dacca.Type {
	case ResultTypeError:
		return _dacca
	case ResultTypeNumber:
		if len(args) == 1 {
			return MakeBoolResult(_dacca.ValueNumber != 0)
		}
		if _dacca.ValueNumber != 0 {
			return args[1]
		}
		if len(args) == 3 {
			return args[2]
		} else {
			return MakeBoolResult(false)
		}
	case ResultTypeList:
		return _beafa(args)
	case ResultTypeArray:
		return _dggc(args)
	default:
		return MakeErrorResult("\u0049F\u0020\u0069n\u0069\u0074\u0069\u0061l\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u006d\u0075\u0073t \u0062\u0065\u0020n\u0075\u006de\u0072\u0069\u0063\u0020\u006f\u0072 \u0061\u0072r\u0061\u0079")
	}
}
func _cfba(_bacf, _cfc, _fdcg, _ecfec, _edde, _gceeg float64, _afc int) (float64, Result) {
	_ffdg := int(_gceeg)
	_gffgc := _eagc(_bacf, _cfc, _ffdg, _afc)
	_eabg := _dadd(_bacf, _cfc, _ffdg, _afc) / _gffgc
	_dfffa, _debc := _dbbg(_bacf, _cfc, _ffdg, _afc)
	if _debc.Type == ResultTypeError {
		return 0, _debc
	}
	_acab := _fecb(_bacf, _cfc, _ffdg, _afc)
	_edecg := _edde / _gfc.Pow(1+_ecfec/_gceeg, _dfffa-1+_eabg)
	_edecg -= 100 * _fdcg / _gceeg * _acab / _gffgc
	_egfce := 100 * _fdcg / _gceeg
	_dcfc := 1 + _ecfec/_gceeg
	for _bfec := 0.0; _bfec < _dfffa; _bfec++ {
		_edecg += _egfce / _gfc.Pow(_dcfc, _bfec+_eabg)
	}
	return _edecg, MakeEmptyResult()
}

// Days is an implementation of the Excel DAYS() function.
func Days(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("D\u0041\u0059\u0053\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	var _cacg, _edb float64
	switch args[0].Type {
	case ResultTypeNumber:
		_edb = args[0].ValueNumber
	case ResultTypeString:
		_gbaa := DateValue([]Result{args[0]})
		if _gbaa.Type == ResultTypeError {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0065\u006e\u0064\u0020\u0064\u0061\u0074e\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
		}
		_edb = _gbaa.ValueNumber
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
	}
	switch args[1].Type {
	case ResultTypeNumber:
		_cacg = args[1].ValueNumber
		if _cacg < 62 && _edb >= 62 {
			_cacg--
		}
	case ResultTypeString:
		_aaf := DateValue([]Result{args[1]})
		if _aaf.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u0020DA\u0059\u0053")
		}
		_cacg = _aaf.ValueNumber
	default:
		return MakeErrorResult("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0066\u006fr\u0020D\u0041\u0059\u0053")
	}
	_cec := float64(int(_edb - _cacg))
	return MakeNumberResult(_cec)
}

// Reference returns an invalid reference for FunctionCall.
func (_gdffd FunctionCall) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }
func init() {
	RegisterFunction("\u0041\u004e\u0044", And)
	RegisterFunction("\u0046\u0041\u004cS\u0045", False)
	RegisterFunction("\u0049\u0046", If)
	RegisterFunction("\u0049F\u0045\u0052\u0052\u004f\u0052", IfError)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0049\u0046\u004e\u0041", IfNA)
	RegisterFunction("\u0049\u0046\u0053", Ifs)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0049\u0046S", Ifs)
	RegisterFunction("\u004e\u004f\u0054", Not)
	RegisterFunction("\u004f\u0052", Or)
	RegisterFunction("\u0054\u0052\u0055\u0045", True)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0058\u004fR", Xor)
}

var _ec = []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

// CountBlank implements the COUNTBLANK function.
func CountBlank(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043\u004f\u0055N\u0054\u0042\u004c\u0041N\u004b\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u006e\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(_aggc(args, _cebbf))
}

// Tbillyield implements the Excel TBILLYIELD function.
func Tbillyield(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0059\u0049E\u004c\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_gcce, _dabba, _acabd := _geae(args[0], args[1], "\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044")
	if _acabd.Type == ResultTypeError {
		return _acabd
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0064\u0069\u0073\u0063\u006f\u0075n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ccca := _dabba - _gcce
	if _ccca > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004cY\u0049\u0045\u004c\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020t\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079e\u0061\u0072\u0020\u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_gabbd := args[2].ValueNumber
	if _gabbd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0059\u0049\u0045\u004c\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020p\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bcffe := (100 - _gabbd) / _gabbd
	_daddc := 360 / _ccca
	return MakeNumberResult(_bcffe * _daddc)
}

// AsNumber attempts to intepret a string cell value as a number. Upon success,
// it returns a new number result, upon  failure it returns the original result.
// This is used as functions return strings that can then act like number (e.g.
// LEFT(1.2345,3) + LEFT(1.2345,3) = 2.4)
func (_fgba Result) AsNumber() Result {
	if _fgba.Type == ResultTypeString {
		_aaggd, _gdcdc := _ff.ParseFloat(_fgba.ValueString, 64)
		if _gdcdc == nil {
			return MakeNumberResult(_aaggd)
		}
	}
	if _fgba.Type == ResultTypeEmpty {
		return MakeNumberResult(0)
	}
	return _fgba
}
func _gbge(_decaf, _beab []float64, _aafe float64) float64 {
	_cfbba := _aafe + 1
	_fegb := 0.0
	_gcbc := len(_decaf)
	_gegaa := _beab[0]
	for _bbaa := 1; _bbaa < _gcbc; _bbaa++ {
		_bfdd := (_beab[_bbaa] - _gegaa) / 365
		_fegb -= _bfdd * _decaf[_bbaa] / _gfc.Pow(_cfbba, _bfdd+1)
	}
	return _fegb
}

// Eval evaluates a horizontal range returning a list of results or an error.
func (_ceac HorizontalRange) Eval(ctx Context, ev Evaluator) Result {
	_fcba := _ceac.horizontalRangeReference()
	if _geebc, _dcbfe := ev.GetFromCache(_fcba); _dcbfe {
		return _geebc
	}
	_eacbf, _gaae := _bdda(ctx, _ceac._ggef, _ceac._edddf)
	_aedg := _efagg(ctx, ev, _eacbf, _gaae)
	ev.SetCache(_fcba, _aedg)
	return _aedg
}

// True is an implementation of the Excel TRUE() function.  It takes no
// arguments.
func True(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0054\u0052\u0055E \u0074\u0061\u006b\u0065\u0073\u0020\u006e\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(true)
}

// BinaryExpr is a binary expression.
type BinaryExpr struct {
	_bg, _fb Expression
	_dee     BinOpType
}

// Reference returns an invalid reference for EmptyExpr.
func (_eee EmptyExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Yielddisc implements the Excel YIELDDISC function.
func Yielddisc(args []Result) Result {
	_cggc := len(args)
	if _cggc != 4 && _cggc != 5 {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_edea, _gedc, _agdefg := _geae(args[0], args[1], "\u0059I\u0045\u004c\u0044\u0044\u0049\u0053C")
	if _agdefg.Type == ResultTypeError {
		return _agdefg
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0044\u0049S\u0043\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_ffdda := args[2].ValueNumber
	if _ffdda <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0049E\u004c\u0044\u0044\u0049\u0053C\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0070\u0072\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_bdcf := args[3].ValueNumber
	if _bdcf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "YI\u0045\u004cD\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076e\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072g\u0075m\u0065\u006et")
	}
	_eebb := 0
	if _cggc == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0059\u0049E\u004c\u0044\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_eebb = int(args[4].ValueNumber)
		if !_dfeg(_eebb) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0059I\u0045\u004cD\u0044\u0049\u0053\u0043")
		}
	}
	_bfcf, _agdefg := _fbabb(_edea, _gedc, _eebb)
	if _agdefg.Type == ResultTypeError {
		return _agdefg
	}
	return MakeNumberResult((_bdcf/_ffdda - 1) / _bfcf)
}

// Average implements the AVERAGE function. It differs slightly from Excel (and
// agrees with LibreOffice) in that boolean values are counted. As an example,
// AVERAGE of two cells containing TRUE & FALSE is 0.5 in LibreOffice and
// #DIV/0! in Excel. unioffice will return 0.5 in this case.
func Average(args []Result) Result {
	_aded, _agag := _bdfc(args, false)
	if _agag == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0041\u0056\u0045\u0052AG\u0045\u0020\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065r\u006f")
	}
	return MakeNumberResult(_aded / _agag)
}

// Ceiling is an implementation of the CEILING function which
// returns the ceiling of a number.
func Ceiling(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("C\u0045\u0049\u004c\u0049\u004e\u0047\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020a\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006ee \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u0028\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_ecbd := args[0].AsNumber()
	if _ecbd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066i\u0072\u0073t\u0020\u0061\u0072\u0067u\u006d\u0065\u006et\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049NG\u0028\u0029\u0020m\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006db\u0065\u0072")
	}
	_cged := float64(1)
	if _ecbd.ValueNumber < 0 {
		_cged = -1
	}
	if len(args) > 1 {
		_fcca := args[1].AsNumber()
		if _fcca.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073e\u0063\u006fn\u0064\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020t\u006f\u0020\u0043\u0045\u0049\u004cI\u004e\u0047\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062e\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_cged = _fcca.ValueNumber
	}
	if _cged < 0 && _ecbd.ValueNumber > 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u006e\u0065\u0067\u0061\u0074\u0069v\u0065\u0020\u0073\u0069\u0067\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004cI\u004e\u0047\u0028\u0029\u0020\u0069\u006ev\u0061\u006c\u0069\u0064")
	}
	if len(args) == 1 {
		return MakeNumberResult(_gfc.Ceil(_ecbd.ValueNumber))
	}
	_fbbca := _ecbd.ValueNumber
	_fbbca, _gdcg := _gfc.Modf(_fbbca / _cged)
	if _gdcg > 0 {
		_fbbca++
	}
	return MakeNumberResult(_fbbca * _cged)
}

// ISBLANK is an implementation of the Excel ISBLANK() function.
func IsBlank(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("I\u0053\u0042\u004c\u0041\u004e\u004b(\u0029\u0020\u0061\u0063\u0063\u0065p\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeEmpty)
}

// NA is an implementation of the Excel NA() function that just returns the #N/A! error.
func NA(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u004eA\u0028\u0029\u0020\u0061c\u0063\u0065\u0070\u0074\u0073 \u006eo\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s")
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

const _egegg = 2

// SetLocked does nothing for the invalid reference context.
func (_ggbaab *ivr) SetLocked(cellRef string, locked bool) {}
func init() {
	_fbbf = _gf.New(_gf.NewSource(_d.Now().UnixNano()))
	RegisterFunction("\u0041\u0042\u0053", _ffgcd("\u0041\u0053\u0049\u004e", _gfc.Abs))
	RegisterFunction("\u0041\u0043\u004f\u0053", _ffgcd("\u0041\u0053\u0049\u004e", _gfc.Acos))
	RegisterFunction("\u0041\u0043\u004fS\u0048", _ffgcd("\u0041\u0053\u0049\u004e", _gfc.Acosh))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0041\u0043\u004f\u0054", _ffgcd("\u0041\u0043\u004f\u0054", func(_fdcge float64) float64 { return _gfc.Pi/2 - _gfc.Atan(_fdcge) }))
	RegisterFunction("_\u0078\u006c\u0066\u006e\u002e\u0041\u0043\u004f\u0054\u0048", _ffgcd("\u0041\u0043\u004fT\u0048", func(_gdddg float64) float64 { return _gfc.Atanh(1 / _gdddg) }))
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u0041\u0052\u0041\u0042\u0049\u0043", Arabic)
	RegisterFunction("\u0041\u0053\u0049\u004e", _ffgcd("\u0041\u0053\u0049\u004e", _gfc.Asin))
	RegisterFunction("\u0041\u0053\u0049N\u0048", _ffgcd("\u0041\u0053\u0049N\u0048", _gfc.Asinh))
	RegisterFunction("\u0041\u0054\u0041\u004e", _ffgcd("\u0041\u0054\u0041\u004e", _gfc.Atan))
	RegisterFunction("\u0041\u0054\u0041N\u0048", _ffgcd("\u0041\u0054\u0041N\u0048", _gfc.Atanh))
	RegisterFunction("\u0041\u0054\u0041N\u0032", Atan2)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0042\u0041\u0053\u0045", Base)
	RegisterFunction("\u0043E\u0049\u004c\u0049\u004e\u0047", Ceiling)
	RegisterFunction("\u005fx\u006cf\u006e\u002e\u0043\u0045\u0049L\u0049\u004eG\u002e\u004d\u0041\u0054\u0048", CeilingMath)
	RegisterFunction("_\u0078\u006c\u0066\u006e.C\u0045I\u004c\u0049\u004e\u0047\u002eP\u0052\u0045\u0043\u0049\u0053\u0045", CeilingPrecise)
	RegisterFunction("\u0043\u004f\u004d\u0042\u0049\u004e", Combin)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u004f\u004d\u0042\u0049\u004e\u0041", Combina)
	RegisterFunction("\u0043\u004f\u0053", _ffgcd("\u0043\u004f\u0053", _gfc.Cos))
	RegisterFunction("\u0043\u004f\u0053\u0048", _ffgcd("\u0043\u004f\u0053\u0048", _gfc.Cosh))
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0043\u004fT", _efbg("\u0043\u004f\u0054", _gfc.Tan))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u004f\u0054\u0048", _efbg("\u0043\u004f\u0054\u0048", _gfc.Tanh))
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0043\u0053C", _efbg("\u0043\u0053\u0043", _gfc.Sin))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0043\u0053\u0043\u0048", _efbg("\u0043\u0053\u0043", _gfc.Sinh))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0044\u0045\u0043\u0049\u004d\u0041\u004c", Decimal)
	RegisterFunction("\u0044E\u0047\u0052\u0045\u0045\u0053", Degrees)
	RegisterFunction("\u0045\u0056\u0045\u004e", Even)
	RegisterFunction("\u0045\u0058\u0050", _ffgcd("\u0045\u0058\u0050", _gfc.Exp))
	RegisterFunction("\u0046\u0041\u0043\u0054", Fact)
	RegisterFunction("\u0046\u0041\u0043\u0054\u0044\u004f\u0055\u0042\u004c\u0045", FactDouble)
	RegisterFunction("\u0046\u004c\u004fO\u0052", Floor)
	RegisterFunction("\u005f\u0078l\u0066\u006e\u002eF\u004c\u004f\u004f\u0052\u002e\u004d\u0041\u0054\u0048", FloorMath)
	RegisterFunction("\u005f\u0078\u006c\u0066n.\u0046\u004c\u004f\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045", FloorPrecise)
	RegisterFunction("\u0047\u0043\u0044", GCD)
	RegisterFunction("\u0049\u004e\u0054", Int)
	RegisterFunction("I\u0053\u004f\u002e\u0043\u0045\u0049\u004c\u0049\u004e\u0047", CeilingPrecise)
	RegisterFunction("\u004c\u0043\u004d", LCM)
	RegisterFunction("\u004c\u004e", _ffgcd("\u004c\u004e", _gfc.Log))
	RegisterFunction("\u004c\u004f\u0047", Log)
	RegisterFunction("\u004c\u004f\u00471\u0030", _ffgcd("\u004c\u004f\u00471\u0030", _gfc.Log10))
	RegisterFunction("\u004dD\u0045\u0054\u0045\u0052\u004d", MDeterm)
	RegisterFunction("\u004d\u004f\u0044", Mod)
	RegisterFunction("\u004d\u0052\u004f\u0055\u004e\u0044", Mround)
	RegisterFunction("M\u0055\u004c\u0054\u0049\u004e\u004f\u004d\u0049\u0041\u004c", Multinomial)
	RegisterFunction("_\u0078\u006c\u0066\u006e\u002e\u004d\u0055\u004e\u0049\u0054", Munit)
	RegisterFunction("\u004f\u0044\u0044", Odd)
	RegisterFunction("\u0050\u0049", Pi)
	RegisterFunction("\u0050\u004f\u0057E\u0052", Power)
	RegisterFunction("\u0050R\u004f\u0044\u0055\u0043\u0054", Product)
	RegisterFunction("\u0051\u0055\u004f\u0054\u0049\u0045\u004e\u0054", Quotient)
	RegisterFunction("\u0052A\u0044\u0049\u0041\u004e\u0053", Radians)
	RegisterFunction("\u0052\u0041\u004e\u0044", Rand)
	RegisterFunction("R\u0041\u004e\u0044\u0042\u0045\u0054\u0057\u0045\u0045\u004e", RandBetween)
	RegisterFunction("\u0052\u004f\u004dA\u004e", Roman)
	RegisterFunction("\u0052\u004f\u0055N\u0044", Round)
	RegisterFunction("\u0052O\u0055\u004e\u0044\u0044\u004f\u0057N", RoundDown)
	RegisterFunction("\u0052O\u0055\u004e\u0044\u0055\u0050", RoundUp)
	RegisterFunction("\u005fx\u006c\u0066\u006e\u002e\u0053\u0045C", _efbg("\u0053\u0045\u0043", _gfc.Cos))
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0053\u0045\u0043\u0048", _efbg("\u0053\u0045\u0043\u0048", _gfc.Cosh))
	RegisterFunction("\u0053E\u0052\u0049\u0045\u0053\u0053\u0055M", SeriesSum)
	RegisterFunction("\u0053\u0049\u0047\u004e", Sign)
	RegisterFunction("\u0053\u0049\u004e", _ffgcd("\u0053\u0049\u004e", _gfc.Sin))
	RegisterFunction("\u0053\u0049\u004e\u0048", _ffgcd("\u0053\u0049\u004e\u0048", _gfc.Sinh))
	RegisterFunction("\u0053\u0051\u0052\u0054", _ffgcd("\u0053\u0051\u0052\u0054", _gfc.Sqrt))
	RegisterFunction("\u0053\u0051\u0052\u0054\u0050\u0049", _ffgcd("\u0053\u0051\u0052\u0054\u0050\u0049", func(_aabe float64) float64 { return _gfc.Sqrt(_aabe * _gfc.Pi) }))
	RegisterFunction("\u0053\u0055\u004d", Sum)
	RegisterFunction("\u0053\u0055\u004dI\u0046", SumIf)
	RegisterFunction("\u0053\u0055\u004d\u0049\u0046\u0053", SumIfs)
	RegisterFunction("\u0053\u0055\u004d\u0050\u0052\u004f\u0044\u0055\u0043\u0054", SumProduct)
	RegisterFunction("\u0053\u0055\u004dS\u0051", SumSquares)
	RegisterFunction("\u0054\u0041\u004e", _ffgcd("\u0054\u0041\u004e", _gfc.Tan))
	RegisterFunction("\u0054\u0041\u004e\u0048", _ffgcd("\u0054\u0041\u004e\u0048", _gfc.Tanh))
	RegisterFunction("\u0054\u0052\u0055N\u0043", Trunc)
}
func _cbaad(_efdf Result) []Result {
	_cfefa := _efdf.ValueList
	if _efdf.Type == ResultTypeArray {
		_cfefa = nil
		for _, _gece := range _efdf.ValueArray {
			if len(_gece) > 0 {
				_cfefa = append(_cfefa, _gece[0])
			} else {
				_cfefa = append(_cfefa, _gaef)
			}
		}
	}
	return _cfefa
}

const _adbge = 57349
const _ecaag = -1000

// Fv implements the Excel FV function.
func Fv(args []Result) Result {
	_ecde := len(args)
	if _ecde < 3 || _ecde > 5 {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u00205")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gddc := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_bgfec := args[1].ValueNumber
	if _bgfec != float64(int(_bgfec)) {
		return MakeErrorResultType(ErrorTypeNum, "\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0061\u0079\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgbg := args[2].ValueNumber
	_bbbg := 0.0
	if _ecde >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("F\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0070\u0072\u0065\u0073\u0065\u006et \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_bbbg = args[3].ValueNumber
	}
	_fgfa := 0
	if _ecde == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0046\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_fgfa = int(args[4].ValueNumber)
		if _fgfa != 0 {
			_fgfa = 1
		}
	}
	return MakeNumberResult(_cdac(_gddc, _bgfec, _dgbg, _bbbg, _fgfa))
}

// Concat is an implementation of the Excel CONCAT() and deprecated CONCATENATE() function.
func Concat(args []Result) Result {
	_cegg := _gb.Buffer{}
	for _, _fgcd := range args {
		switch _fgcd.Type {
		case ResultTypeString:
			_cegg.WriteString(_fgcd.ValueString)
		case ResultTypeNumber:
			var _agff string
			if _fgcd.IsBoolean {
				if _fgcd.ValueNumber == 0 {
					_agff = "\u0046\u0041\u004cS\u0045"
				} else {
					_agff = "\u0054\u0052\u0055\u0045"
				}
			} else {
				_agff = _fgcd.AsString().ValueString
			}
			_cegg.WriteString(_agff)
		default:
			return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041T\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0073")
		}
	}
	return MakeStringResult(_cegg.String())
}

var _eedd, _dedac, _aafg, _cdce, _ggee, _eccc, _afbf, _eaga, _ddfad, _edcb, _agdbg, _egff, _ddce, _bcfb, _bbdf *_ed.Regexp

const _dfb = "\u0028\u0028\u006a\u0061\u006e|\u006a\u0061\u006e\u0075\u0061\u0072\u0079\u0029\u007c\u0028\u0066\u0065\u0062\u007c\u0066\u0065\u0062\u0072\u0075a\u0072\u0079\u0029\u007c\u0028\u006da\u0072\u007c\u006da\u0072\u0063\u0068\u0029\u007c\u0028\u0061\u0070\u0072\u007c\u0061\u0070\u0072\u0069\u006c\u0029\u007c\u0028\u006d\u0061\u0079\u0029\u007c\u0028j\u0075\u006e\u007cj\u0075\u006e\u0065\u0029\u007c\u0028\u006a\u0075\u006c\u007c\u006a\u0075\u006c\u0079\u0029\u007c\u0028a\u0075\u0067\u007c\u0061\u0075\u0067\u0075\u0073t\u0029\u007c\u0028\u0073\u0065\u0070\u007c\u0073\u0065\u0070\u0074\u0065\u006d\u0062\u0065\u0072\u0029\u007c\u0028o\u0063\u0074\u007c\u006f\u0063\u0074\u006f\u0062\u0065\u0072\u0029\u007c\u0028\u006e\u006f\u0076\u007c\u006e\u006f\u0076\u0065\u006d\u0062e\u0072\u0029\u007c\u0028\u0064\u0065\u0063\u007c\u0064\u0065\u0063\u0065\u006d\u0062\u0065\u0072\u0029\u0029"

// Update updates references in the PrefixRangeExpr after removing a row/column.
func (_ebacg PrefixRangeExpr) Update(q *_de.UpdateQuery) Expression {
	_gaeaa := _ebacg
	_gaebfe := _ebacg._gfdcf.String()
	if _gaebfe == q.SheetToUpdate {
		_geba := *q
		_geba.UpdateCurrentSheet = true
		_gaeaa._cbcgb = _ebacg._cbcgb.Update(&_geba)
		_gaeaa._fece = _ebacg._fece.Update(&_geba)
	}
	return _gaeaa
}

var _fadc = [...]int{0, 0, 71, 70, 69, 4, 67, 66, 53, 51, 50, 49, 48, 47, 46, 45, 44, 2}

// Reference returns a string reference value to a sheet.
func (_gbbef SheetPrefixExpr) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeSheet, Value: _gbbef._gegeg}
}

// Reference returns a string reference value to a vertical range.
func (_baggd VerticalRange) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeVerticalRange, Value: _baggd.verticalRangeReference()}
}

type Expression interface {
	Eval(_fda Context, _aff Evaluator) Result
	Reference(_fabd Context, _ge Evaluator) Reference
	String() string
	Update(_ccc *_de.UpdateQuery) Expression
}

// Update returns the same object as updating sheet references does not affect ConstArrayExpr.
func (_dda ConstArrayExpr) Update(q *_de.UpdateQuery) Expression { return _dda }

// Bool is a boolean expression.
type Bool struct{ _fgg bool }

// String returns a string representation of SheetPrefixExpr.
func (_gcbb SheetPrefixExpr) String() string { return _gcbb._gegeg }
func _fagb(_gdff Result, _fgfcb, _bacfg string) (float64, Result) {
	switch _gdff.Type {
	case ResultTypeEmpty:
		return 0, _gaef
	case ResultTypeNumber:
		return _gdff.ValueNumber, _gaef
	case ResultTypeString:
		_fcaf, _gcgff := _ff.ParseFloat(_gdff.ValueString, 64)
		if _gcgff != nil {
			return 0, MakeErrorResult(_bacfg + "\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0066\u006f\u0072\u0020" + _fgfcb)
		}
		return _fcaf, _gaef
	default:
		return 0, MakeErrorResult(_fgfcb + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _bacfg + "\u0020t\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0072\u0020\u0065\u006d\u0070\u0074\u0079")
	}
}

// Munit is an implementation of the Excel MUNIT function that returns an
// identity matrix.
func Munit(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0055\u004eIT\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073 \u006fn\u0065 \u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069\u006e\u0070\u0075\u0074")
	}
	_adgge := args[0].AsNumber()
	if _adgge.Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0055\u004eIT\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073 \u006fn\u0065 \u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069\u006e\u0070\u0075\u0074")
	}
	_ddbg := int(_adgge.ValueNumber)
	_ddccg := make([][]Result, 0, _ddbg)
	for _gabg := 0; _gabg < _ddbg; _gabg++ {
		_aaaaa := make([]Result, _ddbg)
		for _bgcf := 0; _bgcf < _ddbg; _bgcf++ {
			if _gabg == _bgcf {
				_aaaaa[_bgcf] = MakeNumberResult(1.0)
			} else {
				_aaaaa[_bgcf] = MakeNumberResult(0.0)
			}
		}
		_ddccg = append(_ddccg, _aaaaa)
	}
	return MakeArrayResult(_ddccg)
}

// Multinomial implements the excel MULTINOMIAL function.
func Multinomial(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u004d\u0055\u004c\u0054\u0049\u004eO\u004d\u0049\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006ce\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c\u0020i\u006e\u0070\u0075\u0074")
	}
	_cgce, _ccfa, _ceff := _bbec(args)
	if _ceff.Type == ResultTypeError {
		return _ceff
	}
	return MakeNumberResult(_bagd(_cgce) / _ccfa)
}

// Roman is an implementation of the Excel ROMAN function that convers numbers
// to roman numerals in one of 5 formats.
func Roman(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_bcafa := args[0].AsNumber()
	if _bcafa.Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fffa := 0
	if len(args) > 1 {
		_dcaa := args[1]
		if _dcaa.Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u004fM\u0041\u004e\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063")
		}
		_fffa = int(_dcaa.ValueNumber)
		if _fffa < 0 {
			_fffa = 0
		} else if _fffa > 4 {
			_fffa = 4
		}
	}
	_gcadc := _bdbcb
	switch _fffa {
	case 1:
		_gcadc = _gebe
	case 2:
		_gcadc = _dffea
	case 3:
		_gcadc = _ggbag
	case 4:
		_gcadc = _bgac
	}
	_gbbdg := _gfc.Trunc(_bcafa.ValueNumber)
	_dgab := _gb.Buffer{}
	for _, _dbcfe := range _gcadc {
		for _gbbdg >= _dbcfe._fdeaa {
			_dgab.WriteString(_dbcfe._cdfc)
			_gbbdg -= _dbcfe._fdeaa
		}
	}
	return MakeStringResult(_dgab.String())
}

var _dffd = [...]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

// Evaluator is the interface for a formula evaluator.  This is needed so we can
// pass it to the spreadsheet to let it evaluate formula cells before returning
// the results.
// NOTE: in order to implement Evaluator without cache embed noCache in it.
type Evaluator interface {
	Eval(_ceg Context, formula string) Result
	SetCache(_bbef string, _gac Result)
	GetFromCache(_dfc string) (Result, bool)
	LastEvalIsRef() bool
}

func _gdbg(_fcfcg [][]Result, _dedcb int) [][]Result {
	_geeb := [][]Result{}
	for _faeda := range _fcfcg {
		if _faeda == 0 {
			continue
		}
		_baef := []Result{}
		for _ffgb := range _fcfcg {
			if _ffgb == _dedcb {
				continue
			}
			_baef = append(_baef, _fcfcg[_faeda][_ffgb])
		}
		_geeb = append(_geeb, _baef)
	}
	return _geeb
}

// Eval evaluates and returns the result of a function call.
func (_cccae FunctionCall) Eval(ctx Context, ev Evaluator) Result {
	_bggbf := LookupFunction(_cccae._bbfgf)
	if _bggbf != nil {
		_dagf := make([]Result, len(_cccae._ebbe))
		for _gddea, _egaaf := range _cccae._ebbe {
			_dagf[_gddea] = _egaaf.Eval(ctx, ev)
			_dagf[_gddea].Ref = _egaaf.Reference(ctx, ev)
		}
		if _, _abdc := _cddcg[_cccae._bbfgf]; !_abdc {
			if _effbe, _affeb := _fgge(_dagf); _effbe {
				return _affeb
			}
		}
		return _bggbf(_dagf)
	}
	_gdbc := LookupFunctionComplex(_cccae._bbfgf)
	if _gdbc != nil {
		_gcge := make([]Result, len(_cccae._ebbe))
		for _egcb, _adadce := range _cccae._ebbe {
			_gcge[_egcb] = _adadce.Eval(ctx, ev)
			_gcge[_egcb].Ref = _adadce.Reference(ctx, ev)
		}
		if _, _aabef := _cddcg[_cccae._bbfgf]; !_aabef {
			if _fdfc, _cbbc := _fgge(_gcge); _fdfc {
				return _cbbc
			}
		}
		return _gdbc(ctx, ev, _gcge)
	}
	return MakeErrorResult("\u0075\u006e\u006b\u006e\u006f\u0077\u006e\u0020\u0066\u0075\u006e\u0063t\u0069\u006f\u006e\u0020" + _cccae._bbfgf)
}
func _bdfdf(_dcfea yyLexer, _cfecb *yySymType) (_cgfed, _aabed int) {
	_aabed = 0
	_cgfed = _dcfea.Lex(_cfecb)
	if _cgfed <= 0 {
		_aabed = _aacca[0]
		goto _bgca
	}
	if _cgfed < len(_aacca) {
		_aabed = _aacca[_cgfed]
		goto _bgca
	}
	if _cgfed >= _aedac {
		if _cgfed < _aedac+len(_dffd) {
			_aabed = _dffd[_cgfed-_aedac]
			goto _bgca
		}
	}
	for _bgcfc := 0; _bgcfc < len(_cgfe); _bgcfc += 2 {
		_aabed = _cgfe[_bgcfc+0]
		if _aabed == _cgfed {
			_aabed = _cgfe[_bgcfc+1]
			goto _bgca
		}
	}
_bgca:
	if _aabed == 0 {
		_aabed = _dffd[1]
	}
	if _bdddec >= 3 {
		_c.Printf("l\u0065\u0078\u0020\u0025\u0073\u0028\u0025\u0064\u0029\u000a", _addea(_aabed), uint(_cgfed))
	}
	return _cgfed, _aabed
}

type parsedSearchObject struct {
	_ebda string
	_effb string
	_cbec int
}

const _egegf = 57350

// ISFORMULA is an implementation of the Excel ISFORMULA() function.
func IsFormula(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053F\u004f\u0052\u004d\u0055L\u0041\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073 \u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ceea := args[0].Ref
	if _ceea.Type != ReferenceTypeCell {
		return MakeErrorResult("I\u0053\u0046\u004f\u0052\u004d\u0055\u004c\u0041\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072\u0067\u0075\u006de\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	return MakeBoolResult(ctx.HasFormula(_ceea.Value))
}

const _ccbbb = 187

// Received implements the Excel RECEIVED function.
func Received(args []Result) Result {
	_fefa := len(args)
	if _fefa != 4 && _fefa != 5 {
		return MakeErrorResult("R\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066o\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065 a\u0072\u0067\u0075m\u0065n\u0074\u0073")
	}
	_efed, _gfdcbe, _gedf := _geae(args[0], args[1], "\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044")
	if _gedf.Type == ResultTypeError {
		return _gedf
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020i\u006e\u0076\u0065\u0073\u0074\u006d\u0065n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bccd := args[2].ValueNumber
	if _bccd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0069\u006ev\u0065\u0073\u0074\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0045\u0043\u0045\u0049\u0056\u0045\u0044 \u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u0064\u0069s\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_cfbeb := args[3].ValueNumber
	if _cfbeb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0045\u0043\u0045I\u0056\u0045\u0044\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020p\u006f\u0073\u0069\u0074\u0069v\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgcgc := 0
	if _fefa == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052E\u0043\u0045I\u0056\u0045\u0044 \u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0062\u0061\u0073\u0069\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_dgcgc = int(args[4].ValueNumber)
		if !_dfeg(_dgcgc) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006ec\u006f\u0072\u0072\u0065c\u0074\u0020b\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0052\u0045\u0043E\u0049\u0056\u0045\u0044")
		}
	}
	_dcca, _gedf := _fbabb(_efed, _gfdcbe, _dgcgc)
	if _gedf.Type == ResultTypeError {
		return _gedf
	}
	return MakeNumberResult(_bccd / (1 - _cfbeb*_dcca))
}

// Exact is an implementation of the Excel EXACT() which compares two strings.
func Exact(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041\u0054\u0045N\u0041\u0054\u0045(\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_cbad := args[0].AsString()
	_gebc := args[1].AsString()
	if _cbad.Type != ResultTypeString || _gebc.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u004f\u004e\u0043\u0041\u0054\u0045N\u0041\u0054\u0045(\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	return MakeBoolResult(_cbad.ValueString == _gebc.ValueString)
}

// String returns a string of a range.
func (_afdg Range) String() string {
	return _c.Sprintf("\u0025\u0073\u003a%\u0073", _afdg._efbed.String(), _afdg._abfd.String())
}

type durationArgs struct {
	_acdb float64
	_fbef float64
	_dgdc float64
	_ggdd float64
	_gbgg float64
	_bdf  int
}

// Reference returns a string reference value to a vertical range with prefix.
func (_gbebc PrefixVerticalRange) Reference(ctx Context, ev Evaluator) Reference {
	_ccef := _gbebc._ggdbe.Reference(ctx, ev)
	return Reference{Type: ReferenceTypeVerticalRange, Value: _gbebc.verticalRangeReference(_ccef.Value)}
}
func _gaf(_aadc int) int {
	if _aadc < 1900 {
		if _aadc < 30 {
			_aadc += 2000
		} else {
			_aadc += 1900
		}
	}
	return _aadc
}

// NewPrefixRangeExpr constructs a new range with prefix.
func NewPrefixRangeExpr(pfx, from, to Expression) Expression {
	_gccf, _abad, _gdeg := _ccac(from, to)
	if _gdeg != nil {
		_ga.Log.Debug(_gdeg.Error())
		return NewError(_gdeg.Error())
	}
	return PrefixRangeExpr{_gfdcf: pfx, _cbcgb: _gccf, _fece: _abad}
}

// FloorPrecise is an implementation of the FlOOR.PRECISE function.
func FloorPrecise(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0046\u004cO\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 2 {
		return MakeErrorResult("\u0046L\u004f\u004fR\u002e\u0050\u0052\u0045C\u0049\u0053\u0045(\u0029\u0020\u0061\u006c\u006c\u006f\u0077\u0073\u0020at\u0020\u006d\u006fs\u0074\u0020t\u0077\u006f\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_eccb := args[0].AsNumber()
	if _eccb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020F\u004c\u004f\u004f\u0052\u002e\u0050\u0052E\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bgbb := float64(1)
	if _eccb.ValueNumber < 0 {
		_bgbb = -1
	}
	if len(args) > 1 {
		_feab := args[1].AsNumber()
		if _feab.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006ed\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020F\u004c\u004f\u004f\u0052\u002e\u0050\u0052\u0045\u0043\u0049\u0053\u0045\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065r")
		}
		_bgbb = _gfc.Abs(_feab.ValueNumber)
	}
	if len(args) == 1 {
		return MakeNumberResult(_gfc.Floor(_eccb.ValueNumber))
	}
	_ebfg := _eccb.ValueNumber
	_ebfg, _fegbc := _gfc.Modf(_ebfg / _bgbb)
	if _fegbc != 0 {
		if _eccb.ValueNumber < 0 {
			_ebfg--
		}
	}
	return MakeNumberResult(_ebfg * _bgbb)
}
func _fbf(_ba Result) bool {
	if _ba.Type == ResultTypeString {
		return _ba.ValueString == ""
	}
	return _ba.ValueNumber == 0
}

const _degb = 57376

func _fbabb(_deea, _efd float64, _geg int) (float64, Result) {
	_dfbbg, _bad := _eeec(_deea), _eeec(_efd)
	_bfb := _dfbbg.Unix()
	_gfcg := _bad.Unix()
	if _bfb == _gfcg {
		return 0, _gaef
	}
	_fec, _afbd, _abee := _dfbbg.Date()
	_fbgc, _daag, _egc := _bad.Date()
	_bbbd, _cad := int(_afbd), int(_daag)
	var _ecd, _fcfd float64
	switch _geg {
	case 0:
		if _abee == 31 {
			_abee--
		}
		if _abee == 30 && _egc == 31 {
			_egc--
		} else if _bgbf := _acec(_fec); _bbbd == 2 && ((_bgbf && _abee == 29) || (!_bgbf && _abee == 28)) {
			_abee = 30
			if _geda := _acec(_fbgc); _cad == 2 && ((_geda && _egc == 29) || (!_geda && _egc == 28)) {
				_egc = 30
			}
		}
		_ecd = float64((_fbgc-_fec)*360 + (_cad-_bbbd)*30 + (_egc - _abee))
		_fcfd = 360
	case 1:
		_ecd = _efd - _deea
		_acef := _fec != _fbgc
		if _acef && (_fbgc != _fec+1 || _bbbd < _cad || (_bbbd == _cad && _abee < _egc)) {
			_dbdf := 0
			for _beeb := _fec; _beeb <= _fbgc; _beeb++ {
				_dbdf += _bbefe(_beeb, 1)
			}
			_fcfd = float64(_dbdf) / float64(_fbgc-_fec+1)
		} else {
			if !_acef && _acec(_fec) {
				_fcfd = 366
			} else {
				if _acef && ((_acec(_fec) && (_bbbd < 2 || (_bbbd == 2 && _abee <= 29))) || (_acec(_fbgc) && (_cad > 2 || (_cad == 2 && _egc == 29)))) {
					_fcfd = 366
				} else {
					_fcfd = 365
				}
			}
		}
	case 2:
		_ecd = _efd - _deea
		_fcfd = 360
	case 3:
		_ecd = _efd - _deea
		_fcfd = 365
	case 4:
		if _abee == 31 {
			_abee--
		}
		if _egc == 31 {
			_egc--
		}
		_ecd = float64((_fbgc-_fec)*360 + (_cad-_bbbd)*30 + (_egc - _abee))
		_fcfd = 360
	default:
		return 0, MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073 \u0066o\u0072\u0020\u0059\u0065\u0061\u0072\u0046r\u0061\u0063")
	}
	return _ecd / _fcfd, _gaef
}

//go:generate ragel -G2 -Z lexer.rl
//go:generate goimports -w lexer.go
type Lexer struct {
	_fbfbd chan *node
	_bgada _f.Mutex
	_gbaba []chan *node
	_eafbd []*node
}

var _bde = [...]uint8{0, 16, 29, 43, 56, 68, 80, 91, 102, 113, 125, 137, 148, 163}
var _becg = [...]int{-1000, -7, -3, -1, 27, 18, 22, 23, -2, -8, -4, -9, 20, -14, 10, 11, 12, 13, -5, -13, -6, -12, 17, 16, 15, 9, 4, 5, 22, 23, 24, 25, 26, 28, 29, 30, 31, 27, 32, 35, -1, 18, 27, -15, -17, -1, -1, -1, -1, 33, -5, 4, 5, 21, -16, -11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 36, 34, 21, -5, 33, 21, 34, 19, -17, -1, -5, -10, -1}

// Large implements the Excel LARGE function.
func Large(args []Result) Result { return _egdg(args, true) }

var _bdbcb = []ri{{1000, "\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// Reference returns a string reference value to a cell.
func (_dfd CellRef) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeCell, Value: _dfd._acb}
}

// NewNumber constructs a new number expression.
func NewNumber(v string) Expression {
	_aaefe, _adbc := _ff.ParseFloat(v, 64)
	if _adbc != nil {
		_ga.Log.Debug("e\u0072\u0072\u006f\u0072\u0020\u0070a\u0072\u0073\u0069\u006e\u0067\u0020f\u006f\u0072\u006d\u0075\u006c\u0061\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0025\u0073\u003a\u0020%\u0076", v, _adbc)
	}
	return Number{_dddg: _aaefe}
}
func (_cac *evCache) SetCache(key string, value Result) {
	_cac._cgb.Lock()
	_cac._agf[key] = value
	_cac._cgb.Unlock()
}

// String returns an empty string for Error.
func (_fc Error) String() string { return "" }
func (_agab ReferenceType) String() string {
	if _agab >= ReferenceType(len(_faac)-1) {
		return _c.Sprintf("\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _agab)
	}
	return _dfca[_faac[_agab]:_faac[_agab+1]]
}

const _gcafg = 57366

// Minute is an implementation of the Excel MINUTE() function.
func Minute(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0049\u004e\u0055T\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_bdeg := args[0]
	switch _bdeg.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(0)
	case ResultTypeNumber:
		_dcdb := _eeec(_bdeg.ValueNumber)
		return MakeNumberResult(float64(_dcdb.Minute()))
	case ResultTypeString:
		_fdfe := _gg.ToLower(_bdeg.ValueString)
		if !_gfb(_fdfe) {
			_, _, _, _ddg, _cggb := _agda(_fdfe)
			if _cggb.Type == ResultTypeError {
				_cggb.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s\u0020\u0066\u006f\u0072\u0020\u004d\u0049\u004e\u0055\u0054\u0045"
				return _cggb
			}
			if _ddg {
				return MakeNumberResult(0)
			}
		}
		_, _dded, _, _, _, _bgba := _cefg(_fdfe)
		if _bgba.Type == ResultTypeError {
			return _bgba
		}
		return MakeNumberResult(float64(_dded))
	default:
		return MakeErrorResult("\u0049\u006ec\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u004d\u0049NU\u0054\u0045")
	}
}

// Value is an implementation of the Excel VALUE function.
func Value(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0056\u0041\u004c\u0055\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020a\u0020s\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_aaeg := args[0]
	if _aaeg.Type == ResultTypeNumber {
		return _aaeg
	}
	if _aaeg.Type == ResultTypeString {
		_ffaed, _gdbeg := _ff.ParseFloat(_aaeg.Value(), 64)
		if _gdbeg == nil {
			return MakeNumberResult(_ffaed)
		}
	}
	return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0056\u0041L\u0055\u0045")
}

// Parse parses an io.Reader to get an Expression. If expression is parsed with an error, nil is returned
func Parse(r _ef.Reader) Expression {
	_fdbgd := &plex{_cbgec: LexReader(r)}
	_cbed(_fdbgd)
	if _fdbgd._cegf != "" {
		return nil
	}
	return _fdbgd._beaab
}
func _acec(_dbf int) bool {
	if _dbf == _dbf/400*400 {
		return true
	}
	if _dbf == _dbf/100*100 {
		return false
	}
	return _dbf == _dbf/4*4
}

// Eval evaluates and returns the result of the NamedRangeRef reference.
func (_dbag NamedRangeRef) Eval(ctx Context, ev Evaluator) Result {
	_eeafc := ctx.NamedRange(_dbag._cgag)
	_gbddgb := _eeafc.Value
	if _beaa, _dccg := ev.GetFromCache(_gbddgb); _dccg {
		return _beaa
	}
	_geece := _gg.Split(_gbddgb, "\u0021")
	if len(_geece) != 2 {
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006e\u0061\u006de\u0064 \u0072\u0061\u006e\u0067\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0025\u0073", _gbddgb))
	}
	_gadag := ctx.Sheet(_geece[0])
	_edbgb := _gg.Split(_geece[1], "\u003a")
	switch len(_edbgb) {
	case 1:
		_aecegg := ev.Eval(_gadag, _edbgb[0])
		ev.SetCache(_gbddgb, _aecegg)
		return _aecegg
	case 2:
		_abdb := _efagg(_gadag, ev, _edbgb[0], _edbgb[1])
		ev.SetCache(_gbddgb, _abdb)
		return _abdb
	}
	return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070e \u0025\u0073", _eeafc.Type))
}
func _cead(_edcbb Result, _adea *criteriaParsed) bool {
	if _edcbb.IsBoolean {
		return false
	}
	_gfba := _edcbb.Type
	if _adea._dbde {
		return _gfba == ResultTypeNumber && _edcbb.ValueNumber == _adea._bgfgb
	} else if _gfba == ResultTypeNumber {
		return _cfbbe(_edcbb.ValueNumber, _adea._edgc)
	}
	return _defa(_edcbb, _adea)
}

// DateDif is an implementation of the Excel DATEDIF() function.
func DateDif(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeString {
		return MakeErrorResult("\u0044\u0041\u0054\u0045\u0044I\u0046\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077o\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u006e\u0064\u0020\u006f\u006e\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_aagb := args[0].ValueNumber
	_bba := args[1].ValueNumber
	if _bba < _aagb {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0068\u0065\u0020\u0073\u0074\u0061r\u0074\u0020\u0064a\u0074\u0065\u0020\u0069s\u0020\u0067\u0072\u0065\u0061\u0074\u0065\u0072\u0020\u0074\u0068\u0061\u006e\u0020\u0074\u0068\u0065\u0020\u0065\u006e\u0064\u0020\u0064\u0061\u0074\u0065")
	}
	if _bba == _aagb {
		return MakeNumberResult(0)
	}
	_afb := _gg.ToLower(args[2].ValueString)
	if _afb == "\u0064" {
		return MakeNumberResult(_bba - _aagb)
	}
	_cee := _eeec(_aagb)
	_fbab := _eeec(_bba)
	_acee, _bbbf, _ebe := _cee.Date()
	_ega, _dbe, _gbe := _fbab.Date()
	_dgg := int(_bbbf)
	_eeeag := int(_dbe)
	var _adb float64
	switch _afb {
	case "\u0079":
		_adb = float64(_ega - _acee)
		if _eeeag < _dgg || (_eeeag == _dgg && _gbe < _ebe) {
			_adb--
		}
	case "\u006d":
		_gff := _ega - _acee
		_dada := _eeeag - _dgg
		if _gbe < _ebe {
			_dada--
		}
		if _dada < 0 {
			_gff--
			_dada += 12
		}
		_adb = float64(_gff*12 + _dada)
	case "\u006d\u0064":
		_bbeg := _eeeag
		if _gbe < _ebe {
			_bbeg--
		}
		_adb = float64(int(_bba - _gfea(_ega, _bbeg, _ebe)))
	case "\u0079\u006d":
		_adb = float64(_eeeag - _dgg)
		if _gbe < _ebe {
			_adb--
		}
		if _adb < 0 {
			_adb += 12
		}
	case "\u0079\u0064":
		_cfbb := _ega
		if _eeeag < _dgg || (_eeeag == _dgg && _gbe < _ebe) {
			_cfbb--
		}
		_adb = float64(int(_bba - _gfea(_cfbb, _dgg, _ebe)))
	default:
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0069\u006e\u0074e\u0072\u0076\u0061\u006c\u0020\u0076\u0061\u006c\u0075\u0065")
	}
	return MakeNumberResult(_adb)
}

// ISREF is an implementation of the Excel ISREF() function.
func IsRef(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u0052\u0045\u0046\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(ev.LastEvalIsRef())
}

// Update returns the same object as updating sheet references does not affect EmptyExpr.
func (_bfd EmptyExpr) Update(q *_de.UpdateQuery) Expression { return _bfd }

// Parse parses a string to get an Expression.
func ParseString(s string) Expression {
	if s == "" {
		return NewEmptyExpr()
	}
	return Parse(_gg.NewReader(s))
}

const _dgea = "\u0028\u0028\u005b0\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u005c\u002e\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u0028\u0020(\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

var _eadgg _f.Mutex

func init() {
	_babe()
	RegisterFunction("\u0041V\u0045\u0052\u0041\u0047\u0045", Average)
	RegisterFunction("\u0041\u0056\u0045\u0052\u0041\u0047\u0045\u0041", Averagea)
	RegisterFunction("\u0043\u004f\u0055N\u0054", Count)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0041", Counta)
	RegisterFunction("\u0043O\u0055\u004e\u0054\u0049\u0046", CountIf)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0049\u0046\u0053", CountIfs)
	RegisterFunction("\u0043\u004f\u0055\u004e\u0054\u0042\u004c\u0041\u004e\u004b", CountBlank)
	RegisterFunction("\u004d\u0041\u0058", Max)
	RegisterFunction("\u004d\u0041\u0058\u0041", MaxA)
	RegisterFunction("\u004d\u0041\u0058\u0049\u0046\u0053", MaxIfs)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u004d\u0041\u0058\u0049\u0046\u0053", MaxIfs)
	RegisterFunction("\u004d\u0045\u0044\u0049\u0041\u004e", Median)
	RegisterFunction("\u004d\u0049\u004e", Min)
	RegisterFunction("\u004d\u0049\u004e\u0041", MinA)
	RegisterFunction("\u004d\u0049\u004e\u0049\u0046\u0053", MinIfs)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u004d\u0049\u004e\u0049\u0046\u0053", MinIfs)
}

// Offset is an implementation of the Excel OFFSET function.
func Offset(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 3 && len(args) != 5 {
		return MakeErrorResult("\u004f\u0046\u0046\u0053\u0045\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0068\u0072\u0065e\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_edaf := args[0].Ref
	for _edaf.Type == ReferenceTypeNamedRange {
		_edaf = ctx.NamedRange(_edaf.Value)
	}
	_fgaf := ""
	switch _edaf.Type {
	case ReferenceTypeCell:
		_fgaf = _edaf.Value
	case ReferenceTypeRange:
		_bccdb := _gg.Split(_edaf.Value, "\u003a")
		if len(_bccdb) == 2 {
			_fgaf = _bccdb[0]
		}
	default:
		return MakeErrorResult(_c.Sprintf("\u0049\u006ev\u0061\u006c\u0069\u0064\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0069\u006e\u0020\u004f\u0046\u0046\u0053\u0045\u0054\u0028\u0029: \u0025\u0073", _edaf.Type))
	}
	_geec, _bbefd := _ee.ParseCellReference(_fgaf)
	if _bbefd != nil {
		return MakeErrorResult(_c.Sprintf("\u0070\u0061\u0072s\u0065\u0020\u006f\u0072i\u0067\u0069\u006e\u0020\u0065\u0072\u0072o\u0072\u0020\u004f\u0046\u0046\u0053\u0045\u0054\u0028\u0029\u003a\u0020\u0025\u0073", _bbefd.Error()))
	}
	_dfef, _ebed, _agdaa := _geec.Column, _geec.RowIdx, _geec.SheetName
	_dage := args[1].AsNumber()
	if _dage.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0046\u0046SE\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u0075m\u0065r\u0069\u0063\u0020\u0072\u006f\u0077\u0020\u006f\u0066\u0066\u0073\u0065\u0074")
	}
	_afbdb := args[2].AsNumber()
	if _afbdb.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0046\u0046SE\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u0075m\u0065r\u0069\u0063\u0020\u0063\u006f\u006c\u0020\u006f\u0066\u0066\u0073\u0065\u0074")
	}
	var _becc, _geac Result
	if len(args) == 3 {
		_becc = MakeNumberResult(1)
		_geac = MakeNumberResult(1)
	} else {
		_becc = args[3].AsNumber()
		if _becc.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0046\u0046\u0053\u0045\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0068\u0065\u0069\u0067\u0068\u0074")
		}
		if _becc.ValueNumber == 0 {
			return MakeErrorResultType(ErrorTypeRef, "")
		}
		_geac = args[4].AsNumber()
		if _geac.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0046F\u0053\u0045\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0077id\u0074\u0068")
		}
		if _geac.ValueNumber == 0 {
			return MakeErrorResultType(ErrorTypeRef, "")
		}
	}
	_bbca := _ee.ColumnToIndex(_dfef)
	_ecaa := _ebed + uint32(_dage.ValueNumber)
	_fbbg := _bbca + uint32(_afbdb.ValueNumber)
	_gfgc := _ecaa + uint32(_becc.ValueNumber)
	_aegc := _fbbg + uint32(_geac.ValueNumber)
	if _becc.ValueNumber > 0 {
		_gfgc--
	} else {
		_gfgc++
		_ecaa, _gfgc = _gfgc, _ecaa
	}
	if _geac.ValueNumber > 0 {
		_aegc--
	} else {
		_aegc++
		_fbbg, _aegc = _aegc, _fbbg
	}
	_acfg := _c.Sprintf("\u0025\u0073\u0025\u0064", _ee.IndexToColumn(_fbbg), _ecaa)
	_edgdb := _c.Sprintf("\u0025\u0073\u0025\u0064", _ee.IndexToColumn(_aegc), _gfgc)
	if _agdaa == "" {
		return _efagg(ctx, ev, _acfg, _edgdb)
	} else {
		return _efagg(ctx.Sheet(_agdaa), ev, _acfg, _edgdb)
	}
}

// Rept is an implementation of the Excel REPT function that returns n copies of
// a string.
func Rept(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("R\u0045\u0050\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	_cdcf := args[0].AsString()
	if _cdcf.Type != ResultTypeString {
		return MakeErrorResult("\u0050R\u004f\u0050E\u0052\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_abdab := args[1].AsNumber()
	if _abdab.Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052O\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	if _abdab.ValueNumber < 0 {
		return MakeErrorResult("\u0050\u0052\u004fP\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074o\u0020\u0062\u0065\u0020\u003e\u003d\u0020\u0030")
	}
	if _abdab.ValueNumber == 0 {
		return MakeStringResult("")
	}
	_egad := _gb.Buffer{}
	for _aagag := 0; _aagag < int(_abdab.ValueNumber); _aagag++ {
		_egad.WriteString(_cdcf.ValueString)
	}
	return MakeStringResult(_egad.String())
}

// GetLabelPrefix returns an empty string for the invalid reference context.
func (_baec *ivr) GetLabelPrefix(cellRef string) string { return "" }

// Rate implements the Excel RATE function.
func Rate(args []Result) Result {
	_gggc := len(args)
	if _gggc < 3 || _gggc > 6 {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0074\u0068\u0072\u0065\u0065 \u0061\u006e\u0064\u0020\u0073i\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gfdf := args[0].ValueNumber
	if _gfdf != float64(int(_gfdf)) {
		return MakeErrorResultType(ErrorTypeNum, "R\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072i\u006fd\u0073\u0020\u0074\u006f \u0062\u0065 \u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065q\u0075\u0069\u0072e\u0073\u0020\u0070\u0061y\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cfgdc := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_deda := args[2].ValueNumber
	_gccb := 0.0
	if _gggc >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_gccb = args[3].ValueNumber
	}
	_fcag := 0.0
	if _gggc >= 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("R\u0041\u0054\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_fcag = args[4].ValueNumber
		if _fcag != 0 {
			_fcag = 1
		}
	}
	_abge := 0.1
	if _gggc >= 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("\u0052\u0041\u0054\u0045\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_abge = args[5].ValueNumber
	}
	_ggde := 100
	_ffbdb := 0
	_aaad := false
	_gcead := 1e-6
	_facg := _abge
	for _ffbdb < _ggde && !_aaad {
		_afdb := _gfc.Pow(_facg+1, _gfdf)
		_bbeb := _gfc.Pow(_facg+1, _gfdf-1)
		_eeac := _facg*_fcag + 1
		_eede := _cfgdc * (_afdb - 1)
		_dcff := _gccb + _afdb*_deda + _eede*_eeac/_facg
		_daccd := _gfdf*_bbeb*_deda - _eede*_eeac/_gfc.Pow(_facg, 2)
		_cgbgd := (_gfdf*_cfgdc*_bbeb*_eeac + _eede*_fcag) / _facg
		_dacd := _dcff / (_daccd + _cgbgd)
		if _gfc.Abs(_dacd) < _gcead {
			_aaad = true
		}
		_ffbdb++
		_facg -= _dacd
	}
	return MakeNumberResult(_facg)
}
func _fcab(_fbac, _gaea float64) float64 {
	_fbac = _gfc.Trunc(_fbac)
	_gaea = _gfc.Trunc(_gaea)
	if _fbac == 0 && _gaea == 0 {
		return 0
	}
	return _fbac * _gaea / _efcge(_fbac, _gaea)
}

var ReferenceInvalid = Reference{Type: ReferenceTypeInvalid}

func _ebfd(_agcc []Result, _aada string) (float64, float64, Result) {
	if len(_agcc) != 2 {
		return 0, 0, MakeErrorResult(_aada + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _agcc[0].Type != ResultTypeNumber {
		return 0, 0, MakeErrorResult(_aada + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0061\u006c\u0020\u0064\u006f\u006c\u006c\u0061\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_ead := _agcc[0].ValueNumber
	if _agcc[1].Type != ResultTypeNumber {
		return 0, 0, MakeErrorResult(_aada + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_fdd := float64(int(_agcc[1].ValueNumber))
	if _fdd < 0 {
		return 0, 0, MakeErrorResultType(ErrorTypeNum, _aada+"\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073 \u0066\u0072\u0061c\u0074\u0069\u006f\u006e\u0020\u0074\u006f\u0020\u0062e \u006e\u006f\u006e \u006e\u0065g\u0061\u0074\u0069\u0076\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	return _ead, _fdd, _gaef
}

// ISODD is an implementation of the Excel ISODD() function.
func IsOdd(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004f\u0044\u0044\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u0053\u004f\u0044\u0044\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061 \u006eu\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dabd := int(args[0].ValueNumber)
	return MakeBoolResult(_dabd != _dabd/2*2)
}

// Coupnum implements the Excel COUPNUM function.
func Coupnum(args []Result) Result {
	_afbe, _bdgf := _acdf(args, "\u0043O\u0055\u0050\u004e\u0055\u004d")
	if _bdgf.Type == ResultTypeError {
		return _bdgf
	}
	_ggf := _afbe._gedd
	_gaag := _afbe._bgd
	_ecgb, _bdgf := _dbbg(_afbe._fafb, _afbe._ecf, _ggf, _gaag)
	if _bdgf.Type == ResultTypeError {
		return _bdgf
	}
	return MakeNumberResult(_ecgb)
}

const (
	ErrorTypeValue ErrorType = iota
	ErrorTypeNull
	ErrorTypeRef
	ErrorTypeName
	ErrorTypeNum
	ErrorTypeSpill
	ErrorTypeNA
	ErrorTypeDivideByZero
)

// PrefixRangeExpr is a range expression that when evaluated returns a list of Results from a given sheet like Sheet1!A1:B4 (all cells from A1 to B4 from a sheet 'Sheet1').
type PrefixRangeExpr struct{ _gfdcf, _cbcgb, _fece Expression }

func _ggbac(_eed []Result, _fdae string) (*cumulArgs, Result) {
	if len(_eed) != 6 {
		return nil, MakeErrorResult(_fdae + "\u0020\u0072\u0065qu\u0069\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _eed[0].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fdae + "\u0020\u0072eq\u0075\u0069\u0072e\u0073\u0020\u0072\u0061te \u0074o \u0062\u0065\u0020\u006e\u0075\u006d\u0062er\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_eda := _eed[0].ValueNumber
	if _eda <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+"\u0020r\u0065\u0071u\u0069\u0072\u0065s\u0020\u0072\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006fs\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _eed[1].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fdae + "\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_ffad := _eed[1].ValueNumber
	if _ffad <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f \u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u0061r\u0067\u0075\u006de\u006e\u0074")
	}
	if _eed[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fdae + "\u0020r\u0065\u0071u\u0069\u0072\u0065s\u0020\u0070\u0072\u0065\u0073\u0065\u006et\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_beeba := _eed[2].ValueNumber
	if _beeba <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _eed[3].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fdae + "\u0020r\u0065\u0071u\u0069\u0072\u0065\u0073 \u0073\u0074\u0061r\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_fffe := _eed[3].ValueNumber
	if _fffe <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+"\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073t\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069o\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if _eed[4].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_fdae + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bcac := _eed[4].ValueNumber
	if _bcac <= 0 {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+"\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020\u0070\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	if _bcac < _fffe {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+"\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0065\u006e\u0064\u0020p\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006c\u0061\u0074\u0065\u0072\u0020o\u0072\u0020\u0065\u0071\u0075a\u006c\u0020\u0074\u006f\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064")
	}
	if _bcac > _ffad {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+" \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074o\u0020\u0062\u0065\u0020\u0069\u006e\u0020\u0070\u0065\u0072io\u0064\u0073\u0020r\u0061n\u0067\u0065")
	}
	_bagg := int(_eed[5].ValueNumber)
	if _bagg != 0 && _bagg != 1 {
		return nil, MakeErrorResultType(ErrorTypeNum, _fdae+" \u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f \u0062\u0065\u00200\u0020o\u0072\u0020\u0031")
	}
	return &cumulArgs{_eda, _ffad, _beeba, _fffe, _bcac, _bagg}, _gaef
}

// Price implements the Excel PRICE function.
func Price(args []Result) Result {
	_bcfaf := len(args)
	if _bcfaf != 6 && _bcfaf != 7 {
		return MakeErrorResult("\u0050\u0052I\u0043\u0045\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020o\u0072\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_edge, _beeg, _cffa := _geae(args[0], args[1], "\u0050\u0052\u0049C\u0045")
	if _cffa.Type == ResultTypeError {
		return _cffa
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049CE\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072a\u0074e\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ebca := args[2].ValueNumber
	if _ebca < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u006eo\u0074\u0020\u0062\u0065\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0052\u0049\u0043\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0079\u0069\u0065\u006c\u0064\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
	}
	_bgeag := args[3].ValueNumber
	if _bgeag < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0079\u0069\u0065\u006c\u0064 \u0074\u006f\u0020\u006e\u006f\u0074\u0020\u0062\u0065\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0072\u0065\u0064em\u0070\u0074\u0069\u006fn\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_gfbe := args[4].ValueNumber
	if _gfbe <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049\u0043\u0045\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073 \u0072\u0065\u0064\u0065\u006d\u0070\u0074\u0069\u006f\u006e \u0074\u006f\u0020\u0062\u0065 p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_feeg := args[5]
	if _feeg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0066\u0072\u0065\u0071\u0075e\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_ccfdb := _feeg.ValueNumber
	if !_beg(_ccfdb) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_dbcf := 0
	if _bcfaf == 7 && args[6].Type != ResultTypeEmpty {
		if args[6].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0052\u0049C\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_dbcf = int(args[6].ValueNumber)
		if !_dfeg(_dbcf) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069s\u0020a\u0072g\u0075m\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020\u0050\u0052\u0049\u0043\u0045")
		}
	}
	_gefb, _cffa := _cfba(_edge, _beeg, _ebca, _bgeag, _gfbe, _ccfdb, _dbcf)
	if _cffa.Type == ResultTypeError {
		return _cffa
	}
	return MakeNumberResult(_gefb)
}
func (_bfbbd *plex) Lex(lval *yySymType) int {
	_befg = true
	_aafb := <-_bfbbd._cbgec
	if _aafb != nil {
		lval._aacfc = _aafb
		return int(lval._aacfc._cgbd)
	}
	return 0
}

const _feed = 16

// SupportedFunctions returns a list of supported functions.
func SupportedFunctions() []string {
	_gcff := []string{}
	for _gcadd := range _bfgfa {
		_gcff = append(_gcff, _gcadd)
	}
	for _gbede := range _ecdeb {
		_gcff = append(_gcff, _gbede)
	}
	_eaf.Strings(_gcff)
	return _gcff
}
func _efbg(_ddabb string, _bdgdc func(_gffd float64) float64) Function {
	return func(_dgde []Result) Result {
		if len(_dgde) != 1 {
			return MakeErrorResult(_ddabb + "\u0020\u0072\u0065\u0071ui\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_gdde := _dgde[0].AsNumber()
		switch _gdde.Type {
		case ResultTypeNumber:
			_agca := _bdgdc(_gdde.ValueNumber)
			if _gfc.IsNaN(_agca) {
				return MakeErrorResult(_ddabb + "\u0020\u0072\u0065\u0074\u0075\u0072\u006e\u0065\u0064\u0020\u004e\u0061\u004e")
			}
			if _gfc.IsInf(_agca, 0) {
				return MakeErrorResult(_ddabb + "\u0020r\u0065t\u0075\u0072\u006e\u0065\u0064 \u0069\u006ef\u0069\u006e\u0069\u0074\u0079")
			}
			if _agca == 0 {
				return MakeErrorResultType(ErrorTypeDivideByZero, _ddabb+"\u0020d\u0069v\u0069\u0064\u0065\u0020\u0062\u0079\u0020\u007a\u0065\u0072\u006f")
			}
			return MakeNumberResult(1 / _agca)
		case ResultTypeList, ResultTypeString:
			return MakeErrorResult(_ddabb + "\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u006e\u0075\u006de\u0072i\u0063\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		case ResultTypeError:
			return _gdde
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068a\u006e\u0064\u006c\u0065d\u0020\u0025\u0073\u0028\u0029\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _ddabb, _gdde.Type))
		}
	}
}
func _gdfd(_cfbgd []Result, _cdceg bool) Result {
	_adag := "\u004d\u0041\u0058"
	if _cdceg {
		_adag = "\u004d\u0041\u0058\u0041"
	}
	if len(_cfbgd) == 0 {
		return MakeErrorResult(_adag + "\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s\u0020\u0061\u0074\u0020\u006c\u0065\u0061s\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cdegc := -_gfc.MaxFloat64
	for _, _gdcge := range _cfbgd {
		switch _gdcge.Type {
		case ResultTypeNumber:
			if (_cdceg || !_gdcge.IsBoolean) && _gdcge.ValueNumber > _cdegc {
				_cdegc = _gdcge.ValueNumber
			}
		case ResultTypeList, ResultTypeArray:
			_bgeba := _gdfd(_gdcge.ListValues(), _cdceg)
			if _bgeba.ValueNumber > _cdegc {
				_cdegc = _bgeba.ValueNumber
			}
		case ResultTypeEmpty:
		case ResultTypeString:
			_cgdg := 0.0
			if _cdceg {
				_cgdg = _gdcge.AsNumber().ValueNumber
			}
			if _cgdg > _cdegc {
				_cdegc = _cgdg
			}
		default:
			_ga.Log.Debug("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020"+_adag+"\u0028\u0029\u0020\u0061rg\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _gdcge.Type)
		}
	}
	if _cdegc == -_gfc.MaxFloat64 {
		_cdegc = 0
	}
	return MakeNumberResult(_cdegc)
}

// Update updates references in the PrefixExpr after removing a row/column.
func (_acac PrefixExpr) Update(q *_de.UpdateQuery) Expression {
	_fefbd := _acac
	_gaeae := _acac._dcfga.String()
	if _gaeae == q.SheetToUpdate {
		_dedcd := *q
		_dedcd.UpdateCurrentSheet = true
		_fefbd._bcbe = _acac._bcbe.Update(&_dedcd)
	}
	return _fefbd
}

// Update updates references in the Range after removing a row/column.
func (_gdacf Range) Update(q *_de.UpdateQuery) Expression {
	_ccaeg := _gdacf
	if q.UpdateCurrentSheet {
		_ccaeg._efbed = _gdacf._efbed.Update(q)
		_ccaeg._abfd = _gdacf._abfd.Update(q)
	}
	return _ccaeg
}
func _cdac(_gagc, _bdae, _bgaa, _aadf float64, _afac int) float64 {
	var _eagb float64
	if _gagc == 0 {
		_eagb = _aadf + _bgaa*_bdae
	} else {
		_bfba := _gfc.Pow(1+_gagc, _bdae)
		if _afac == 1 {
			_eagb = _aadf*_bfba + _bgaa*(1+_gagc)*(_bfba-1)/_gagc
		} else {
			_eagb = _aadf*_bfba + _bgaa*(_bfba-1)/_gagc
		}
	}
	return -_eagb
}

// Xor is an implementation of the Excel XOR() function and takes a variable
// number of arguments. It's odd to say the least.  If any argument is numeric,
// it returns true if the number of non-zero numeric arguments is odd and false
// otherwise.  If no argument is numeric, it returns an error.
func Xor(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0058\u004f\u0052 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061t\u0020l\u0065a\u0073t\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_caea := 0
	_ebac := false
	for _, _bbcb := range args {
		switch _bbcb.Type {
		case ResultTypeList, ResultTypeArray:
			_aadb := Xor(_bbcb.ListValues())
			if _aadb.Type == ResultTypeError {
				return _aadb
			}
			if _aadb.ValueNumber != 0 {
				_caea++
			}
			_ebac = true
		case ResultTypeNumber:
			if _bbcb.ValueNumber != 0 {
				_caea++
			}
			_ebac = true
		case ResultTypeString:
		case ResultTypeError:
			return _bbcb
		default:
			return MakeErrorResult("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0061\u0072\u0067u\u006de\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0058\u004f\u0052")
		}
	}
	if !_ebac {
		return MakeErrorResult("\u0058\u004f\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0069n\u0070\u0075\u0074")
	}
	return MakeBoolResult(_caea%2 != 0)
}

// Mduration implements the Excel MDURATION function.
func Mduration(args []Result) Result {
	_ecgbe, _bgbd := _gfdb(args, "\u004dD\u0055\u0052\u0041\u0054\u0049\u004fN")
	if _bgbd.Type == ResultTypeError {
		return _bgbd
	}
	_degg := _ecgbe._acdb
	_fgad := _ecgbe._fbef
	_cfec := _ecgbe._dgdc
	_bcca := _ecgbe._ggdd
	_edecf := _ecgbe._gbgg
	_fafbd := _ecgbe._bdf
	_daeg := _aggbb(_degg, _fgad, _cfec, _bcca, _edecf, _fafbd)
	if _daeg.Type == ResultTypeError {
		return _daeg
	}
	_cebfd := _daeg.ValueNumber / (1.0 + _bcca/_edecf)
	return MakeNumberResult(_cebfd)
}

// Coupdays implements the Excel COUPDAYS function.
func Coupdays(args []Result) Result {
	_aggb, _ebb := _acdf(args, "\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053")
	if _ebb.Type == ResultTypeError {
		return _ebb
	}
	return MakeNumberResult(_eagc(_aggb._fafb, _aggb._ecf, _aggb._gedd, _aggb._bgd))
}

// Mround is an implementation of the Excel MROUND function.  It is not a
// generic rounding function and has some oddities to match Excel's behavior.
func Mround(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004d\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0077o\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_faafb := args[0].AsNumber()
	if _faafb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006de\u006e\u0074\u0020\u0074o\u0020\u004d\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gdddd := float64(1)
	_ebfff := args[1].AsNumber()
	if _ebfff.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073e\u0063\u006fn\u0064\u0020\u0061\u0072g\u0075\u006d\u0065n\u0074\u0020\u0074\u006f\u0020\u004d\u0052\u004f\u0055ND\u0028\u0029\u0020m\u0075\u0073t\u0020\u0062\u0065\u0020\u0061\u0020n\u0075\u006db\u0065\u0072")
	}
	_gdddd = _ebfff.ValueNumber
	if _gdddd < 0 && _faafb.ValueNumber > 0 || _gdddd > 0 && _faafb.ValueNumber < 0 {
		return MakeErrorResult("\u004d\u0052\u004fUN\u0044\u0028\u0029\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020s\u0069g\u006e\u0073\u0020\u006d\u0075\u0073\u0074\u0020\u006d\u0061\u0074\u0063\u0068")
	}
	_begd := _faafb.ValueNumber
	_begd, _cegb := _gfc.Modf(_begd / _gdddd)
	if _gfc.Trunc(_cegb+0.5) > 0 {
		_begd++
	}
	return MakeNumberResult(_begd * _gdddd)
}

// Small implements the Excel SMALL function.
func Small(args []Result) Result { return _egdg(args, false) }

// Max is an implementation of the Excel MAX() function.
func Max(args []Result) Result { return _gdfd(args, false) }

type yyParser interface {
	Parse(yyLexer) int
	Lookahead() int
}
type plex struct {
	_cbgec chan *node
	_beaab Expression
	_cegf  string
}

// Pi is an implementation of the Excel Pi() function that just returns the Pi
// constant.
func Pi(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("\u0050I\u0028\u0029\u0020\u0061c\u0063\u0065\u0070\u0074\u0073 \u006eo\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074s")
	}
	return MakeNumberResult(_gfc.Pi)
}
func _cbf(_bade, _cbcg, _deefe, _gcee float64, _ddad int) float64 {
	var _fdfb float64
	if _bade == 0 {
		_fdfb = (_deefe + _gcee) / _cbcg
	} else {
		_ddgaf := _gfc.Pow(1+_bade, _cbcg)
		if _ddad == 1 {
			_fdfb = (_gcee*_bade/(_ddgaf-1) + _deefe*_bade/(1-1/_ddgaf)) / (1 + _bade)
		} else {
			_fdfb = _gcee*_bade/(_ddgaf-1) + _deefe*_bade/(1-1/_ddgaf)
		}
	}
	return -_fdfb
}

const _edfc = 57378

// SheetPrefixExpr is a reference to a sheet like Sheet1! (reference to sheet 'Sheet1').
type SheetPrefixExpr struct{ _gegeg string }

var _ggbag = []ri{{1000, "\u004d"}, {995, "\u0056\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {495, "\u0056\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}
var _faac = [...]uint8{0, 20, 37, 60, 78, 96}

func init() {
	RegisterFunction("\u0043\u0048\u0041\u0052", Char)
	RegisterFunction("\u0043\u004c\u0045A\u004e", Clean)
	RegisterFunction("\u0043\u004f\u0044\u0045", Code)
	RegisterFunction("C\u004f\u004e\u0043\u0041\u0054\u0045\u004e\u0041\u0054\u0045", Concat)
	RegisterFunction("\u0043\u004f\u004e\u0043\u0041\u0054", Concat)
	RegisterFunction("\u005f\u0078\u006cf\u006e\u002e\u0043\u004f\u004e\u0043\u0041\u0054", Concat)
	RegisterFunction("\u0045\u0058\u0041C\u0054", Exact)
	RegisterFunction("\u0046\u0049\u004e\u0044", Find)
	RegisterFunctionComplex("\u0046\u0049\u004eD\u0042", Findb)
	RegisterFunction("\u004c\u0045\u0046\u0054", Left)
	RegisterFunction("\u004c\u0045\u0046T\u0042", Left)
	RegisterFunction("\u004c\u0045\u004e", Len)
	RegisterFunction("\u004c\u0045\u004e\u0042", Len)
	RegisterFunction("\u004c\u004f\u0057E\u0052", Lower)
	RegisterFunction("\u004d\u0049\u0044", Mid)
	RegisterFunction("\u0050\u0052\u004f\u0050\u0045\u0052", Proper)
	RegisterFunction("\u0052E\u0050\u004c\u0041\u0043\u0045", Replace)
	RegisterFunction("\u0052\u0045\u0050\u0054", Rept)
	RegisterFunction("\u0052\u0049\u0047H\u0054", Right)
	RegisterFunction("\u0052\u0049\u0047\u0048\u0054\u0042", Right)
	RegisterFunction("\u0053\u0045\u0041\u0052\u0043\u0048", Search)
	RegisterFunctionComplex("\u0053E\u0041\u0052\u0043\u0048\u0042", Searchb)
	RegisterFunction("\u0053\u0055\u0042\u0053\u0054\u0049\u0054\u0055\u0054\u0045", Substitute)
	RegisterFunction("\u0054", T)
	RegisterFunction("\u0054\u0045\u0058\u0054", Text)
	RegisterFunction("\u0054\u0045\u0058\u0054\u004a\u004f\u0049\u004e", TextJoin)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0054\u0045\u0058T\u004a\u004f\u0049\u004e", TextJoin)
	RegisterFunction("\u0054\u0052\u0049\u004d", Trim)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0055\u004e\u0049\u0043\u0048\u0041\u0052", Char)
	RegisterFunction("\u005f\u0078\u006c\u0066\u006e\u002e\u0055\u004e\u0049\u0043\u004f\u0044\u0045", Unicode)
	RegisterFunction("\u0055\u0050\u0050E\u0052", Upper)
	RegisterFunction("\u0056\u0041\u004cU\u0045", Value)
}

// Vdb implements the Excel VDB function.
func Vdb(args []Result) Result {
	_cfcg := len(args)
	if _cfcg < 5 || _cfcg > 7 {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020b\u0065\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u0062\u0065\u0074\u0077\u0065\u0065\u006e\u0020\u0066\u0069\u0076\u0065\u0020a\u006e\u0064\u0020\u0073\u0065v\u0065\u006e")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gbec := args[0].ValueNumber
	if _gbec < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044B \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 co\u0073t \u0074\u006f\u0020\u0062\u0065\u0020\u006eon\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dafd := args[1].ValueNumber
	if _dafd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gcbe := args[2].ValueNumber
	if _gcbe == 0 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _gcbe < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("V\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0074\u0061\u0072\u0074 p\u0065\u0072\u0069\u006fd\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_edgd := args[3].ValueNumber
	if _edgd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065\u0073\u0073\u0020\u0074h\u0061n\u0020\u006f\u006e\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("\u0056D\u0042\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0065\u006e\u0064 \u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_afefe := args[4].ValueNumber
	if _edgd > _afefe {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020s\u0074\u0061\u0072\u0074\u0020\u0070\u0065r\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0056\u0044\u0042")
	}
	if _afefe > _gcbe {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0065\u006e\u0064\u0020\u0070e\u0072i\u006f\u0064\u0020\u0066\u006f\u0072\u0020V\u0044\u0042")
	}
	_ebcge := 2.0
	if _cfcg > 5 {
		if args[5].Type == ResultTypeEmpty {
			_ebcge = 0.0
		} else {
			if args[5].Type != ResultTypeNumber {
				return MakeErrorResult("\u0056\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
			}
			_ebcge = args[5].ValueNumber
			if _ebcge < 0 {
				return MakeErrorResultType(ErrorTypeNum, "\u0056\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
			}
		}
	}
	_beca := false
	if _cfcg > 6 && args[6].Type != ResultTypeEmpty {
		if args[6].Type != ResultTypeNumber {
			return MakeErrorResult("\u0056D\u0042\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020n\u006f\u005f\u0073\u0077\u0069\u0074\u0063\u0068\u0020to\u0020\u0062\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
		}
		_beca = args[6].ValueNumber != 0
	}
	_eedg := 0.0
	_ddab := _gfc.Floor(_edgd)
	_edad := _gfc.Ceil(_afefe)
	if _beca {
		for _bbbac := _ddab + 1; _bbbac <= _edad; _bbbac++ {
			_cecc := _gbf(_gbec, _dafd, _gcbe, _bbbac, _ebcge)
			if _bbbac == _ddab+1 {
				_cecc *= _gfc.Min(_afefe, _ddab+1) - _edgd
			} else if _bbbac == _edad {
				_cecc *= _afefe + 1 - _edad
			}
			_eedg += _cecc
		}
	} else {
		_fbff := _gcbe
		var _gaegb float64
		if !_eddg(_edgd, _gfc.Floor(_edgd)) {
			if _ebcge == 1 {
				_gdgaf := _gcbe / 2
				if _edgd > _gdgaf || _eddg(_edgd, _gdgaf) {
					_gaegb = _edgd - _gdgaf
					_edgd = _gdgaf
					_afefe -= _gaegb
					_fbff++
				}
			}
		}
		if _ebcge != 0 {
			_gbec -= _cgc(_gbec, _dafd, _gcbe, _fbff, _edgd, _ebcge)
		}
		_eedg = _cgc(_gbec, _dafd, _gcbe, _gcbe-_edgd, _afefe-_edgd, _ebcge)
	}
	return MakeNumberResult(_eedg)
}

const _gbdfc = 57371

// CountIfs implements the COUNTIFS function.
func CountIfs(args []Result) Result {
	_eccd := _dcfg(args, false, "\u0043\u004f\u0055\u004e\u0054\u0049\u0046\u0053")
	if _eccd.Type != ResultTypeEmpty {
		return _eccd
	}
	_fbacg := _gcae(args)
	return MakeNumberResult(float64(len(_fbacg)))
}

type yyLexer interface {
	Lex(_gdab *yySymType) int
	Error(_fabg string)
}

// Oddlprice implements the Excel ODDLPRICE function.
func Oddlprice(args []Result) Result {
	if len(args) != 8 && len(args) != 9 {
		return MakeErrorResult("\u004f\u0044\u0044L\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0065\u0069\u0067\u0068\u0074\u0020\u006f\u0072\u0020\u006e\u0069\u006e\u0065\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_eaea, _egeg, _ffdd := _geae(args[0], args[1], "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _ffdd.Type == ResultTypeError {
		return _ffdd
	}
	_gbgb, _ffdd := _bdea(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _ffdd.Type == ResultTypeError {
		return _ffdd
	}
	if _gbgb >= _eaea {
		return MakeErrorResultType(ErrorTypeNum, "\u004c\u0061\u0073\u0074\u0020i\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0064\u0061\u0074\u0065\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074e")
	}
	_gbgbf := args[3]
	if _gbgbf.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_dafac := _gbgbf.ValueNumber
	if _dafac < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	_edga := args[4]
	if _edga.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0079i\u0065\u006c\u0064\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_agdd := _edga.ValueNumber
	if _agdd < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_dcefb := args[5]
	if _dcefb.Type != ResultTypeNumber {
		return MakeErrorResult("\u004fD\u0044\u004cP\u0052\u0049\u0043\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_cfac := _dcefb.ValueNumber
	if _cfac < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_abcc := args[6]
	if _abcc.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049C\u0045\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_dcbg := float64(int(_abcc.ValueNumber))
	if !_beg(_dcbg) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_dbeb := 0
	if len(args) == 8 && args[7].Type != ResultTypeEmpty {
		_bed := args[7]
		if _bed.Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0044\u0044\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0062a\u0073\u0069\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
		}
		_dbeb = int(_bed.ValueNumber)
		if !_dfeg(_dbeb) {
			return MakeErrorResultType(ErrorTypeNum, "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0062\u0061\u0073\u0069s\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020\u004f\u0044\u0044\u004c\u0050\u0052\u0049C\u0045")
		}
	}
	_gfaa, _ffdd := _fbabb(_gbgb, _egeg, _dbeb)
	if _ffdd.Type == ResultTypeError {
		return _ffdd
	}
	_gfaa *= _dcbg
	_acga, _ffdd := _fbabb(_eaea, _egeg, _dbeb)
	if _ffdd.Type == ResultTypeError {
		return _ffdd
	}
	_acga *= _dcbg
	_dccf, _ffdd := _fbabb(_gbgb, _eaea, _dbeb)
	if _ffdd.Type == ResultTypeError {
		return _ffdd
	}
	_dccf *= _dcbg
	_dedd := _cfac + _gfaa*100*_dafac/_dcbg
	_dedd /= _acga*_agdd/_dcbg + 1
	_dedd -= _dccf * 100 * _dafac / _dcbg
	return MakeNumberResult(_dedd)
}

// Rri implements the Excel RRI function.
func Rri(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0052\u0052\u0049\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0052I\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006eu\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dgdcc := args[0].ValueNumber
	if _dgdcc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052R\u0049\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062e\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0052\u0052\u0049\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065\u006e\u0074 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_bbefa := args[1].ValueNumber
	if _bbefa <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052\u0052\u0049\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006et\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("R\u0052\u0049\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0075\u0074\u0075\u0072e \u0076\u0061\u006c\u0075e\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075mb\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cagf := args[2].ValueNumber
	if _cagf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0052R\u0049\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020f\u0075\u0074\u0075\u0072\u0065\u0020\u0076\u0061\u006cue\u0020\u0074\u006f \u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065g\u0061\u0074i\u0076\u0065")
	}
	return MakeNumberResult(_gfc.Pow(_cagf/_bbefa, 1/_dgdcc) - 1)
}

// CeilingMath implements _xlfn.CEILING.MATH which rounds numbers to the nearest
// multiple of the second argument, toward or away from zero as specified by the
// third argument.
func CeilingMath(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0043E\u0049\u004cI\u004e\u0047\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006ee\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u0043E\u0049\u004cI\u004e\u0047\u002eM\u0041\u0054\u0048\u0028\u0029\u0020\u0061l\u006c\u006f\u0077\u0073\u0020\u0061t\u0020\u006d\u006f\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_efedf := args[0].AsNumber()
	if _efedf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u004dA\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061 \u006eu\u006d\u0062\u0065\u0072")
	}
	_acff := float64(1)
	if _efedf.ValueNumber < 0 {
		_acff = -1
	}
	if len(args) > 1 {
		_cbcc := args[1].AsNumber()
		if _cbcc.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0043\u0045\u0049\u004c\u0049\u004e\u0047.\u004d\u0041\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074 \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_acff = _cbcc.ValueNumber
	}
	_ggdb := float64(1)
	if len(args) > 2 {
		_afeea := args[2].AsNumber()
		if _afeea.Type != ResultTypeNumber {
			return MakeErrorResult("\u0074\u0068\u0069\u0072\u0064\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0043\u0045\u0049\u004c\u0049\u004e\u0047\u002e\u004dA\u0054\u0048\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061 \u006eu\u006d\u0062\u0065\u0072")
		}
		_ggdb = _afeea.ValueNumber
	}
	if len(args) == 1 {
		return MakeNumberResult(_gfc.Ceil(_efedf.ValueNumber))
	}
	_cfca := _efedf.ValueNumber
	_cfca, _bfgb := _gfc.Modf(_cfca / _acff)
	if _bfgb != 0 {
		if _efedf.ValueNumber > 0 {
			_cfca++
		} else if _ggdb < 0 {
			_cfca--
		}
	}
	return MakeNumberResult(_cfca * _acff)
}

// NewFunction constructs a new function call expression.
func NewFunction(name string, args []Expression) Expression {
	return FunctionCall{_bbfgf: name, _ebbe: args}
}
func _fcc() {
	_fba["\u006d\u006d\u002f\u0064\u0064\u002f\u0079\u0079"] = _ed.MustCompile("\u005e" + _dge + _cca)
	_fba["\u006dm\u0020\u0064\u0064\u002c\u0020\u0079y"] = _ed.MustCompile("\u005e" + _dga + _cca)
	_fba["\u0079\u0079\u002d\u006d\u006d\u002d\u0064\u0064"] = _ed.MustCompile("\u005e" + _edec + _cca)
	_fba["y\u0079\u002d\u006d\u006d\u0053\u0074\u0072\u002d\u0064\u0064"] = _ed.MustCompile("\u005e" + _dba + _cca)
	_eeea["\u0068\u0068"] = _ed.MustCompile(_afeb + _ace + "\u0024")
	_eeea["\u0068\u0068\u003am\u006d"] = _ed.MustCompile(_afeb + _eae + "\u0024")
	_eeea["\u006d\u006d\u003as\u0073"] = _ed.MustCompile(_afeb + _dgea + "\u0024")
	_eeea["\u0068\u0068\u003a\u006d\u006d\u003a\u0073\u0073"] = _ed.MustCompile(_afeb + _bcfd + "\u0024")
	_fgga = []*_ed.Regexp{_ed.MustCompile("\u005e" + _dge + "\u0024"), _ed.MustCompile("\u005e" + _dga + "\u0024"), _ed.MustCompile("\u005e" + _edec + "\u0024"), _ed.MustCompile("\u005e" + _dba + "\u0024")}
	_aee = []*_ed.Regexp{_ed.MustCompile("\u005e" + _ace + "\u0024"), _ed.MustCompile("\u005e" + _eae + "\u0024"), _ed.MustCompile("\u005e" + _dgea + "\u0024"), _ed.MustCompile("\u005e" + _bcfd + "\u0024")}
}

// NewError constructs a new error expression from a string.
func NewError(v string) Expression { return Error{_cbgb: v} }

// GetFilename returns an empty string for the invalid reference context.
func (_ceag *ivr) GetFilename() string { return "" }

const _bddgc = 57374

// Fvschedule implements the Excel FVSCHEDULE function.
func Fvschedule(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045D\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077\u006f\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048E\u0044\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0070\u0072\u0069\u006e\u0063\u0069\u0070\u0061\u006c\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_gdea := args[0].ValueNumber
	switch args[1].Type {
	case ResultTypeNumber:
		return MakeNumberResult(_gdea * (args[1].ValueNumber + 1))
	case ResultTypeList, ResultTypeArray:
		_gbee := _bbcd(args[1])
		for _, _ccaf := range _gbee {
			for _, _ccda := range _ccaf {
				if _ccda.Type != ResultTypeNumber || _ccda.IsBoolean {
					return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0073")
				}
				_gdea *= 1.0 + _ccda.ValueNumber
			}
		}
		return MakeNumberResult(_gdea)
	default:
		return MakeErrorResult("\u0046\u0056\u0053\u0043\u0048\u0045\u0044\u0055\u004c\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0063\u0068\u0065\u0064\u0075\u006c\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0072\u0020\u0061\u0072\u0072a\u0079\u0020\u0074y\u0070\u0065")
	}
}
func (_bggbc Result) String() string { return _bggbc.Value() }

const _gdce = 57356

// MinIfs implements the MINIFS function.
func MinIfs(args []Result) Result {
	_aebe := _dcfg(args, true, "\u004d\u0049\u004e\u0049\u0046\u0053")
	if _aebe.Type != ResultTypeEmpty {
		return _aebe
	}
	_dfgee := _gcae(args[1:])
	_gbcc := _gfc.MaxFloat64
	_ddgd := _bbcd(args[0])
	for _, _cbaab := range _dfgee {
		_gafg := _ddgd[_cbaab._gefg][_cbaab._facdg].ValueNumber
		if _gbcc > _gafg {
			_gbcc = _gafg
		}
	}
	if _gbcc == _gfc.MaxFloat64 {
		_gbcc = 0
	}
	return MakeNumberResult(float64(_gbcc))
}

// Indirect is an implementation of the Excel INDIRECT function that returns the
// contents of a cell.
func Indirect(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 && len(args) != 2 {
		return MakeErrorResult("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006e\u0065\u0020\u006f\u0072 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_fdac := args[0].AsString()
	if _fdac.Type != ResultTypeString {
		return MakeErrorResult("\u0049\u004e\u0044\u0049\u0052\u0045\u0043\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069r\u0073t\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066 \u0074\u0079\u0070\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	return ctx.Cell(_fdac.ValueString, ev)
}

type criteriaParsed struct {
	_dbde  bool
	_bgfgb float64
	_ecef  string
	_edgc  *criteriaRegex
}

func _ffdga(_gcbeb, _dbae Reference) string {
	return _c.Sprintf("\u0025\u0073\u003a%\u0073", _gcbeb.Value, _dbae.Value)
}

// String returns a string representation of a vertical range.
func (_ffaad VerticalRange) String() string { return _ffaad.verticalRangeReference() }

// Pduration implements the Excel PDURATION function.
func Pduration(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0050\u0044\u0055RA\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u0074h\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050D\u0055\u0052A\u0054\u0049\u004fN\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0072\u0061\u0074\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_feca := args[0].ValueNumber
	if _feca <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020p\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0063\u0075\u0072\u0072\u0065\u006e\u0074\u0020\u0076\u0061l\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006dbe\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dacce := args[1].ValueNumber
	if _dacce <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "P\u0044\u0055\u0052\u0041\u0054\u0049\u004f\u004e\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 c\u0075\u0072\u0072\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074o \u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0044\u0055\u0052\u0041\u0054I\u004f\u004e\u0020r\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0070\u0065\u0063\u0069\u0066i\u0065\u0064\u0020\u0076\u0061lu\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fad := args[2].ValueNumber
	if _fad <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0044\u0055\u0052\u0041\u0054I\u004f\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0070\u0065\u0063\u0069\u0066\u0069\u0065d\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070o\u0073i\u0074\u0069\u0076\u0065")
	}
	return MakeNumberResult((_gfc.Log10(_fad) - _gfc.Log10(_dacce)) / _gfc.Log10(1+_feca))
}

// Reference returns an invalid reference for ConstArrayExpr.
func (_dg ConstArrayExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

// Decimal is an implementation of the Excel function DECIMAL() that parses a string
// in a given base and returns the numeric result.
func Decimal(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0044\u0045\u0043\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069r\u0065s\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_aeac := args[0].AsString()
	if _aeac.Type != ResultTypeString {
		return MakeErrorResult("D\u0045\u0043\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0074\u0072\u0069\u006e\u0067\u0020\u0066\u0069\u0072\u0073t \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_afeg := args[1].AsNumber()
	if _afeg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0045\u0043\u0049\u004dA\u004c\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eddef := _aeac.ValueString
	if len(_eddef) > 2 && (_gg.HasPrefix(_eddef, "\u0030\u0078") || _gg.HasPrefix(_eddef, "\u0030\u0058")) {
		_eddef = _eddef[2:]
	}
	_gedcb, _cfdg := _ff.ParseInt(_eddef, int(_afeg.ValueNumber), 64)
	if _cfdg != nil {
		return MakeErrorResult("\u0044\u0045C\u0049\u004d\u0041\u004c\u0028\u0029\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0069\u006e\u0020\u0063\u006f\u006e\u0076\u0065\u0072si\u006f\u006e")
	}
	return MakeNumberResult(float64(_gedcb))
}
func _adcb(_deac string) string {
	_deac = _gg.Replace(_deac, "\u000a", "\u005c\u006e", -1)
	_deac = _gg.Replace(_deac, "\u000d", "\u005c\u0072", -1)
	_deac = _gg.Replace(_deac, "\u0009", "\u005c\u0074", -1)
	return _deac
}

// Power is an implementation of the Excel POWER function that raises a number
// to a power. It requires two numeric arguments.
func Power(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_gcac := args[0].AsNumber()
	if _gcac.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_ffcgf := args[1].AsNumber()
	if _ffcgf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0050\u004f\u0057\u0045\u0052\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	return MakeNumberResult(_gfc.Pow(_gcac.ValueNumber, _ffcgf.ValueNumber))
}

const _baac = 86400000000000

type rmode byte

func (_gadf *noCache) SetCache(key string, value Result) {}

// Coupdaysnc implements the Excel COUPDAYSNC function.
func Coupdaysnc(args []Result) Result {
	_dgb, _egda := _acdf(args, "\u0043\u004f\u0055\u0050\u0044\u0041\u0059\u0053\u004e\u0043")
	if _egda.Type == ResultTypeError {
		return _egda
	}
	return MakeNumberResult(_dadd(_dgb._fafb, _dgb._ecf, _dgb._gedd, _dgb._bgd))
}

// SumIf implements the SUMIF function.
func SumIf(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0053\u0055\u004d\u0049\u0046\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0068\u0072e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_ceed := args[0]
	if _ceed.Type != ResultTypeArray && _ceed.Type != ResultTypeList {
		return MakeErrorResult("\u0053\u0055\u004d\u0049\u0046\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0066i\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fcbb := _bbcd(_ceed)
	_feffb := args[2]
	if _feffb.Type != ResultTypeArray && _feffb.Type != ResultTypeList {
		return MakeErrorResult("\u0053\u0055\u004dI\u0046\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0061\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_eeecb := _bbcd(_feffb)
	_gfgfd := _affeg(args[1])
	_ebfgd := 0.0
	for _caga, _bbdg := range _fcbb {
		for _baba, _ggfdb := range _bbdg {
			if _cead(_ggfdb, _gfgfd) {
				_ebfgd += _eeecb[_caga][_baba].ValueNumber
			}
		}
	}
	return MakeNumberResult(_ebfgd)
}

var _fdaae = [...]int{123, -1000, -1000, 74, 163, 103, 163, 163, -1000, -1000, -1000, -1000, 163, -1000, -1000, -1000, -1000, -1000, -12, 106, -1000, -1000, 143, -1000, -1000, -1000, -1000, -1000, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 74, 163, 163, 6, -28, 74, -15, -15, 60, 10, -14, -1000, -1000, -1000, 7, -1000, 74, -15, -15, -23, -23, -1000, -8, -8, -8, -8, -8, -8, -4, 33, -1000, 163, 163, -1000, -1000, 10, -1000, 163, -1000, -28, 74, -1000, -1000, 74}

// ISNUMBER is an implementation of the Excel ISNUMBER() function.
func IsNumber(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053NU\u004d\u0042\u0045R\u0028\u0029\u0020\u0061cce\u0070ts\u0020\u0061\u0020\u0073\u0069\u006e\u0067le\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeNumber)
}

// Ppmt implements the Excel PPPMT function.
func Ppmt(args []Result) Result {
	_ccfdf := len(args)
	if _ccfdf < 4 || _ccfdf > 6 {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006ff\u0020\u0066\u006f\u0075\u0072\u0020a\u006e\u0064\u0020s\u0069\u0078")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("P\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_cfdc := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004dT\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dcfb := args[1].ValueNumber
	if _dcfb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "P\u0050\u004d\u0054\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020p\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069v\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_efdb := args[2].ValueNumber
	if _efdb < _dcfb {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u006f\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064s\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065s\u0073\u0020\u0074\u0068\u0061\u006e \u0070\u0065\u0072i\u006f\u0064")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061r\u0067u\u006d\u0065\u006e\u0074")
	}
	_gcgd := args[3].ValueNumber
	_bdfd := 0.0
	if _ccfdf >= 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0050\u004d\u0054\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s \u0066\u0075\u0074\u0075\u0072\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
		}
		_bdfd = args[4].ValueNumber
	}
	_gfca := 0
	if _ccfdf == 6 && args[5].Type != ResultTypeEmpty {
		if args[5].Type != ResultTypeNumber {
			return MakeErrorResult("P\u0050\u004d\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
		}
		_gfca = int(args[5].ValueNumber)
		if _gfca != 0 {
			_gfca = 1
		}
	}
	return MakeNumberResult(_cbf(_cfdc, _efdb, _gcgd, _bdfd, _gfca) - _dgdfc(_cfdc, _dcfb, _efdb, _gcgd, _bdfd, _gfca))
}

// Reference returns a string reference value to a range with prefix.
func (_baaff PrefixRangeExpr) Reference(ctx Context, ev Evaluator) Reference {
	_beaac := _baaff._gfdcf.Reference(ctx, ev)
	_aaea := _baaff._cbcgb.Reference(ctx, ev)
	_fccfg := _baaff._fece.Reference(ctx, ev)
	if _beaac.Type == ReferenceTypeSheet && _aaea.Type == ReferenceTypeCell && _fccfg.Type == ReferenceTypeCell {
		return MakeRangeReference(_cegd(_beaac, _aaea, _fccfg))
	}
	return ReferenceInvalid
}

const _dbcdd = 57377

// Tbillprice implements the Excel TBILLPRICE function.
func Tbillprice(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("T\u0042\u0049\u004c\u004c\u0050\u0052I\u0043\u0045\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_bebg, _ecba, _faee := _geae(args[0], args[1], "\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045")
	if _faee.Type == ResultTypeError {
		return _faee
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0064\u0069\u0073\u0063\u006f\u0075n\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_afg := _ecba - _bebg
	if _afg > 365 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004cP\u0052\u0049\u0043\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020m\u0061\u0074\u0075r\u0069\u0074\u0079\u0020t\u006f\u0020\u0062\u0065\u0020\u006eo\u0074\u0020\u006d\u006f\u0072\u0065\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065\u0020\u0079e\u0061\u0072\u0020\u0061\u0066\u0074\u0065\u0072\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074")
	}
	_ddbcb := args[2].ValueNumber
	if _ddbcb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0054\u0042\u0049\u004c\u004c\u0050\u0052\u0049\u0043\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020d\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	return MakeNumberResult(100 * (1 - _ddbcb*_afg/360))
}

// Npv implements the Excel NPV function.
func Npv(args []Result) Result {
	_dfbca := len(args)
	if _dfbca < 2 {
		return MakeErrorResult("\u004e\u0050\u0056 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f \u006fr\u0020m\u006f\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020r\u0061\u0074\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ecdc := args[0].ValueNumber
	if _ecdc == -1 {
		return MakeErrorResultType(ErrorTypeDivideByZero, "")
	}
	_ebagd := []float64{}
	for _, _edcf := range args[1:] {
		switch _edcf.Type {
		case ResultTypeNumber:
			_ebagd = append(_ebagd, _edcf.ValueNumber)
		case ResultTypeArray, ResultTypeList:
			_gge := _bbcd(_edcf)
			for _, _ccbfg := range _gge {
				for _, _cae := range _ccbfg {
					if _cae.Type == ResultTypeNumber && !_cae.IsBoolean {
						_ebagd = append(_ebagd, _cae.ValueNumber)
					}
				}
			}
		}
	}
	_gbde := 0.0
	for _aeca, _aeeb := range _ebagd {
		_gbde += _aeeb / _gfc.Pow(1+_ecdc, float64(_aeca)+1)
	}
	return MakeNumberResult(_gbde)
}

type cmpResult int8

const _gfce = 57369
const _afeb = "\u005e\u0028\u0028" + _dge + "\u007c" + _dga + "\u007c" + _edec + "\u007c" + _dba + "\u0029\u0020\u0029\u003f"

// Negate is a negate expression like -A1.
type Negate struct{ _gdda Expression }

// NamedRangeRef is a reference to a named range.
type NamedRangeRef struct{ _cgag string }

func _dgdfc(_fcce, _ced, _cbaa, _baggc, _bdfa float64, _gfed int) float64 {
	_bfaab := _cbf(_fcce, _cbaa, _baggc, _bdfa, _gfed)
	var _aafc float64
	if _ced == 1 {
		if _gfed == 1 {
			_aafc = 0
		} else {
			_aafc = -_baggc
		}
	} else {
		if _gfed == 1 {
			_aafc = _cdac(_fcce, _ced-2, _bfaab, _baggc, 1) - _bfaab
		} else {
			_aafc = _cdac(_fcce, _ced-1, _bfaab, _baggc, 0)
		}
	}
	return _aafc * _fcce
}
func (_baeae node) String() string {
	return _c.Sprintf("\u007b%\u0073\u0020\u0025\u0073\u007d", _baeae._cgbd, _adcb(string(_baeae._cedb)))
}

// CountIf implements the COUNTIF function.
func CountIf(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0043\u004f\u0055N\u0054\u0049\u0046\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0073")
	}
	_dbfcf := args[0]
	if _dbfcf.Type != ResultTypeArray && _dbfcf.Type != ResultTypeList {
		return MakeErrorResult("\u0043O\u0055\u004eT\u0049\u0046\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0066\u0069\u0072\u0073\u0074\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020t\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_eedde := _affeg(args[1])
	_dcafc := 0
	for _, _cfgcb := range _bbcd(_dbfcf) {
		for _, _ffgaa := range _cfgcb {
			if _cead(_ffgaa, _eedde) {
				_dcafc++
			}
		}
	}
	return MakeNumberResult(float64(_dcafc))
}

const _cbecc = 1

// Clean is an implementation of the Excel CLEAN function that removes
// unprintable characters.
func Clean(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u004c\u0045\u0041\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gfgce := args[0].AsString()
	if _gfgce.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0073t\u0072\u0069\u006e\u0067\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dadf := _gb.Buffer{}
	for _, _dacb := range _gfgce.ValueString {
		if _ea.IsPrint(_dacb) {
			_dadf.WriteRune(_dacb)
		}
	}
	return MakeStringResult(_dadf.String())
}

// GetLocked returns FALSE for the invalid reference context.
func (_feaee *ivr) GetLocked(cellRef string) bool { return false }
func _defa(_eggeb Result, _efgfc *criteriaParsed) bool {
	_bebe := _gg.ToLower(_eggeb.ValueString)
	_gfgb := _efgfc._edgc._cadca
	_geacb := _efgfc._edgc._acdd
	if _gfgb == _fdff {
		return _bebe == _geacb || _ce.Match(_geacb, _bebe)
	}
	if _eggeb.Type != ResultTypeEmpty {
		if _bebe == _efgfc._ecef || _ce.Match(_efgfc._ecef, _bebe) {
			return true
		}
		if _, _gdfbc := _ff.ParseFloat(_geacb, 64); _gdfbc == nil {
			return false
		}
		switch _gfgb {
		case _cegbg:
			return _bebe <= _geacb
		case _deeb:
			return _bebe >= _geacb
		case _fgabb:
			return _bebe < _geacb
		case _bbfg:
			return _bebe > _geacb
		}
	}
	return false
}

// Pricedisc implements the Excel PRICEDISC function.
func Pricedisc(args []Result) Result {
	_edgg := len(args)
	if _edgg != 4 && _edgg != 5 {
		return MakeErrorResult("\u0050\u0052\u0049\u0043\u0045D\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_eaeb, _dbca, _bgae := _geae(args[0], args[1], "\u0050R\u0049\u0043\u0045\u0044\u0049\u0053C")
	if _bgae.Type == ResultTypeError {
		return _bgae
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0052\u0049C\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bdfg := args[2].ValueNumber
	if _bdfg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0052\u0049C\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0069\u0073\u0063\u006f\u0075\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_cdaccd := args[3].ValueNumber
	if _cdaccd <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006fs\u0069\u0074i\u0076\u0065")
	}
	_afcd := 0
	if _edgg == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0052I\u0043\u0045\u0044\u0049\u0053\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_afcd = int(args[4].ValueNumber)
		if !_dfeg(_afcd) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0062\u0061\u0073\u0069\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0066\u006f\u0072\u0020\u0050R\u0049\u0043E\u0044\u0049\u0053\u0043")
		}
	}
	_aefb, _bgae := _fbabb(_eaeb, _dbca, _afcd)
	if _bgae.Type == ResultTypeError {
		return _bgae
	}
	return MakeNumberResult(_cdaccd * (1 - _bdfg*_aefb))
}

// Eval evaluates and returns a number.
func (_ecebf Number) Eval(ctx Context, ev Evaluator) Result { return MakeNumberResult(_ecebf._dddg) }
func _bbfa(_deede string, _cdb _d.Time) (_d.Time, error) {
	_ecbc, _, _aae := _cf.ParseFloat(_deede, 10, 128, _cf.ToNearestEven)
	if _aae != nil {
		return _d.Time{}, _aae
	}
	_ggbaa := new(_cf.Float)
	_ggbaa.SetUint64(uint64(24 * _d.Hour))
	_ecbc.Mul(_ecbc, _ggbaa)
	_cagg, _ := _ecbc.Uint64()
	_efag := _cdb.Add(_d.Duration(_cagg))
	return _dggff(_efag), nil
}
func _adcgg(_gdaf Result, _cbfec, _baaca string) (string, Result) {
	switch _gdaf.Type {
	case ResultTypeString, ResultTypeNumber, ResultTypeEmpty:
		return _gdaf.Value(), _gaef
	default:
		return "", MakeErrorResult(_cbfec + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020" + _baaca + "\u0020t\u006f\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006db\u0065r\u0020o\u0072\u0020\u0073\u0074\u0072\u0069\u006eg")
	}
}

var _bfgfa = map[string]Function{}

// String returns a string representation of a named range.
func (_bffdb NamedRangeRef) String() string { return _bffdb._cgag }

// Rand is an implementation of the Excel RAND() function that returns random
// numbers in the range [0,1).
func Rand(args []Result) Result {
	if len(args) != 0 {
		return MakeErrorResult("R\u0041\u004e\u0044\u0028\u0029\u0020a\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006e\u006f \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	return MakeNumberResult(_fbbf.Float64())
}

type rangeIndex struct {
	_gefg  int
	_facdg int
}

// Reference returns a string reference value to an expression with prefix.
func (_bgfge PrefixExpr) Reference(ctx Context, ev Evaluator) Reference {
	_eege := _bgfge._dcfga.Reference(ctx, ev)
	_baee := _bgfge._bcbe.Reference(ctx, ev)
	if _eege.Type == ReferenceTypeSheet && _baee.Type == ReferenceTypeCell {
		return Reference{Type: ReferenceTypeCell, Value: _eege.Value + "\u0021" + _baee.Value}
	}
	return ReferenceInvalid
}

// Len is an implementation of the Excel LEN function that returns length of a string
func Len(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004c\u0045N\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_dffcg := args[0].AsString()
	if _dffcg.Type != ResultTypeString {
		return MakeErrorResult("\u004c\u0045N\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeNumberResult(float64(len(_dffcg.ValueString)))
}
func _cbg(_be BinOpType, _bd, _gbd []Result) Result {
	_cbb := []Result{}
	for _dcb := range _bd {
		_cg := _bd[_dcb].AsNumber()
		_da := _gbd[_dcb].AsNumber()
		if _cg.Type != ResultTypeNumber || _da.Type != ResultTypeNumber {
			return MakeErrorResult("\u006e\u006f\u006e\u002d\u006e\u0075\u006e\u006d\u0065\u0072\u0069\u0063\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0069\u006e\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006fp\u0065\u0072a\u0074\u0069\u006f\u006e")
		}
		switch _be {
		case BinOpTypePlus:
			_cbb = append(_cbb, MakeNumberResult(_cg.ValueNumber+_da.ValueNumber))
		case BinOpTypeMinus:
			_cbb = append(_cbb, MakeNumberResult(_cg.ValueNumber-_da.ValueNumber))
		case BinOpTypeMult:
			_cbb = append(_cbb, MakeNumberResult(_cg.ValueNumber*_da.ValueNumber))
		case BinOpTypeDiv:
			if _da.ValueNumber == 0 {
				return MakeErrorResultType(ErrorTypeDivideByZero, "")
			}
			_cbb = append(_cbb, MakeNumberResult(_cg.ValueNumber/_da.ValueNumber))
		case BinOpTypeExp:
			_cbb = append(_cbb, MakeNumberResult(_gfc.Pow(_cg.ValueNumber, _da.ValueNumber)))
		case BinOpTypeLT:
			_cbb = append(_cbb, MakeBoolResult(_cg.ValueNumber < _da.ValueNumber))
		case BinOpTypeGT:
			_cbb = append(_cbb, MakeBoolResult(_cg.ValueNumber > _da.ValueNumber))
		case BinOpTypeEQ:
			_cbb = append(_cbb, MakeBoolResult(_cg.ValueNumber == _da.ValueNumber))
		case BinOpTypeLEQ:
			_cbb = append(_cbb, MakeBoolResult(_cg.ValueNumber <= _da.ValueNumber))
		case BinOpTypeGEQ:
			_cbb = append(_cbb, MakeBoolResult(_cg.ValueNumber >= _da.ValueNumber))
		case BinOpTypeNE:
			_cbb = append(_cbb, MakeBoolResult(_cg.ValueNumber != _da.ValueNumber))
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006c\u0069\u0073\u0074\u0020\u0062\u0069\u006e\u0061\u0072\u0079\u0020\u006fp \u0025\u0073", _be))
		}
	}
	return MakeListResult(_cbb)
}
func _afa(_cefgd, _caab _d.Time, _eeeef, _fgfd int) _d.Time {
	_cadc := _caab
	_abcb := _cefgd.Year() - _caab.Year()
	_cadc = _cadc.AddDate(_abcb, 0, 0)
	if _cefgd.After(_cadc) {
		_cadc = _cadc.AddDate(1, 0, 0)
	}
	_ebg := -12 / _eeeef
	for _cadc.After(_cefgd) {
		_cadc = _cadc.AddDate(0, _ebg, 0)
	}
	return _cadc
}

// LookupFunctionComplex looks up and returns a complex function or nil.
func LookupFunctionComplex(name string) FunctionComplex {
	_eadgg.Lock()
	defer _eadgg.Unlock()
	if _dbebbe, _bbag := _ecdeb[name]; _bbag {
		return _dbebbe
	}
	return nil
}

// Eval evaluates and returns a string.
func (_egfa String) Eval(ctx Context, ev Evaluator) Result { return MakeStringResult(_egfa._geef) }

// SumSquares is an implementation of the Excel SUMSQ() function.
func SumSquares(args []Result) Result {
	_dfce := MakeNumberResult(0)
	for _, _fbfc := range args {
		_fbfc = _fbfc.AsNumber()
		switch _fbfc.Type {
		case ResultTypeNumber:
			_dfce.ValueNumber += _fbfc.ValueNumber * _fbfc.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_gdead := SumSquares(_fbfc.ListValues())
			if _gdead.Type != ResultTypeNumber {
				return _gdead
			}
			_dfce.ValueNumber += _gdead.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _fbfc
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0053\u0055\u004dS\u0051\u0055\u0041\u0052\u0045\u0053(\u0029\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079p\u0065\u0020\u0025\u0073", _fbfc.Type))
		}
	}
	return _dfce
}

// Update makes a reference to point to one of the neighboring cells after removing a row/column with respect to the update type.
func (_fea CellRef) Update(q *_de.UpdateQuery) Expression {
	if q.UpdateCurrentSheet {
		_fea._acb = _bgb(_fea._acb, q)
	}
	return _fea
}

const _cdeb = "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0044\u0041\u0054\u0045\u0056\u0041\u004c\u0055\u0045"

func _affeg(_ggad Result) *criteriaParsed {
	_gcfb := _ggad.Type == ResultTypeNumber
	_accf := _ggad.ValueNumber
	_ccebf := _gg.ToLower(_ggad.ValueString)
	_bgee := _eabacg(_ccebf)
	return &criteriaParsed{_gcfb, _accf, _ccebf, _bgee}
}

// Date is an implementation of the Excel DATE() function.
func Date(args []Result) Result {
	if len(args) != 3 || args[0].Type != ResultTypeNumber || args[1].Type != ResultTypeNumber || args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0041TE\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0068re\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_cde := int(args[0].ValueNumber)
	if _cde < 0 || _cde >= 10000 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074 \u0064\u0061\u0074\u0065")
	} else if _cde <= 1899 {
		_cde += 1900
	}
	_ggb := _d.Month(args[1].ValueNumber)
	_deeg := int(args[2].ValueNumber)
	_ffa := _fca(_cde, _ggb, _deeg)
	_fgf := _fccg(_eec, _ffa) + 1
	if _fgf < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074 \u0064\u0061\u0074\u0065")
	}
	return MakeNumberResult(_fgf)
}

var _dged = [...]int{0, 7, 3, 3, 3, 8, 8, 8, 8, 1, 1, 1, 2, 2, 2, 2, 2, 14, 15, 15, 17, 17, 4, 4, 4, 13, 5, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 9, 9, 9, 16, 16, 11, 10, 10}

func _dead(_fedg Result) Result {
	if _fedg.Type == ResultTypeEmpty {
		return _fedg
	}
	_adcgc := _fedg.AsString()
	if _adcgc.Type != ResultTypeString {
		return MakeErrorResult("\u004c\u004f\u0057\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0061\u0020\u0073\u0069\u006eg\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	if _fedg.IsBoolean {
		if _adcgc.ValueString == "\u0031" {
			return MakeStringResult("\u0074\u0072\u0075\u0065")
		} else if _adcgc.ValueString == "\u0030" {
			return MakeStringResult("\u0066\u0061\u006cs\u0065")
		} else {
			return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u004c\u004fW\u0045\u0052")
		}
	} else {
		return MakeStringResult(_gg.ToLower(_adcgc.ValueString))
	}
}

// FunctionComplex is a function whose result  depends on its arguments and the
// context that it's in.  As an example, INDIRECT is a complex function so that
// INDIRECT("A1") which returns the value of the "A1" cell in a sheet can use
// the context to reach into the sheet and pull out required values.
type FunctionComplex func(_bgfeb Context, _cdde Evaluator, _ebcc []Result) Result

// Eval evaluates a vertical range with prefix returning a list of results or an error.
func (_eaeac PrefixVerticalRange) Eval(ctx Context, ev Evaluator) Result {
	_cdbd := _eaeac._ggdbe.Reference(ctx, ev)
	switch _cdbd.Type {
	case ReferenceTypeSheet:
		if _fggd(_cdbd, ctx) {
			return MakeErrorResultType(ErrorTypeName, _c.Sprintf("\u0053h\u0065e\u0074\u0020\u0025\u0073\u0020n\u006f\u0074 \u0066\u006f\u0075\u006e\u0064", _cdbd.Value))
		}
		_cgfd := _eaeac.verticalRangeReference(_cdbd.Value)
		if _ffgcc, _bfcd := ev.GetFromCache(_cgfd); _bfcd {
			return _ffgcc
		}
		_edef := ctx.Sheet(_cdbd.Value)
		_bffc, _gcfeg := _gffe(_edef, _eaeac._cagbb, _eaeac._baae)
		_cbgbd := _efagg(_edef, ev, _bffc, _gcfeg)
		ev.SetCache(_cgfd, _cbgbd)
		return _cbgbd
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cdbd.Type))
	}
}

var _gebe = []ri{{1000, "\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {95, "\u0056\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// String returns a string representation of a horizontal range with prefix.
func (_ffada PrefixHorizontalRange) String() string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0064\u003a\u0025\u0064", _ffada._bbff.String(), _ffada._abbf, _ffada._fdcc)
}
func _gbdef(_abebf, _dafaf int) string {
	const TOKSTART = 4
	if !_befg {
		return "\u0073\u0079\u006et\u0061\u0078\u0020\u0065\u0072\u0072\u006f\u0072"
	}
	for _, _eedce := range _fdgg {
		if _eedce._gfbeg == _abebf && _eedce._ecfad == _dafaf {
			return "\u0073\u0079\u006e\u0074\u0061\u0078\u0020\u0065\u0072r\u006f\u0072\u003a\u0020" + _eedce._eaeaf
		}
	}
	_agac := "\u0073y\u006e\u0074\u0061\u0078 \u0065\u0072\u0072\u006f\u0072:\u0020u\u006ee\u0078\u0070\u0065\u0063\u0074\u0065\u0064 " + _addea(_dafaf)
	_caed := make([]int, 0, 4)
	_fddc := _fdaae[_abebf]
	for _acbb := TOKSTART; _acbb-1 < len(_acad); _acbb++ {
		if _bggad := _fddc + _acbb; _bggad >= 0 && _bggad < _ccbbb && _becg[_gabbg[_bggad]] == _acbb {
			if len(_caed) == cap(_caed) {
				return _agac
			}
			_caed = append(_caed, _acbb)
		}
	}
	if _eggg[_abebf] == -2 {
		_cgefg := 0
		for _bcfbd[_cgefg] != -1 || _bcfbd[_cgefg+1] != _abebf {
			_cgefg += 2
		}
		for _cgefg += 2; _bcfbd[_cgefg] >= 0; _cgefg += 2 {
			_eefd := _bcfbd[_cgefg]
			if _eefd < TOKSTART || _bcfbd[_cgefg+1] == 0 {
				continue
			}
			if len(_caed) == cap(_caed) {
				return _agac
			}
			_caed = append(_caed, _eefd)
		}
		if _bcfbd[_cgefg+1] != 0 {
			return _agac
		}
	}
	for _cbgg, _egggg := range _caed {
		if _cbgg == 0 {
			_agac += "\u002c\u0020\u0065x\u0070\u0065\u0063\u0074\u0069\u006e\u0067\u0020"
		} else {
			_agac += "\u0020\u006f\u0072\u0020"
		}
		_agac += _addea(_egggg)
	}
	return _agac
}

// Context is a formula execution context.  Formula evaluation uses the context
// to retreive information from sheets.
type Context interface {

	// Cell returns the result of evaluating a cell.
	Cell(_cfb string, _faf Evaluator) Result

	// Sheet returns an evaluation context for a given sheet name.  This is used
	// when evaluating cells that pull data from other sheets (e.g. ='Sheet 2'!A1).
	Sheet(_fab string) Context

	// GetEpoch returns the time epoch of the context's Workbook.
	GetEpoch() _d.Time

	// GetFilename returns the full filename of the context's Workbook.
	GetFilename() string

	// GetWidth returns a worksheet's column width.
	GetWidth(_edd int) float64

	// GetFormat returns a cell's format.
	GetFormat(_ccb string) string

	// GetLabelPrefix returns cell's label prefix dependent on cell horizontal alignment.
	GetLabelPrefix(_gaeb string) string

	// GetFormat returns if cell is protected.
	GetLocked(_eag string) bool

	// HasFormula returns if cell contains formula.
	HasFormula(_beb string) bool

	// IsBool returns if cell contains boolean value.
	IsBool(_gfe string) bool

	// IsDBCS returns if workbook default language is among DBCS.
	IsDBCS() bool

	// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
	LastColumn(_dbd, _bdb int) string

	// LastRow returns the name of last row which contains data in range of context sheet's given columns.
	LastRow(_abeb string) int

	// SetLocked returns sets cell's protected attribute.
	SetLocked(_efb string, _gbg bool)

	// NamedRange returns a named range.
	NamedRange(_cfg string) Reference

	// SetOffset is used so that the Context can evaluate cell references
	// differently when they are not absolute (e.g. not like '$A$5').  See the
	// shared formula support in Cell for usage.
	SetOffset(_ffd, _deb uint32)
}

const _dga = _dfb + "\u0020\u0028\u0028[0\u002d\u0039\u005d\u0029\u002b\u0029\u002c\u0020\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

func _cgc(_daegg, _dca, _accc, _cbaae, _ggfda, _efde float64) float64 {
	var _dbbce, _aeaf float64
	_afga := 0.0
	_efgef := _gfc.Ceil(_ggfda)
	_cggf := _daegg - _dca
	_aagbc := false
	_cfgdb := 0.0
	for _dcdd := 1.0; _dcdd <= _efgef; _dcdd++ {
		if !_aagbc {
			_dbbce = _gbf(_daegg, _dca, _accc, _dcdd, _efde)
			_cfgdb = _cggf / (_accc - _dcdd + 1)
			if _cfgdb > _dbbce {
				_aeaf = _cfgdb
				_aagbc = true
			} else {
				_aeaf = _dbbce
				_cggf -= _dbbce
			}
		} else {
			_aeaf = _cfgdb
		}
		if _dcdd == _efgef {
			_aeaf *= _ggfda + 1 - _efgef
		}
		_afga += _aeaf
	}
	return _afga
}

// Eval evaluates a range returning a list of results or an error.
func (_aagd Range) Eval(ctx Context, ev Evaluator) Result {
	_bcae := _aagd._efbed.Reference(ctx, ev)
	_cbeae := _aagd._abfd.Reference(ctx, ev)
	_efbfb := _ffdga(_bcae, _cbeae)
	if _bcae.Type == ReferenceTypeCell && _cbeae.Type == ReferenceTypeCell {
		if _edbcf, _gccbd := ev.GetFromCache(_efbfb); _gccbd {
			return _edbcf
		} else {
			_fcgd := _efagg(ctx, ev, _bcae.Value, _cbeae.Value)
			ev.SetCache(_efbfb, _fcgd)
			return _fcgd
		}
	}
	return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072a\u006e\u0067\u0065\u0020" + _efbfb)
}
func _bdfc(_ebge []Result, _gdcde bool) (float64, float64) {
	_ecdf := 0.0
	_dbgcg := 0.0
	for _, _eaedc := range _ebge {
		switch _eaedc.Type {
		case ResultTypeNumber:
			if _gdcde || !_eaedc.IsBoolean {
				_dbgcg += _eaedc.ValueNumber
				_ecdf++
			}
		case ResultTypeList, ResultTypeArray:
			_eeeaa, _gfgge := _bdfc(_eaedc.ListValues(), _gdcde)
			_dbgcg += _eeeaa
			_ecdf += _gfgge
		case ResultTypeString:
			if _gdcde {
				_ecdf++
			}
		case ResultTypeEmpty:
		}
	}
	return _dbgcg, _ecdf
}

// VLookup implements the VLOOKUP function that returns a matching value from a
// column in an array.
func VLookup(args []Result) Result {
	_adadc := len(args)
	if _adadc < 3 {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004bU\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _adadc > 4 {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0074\u0020m\u006f\u0073\u0074\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_bfac := args[0]
	_dfba := args[1]
	if _dfba.Type != ResultTypeArray {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_cbgc := args[2].AsNumber()
	if _cbgc.Type != ResultTypeNumber {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050 \u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0063\u006f\u006c\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gbeb := false
	if _adadc == 4 && args[3].Type != ResultTypeEmpty {
		_gdf := args[3].AsNumber()
		if _gdf.Type != ResultTypeNumber {
			return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		if _gdf.ValueNumber == 0 {
			_gbeb = true
		}
	}
	_eaagd := int(_cbgc.ValueNumber) - 1
	_dgeaf := -1
	_cdgd := false
_dega:
	for _daee, _ebga := range _dfba.ValueArray {
		if len(_ebga) == 0 {
			continue
		}
		_cgea := _ebga[0]
		switch _faff(_cgea, _bfac, false, _gbeb) {
		case _fcga:
			_dgeaf = _daee
		case _effe:
			_dgeaf = _daee
			_cdgd = true
			break _dega
		}
	}
	if _dgeaf == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_dcbfd := _dfba.ValueArray[_dgeaf]
	if _eaagd < 0 || _eaagd >= len(_dcbfd) {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0063\u006f\u006c\u0075\u006d\u006e\u0020\u0069\u006e\u0064\u0065\u0078")
	}
	if _cdgd || !_gbeb {
		return _dcbfd[_eaagd]
	}
	return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
}

// IsLogical is an implementation of the Excel ISLOGICAL() function.
func IsLogical(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004c\u004f\u0047\u0049\u0043A\u004c\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fgab := args[0].Ref
	if _fgab.Type != ReferenceTypeCell {
		return MakeErrorResult("I\u0053\u004c\u004f\u0047\u0049\u0043\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072\u0067\u0075\u006de\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
	}
	return MakeBoolResult(ctx.Cell(_fgab.Value, ev).IsBoolean)
}
func _fca(_cda int, _cgd _d.Month, _ceab int) int64 {
	if _cda == 1900 && int(_cgd) <= 2 {
		_ceab--
	}
	_dfcc := _d.Date(_cda, _cgd, _ceab, 0, 0, 0, 0, _d.UTC)
	return _dfcc.Unix()
}

// ISERR is an implementation of the Excel ISERR() function.
func IsErr(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u0045\u0052\u0052\u0028)\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError && args[0].ValueString != "\u0023\u004e\u002f\u0041")
}

// ListValues converts an array to a list or returns a lists values. This is used
// for functions that can accept an array, but don't care about ordering to
// reuse the list function logic.
func (_baggca Result) ListValues() []Result {
	if _baggca.Type == ResultTypeArray {
		_aaggba := []Result{}
		for _, _dgbae := range _baggca.ValueArray {
			for _, _abaff := range _dgbae {
				_aaggba = append(_aaggba, _abaff)
			}
		}
		return _aaggba
	}
	if _baggca.Type == ResultTypeList {
		return _baggca.ValueList
	}
	return nil
}

const _eebc = 57357

// Edate is an implementation of the Excel EDATE() function.
func Edate(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u0044\u0041\u0054E\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020t\u0077o\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	_feaa := args[1].ValueNumber
	_gcf := args[0]
	var _dfec float64
	switch _gcf.Type {
	case ResultTypeEmpty:
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	case ResultTypeNumber:
		_dfec = _gcf.ValueNumber
	case ResultTypeString:
		_bac := DateValue([]Result{args[0]})
		if _bac.Type == ResultTypeError {
			return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
		}
		_dfec = _bac.ValueNumber
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	_dfg := _eeec(_dfec)
	_aef := _dfg.AddDate(0, int(_feaa), 0)
	_egd, _efcc, _dggf := _aef.Date()
	_cga := _gfea(_egd, int(_efcc), _dggf)
	if _cga < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063\u006fr\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006de\u006et\u0020\u0066\u006f\u0072\u0020\u0045\u0044A\u0054\u0045")
	}
	return MakeNumberResult(_cga)
}

// Reference returns a string reference value to a named range.
func (_eeef NamedRangeRef) Reference(ctx Context, ev Evaluator) Reference {
	return Reference{Type: ReferenceTypeNamedRange, Value: _eeef._cgag}
}

var _acad = [...]string{"\u0024\u0065\u006e\u0064", "\u0065\u0072\u0072o\u0072", "\u0024\u0075\u006e\u006b", "t\u006fk\u0065\u006e\u0048\u006f\u0072\u0069\u007a\u006fn\u0074\u0061\u006c\u0052an\u0067\u0065", "\u0074o\u006be\u006e\u0056\u0065\u0072\u0074i\u0063\u0061l\u0052\u0061\u006e\u0067\u0065", "\u0074\u006f\u006b\u0065\u006e\u0052\u0065\u0073\u0065\u0072\u0076\u0065d\u004e\u0061\u006d\u0065", "\u0074\u006f\u006be\u006e\u0044\u0044\u0045\u0043\u0061\u006c\u006c", "\u0074\u006f\u006b\u0065\u006e\u004c\u0065\u0078\u0045\u0072\u0072\u006f\u0072", "\u0074o\u006be\u006e\u004e\u0061\u006d\u0065\u0064\u0052\u0061\u006e\u0067\u0065", "\u0074o\u006b\u0065\u006e\u0042\u006f\u006fl", "t\u006f\u006b\u0065\u006e\u004e\u0075\u006d\u0062\u0065\u0072", "t\u006f\u006b\u0065\u006e\u0053\u0074\u0072\u0069\u006e\u0067", "\u0074\u006f\u006b\u0065\u006e\u0045\u0072\u0072\u006f\u0072", "\u0074\u006f\u006b\u0065\u006e\u0045\u0072\u0072\u006f\u0072\u0052\u0065\u0066", "\u0074\u006f\u006b\u0065\u006e\u0053\u0068\u0065\u0065\u0074", "\u0074o\u006b\u0065\u006e\u0043\u0065\u006cl", "t\u006fk\u0065\u006e\u0046\u0075\u006e\u0063\u0074\u0069o\u006e\u0042\u0075\u0069lt\u0069\u006e", "t\u006f\u006b\u0065\u006e\u004c\u0042\u0072\u0061\u0063\u0065", "t\u006f\u006b\u0065\u006e\u0052\u0042\u0072\u0061\u0063\u0065", "t\u006f\u006b\u0065\u006e\u004c\u0050\u0061\u0072\u0065\u006e", "t\u006f\u006b\u0065\u006e\u0052\u0050\u0061\u0072\u0065\u006e", "\u0074o\u006b\u0065\u006e\u0050\u006c\u0075s", "\u0074\u006f\u006b\u0065\u006e\u004d\u0069\u006e\u0075\u0073", "\u0074o\u006b\u0065\u006e\u004d\u0075\u006ct", "\u0074\u006f\u006b\u0065\u006e\u0044\u0069\u0076", "\u0074\u006f\u006b\u0065\u006e\u0045\u0078\u0070", "\u0074o\u006b\u0065\u006e\u0045\u0051", "\u0074o\u006b\u0065\u006e\u004c\u0054", "\u0074o\u006b\u0065\u006e\u0047\u0054", "\u0074\u006f\u006b\u0065\u006e\u004c\u0045\u0051", "\u0074\u006f\u006b\u0065\u006e\u0047\u0045\u0051", "\u0074o\u006b\u0065\u006e\u004e\u0045", "\u0074\u006f\u006b\u0065\u006e\u0043\u006f\u006c\u006f\u006e", "\u0074\u006f\u006b\u0065\u006e\u0043\u006f\u006d\u006d\u0061", "\u0074\u006f\u006b\u0065\u006e\u0041\u006d\u0070\u0065r\u0073\u0061\u006e\u0064", "\u0074o\u006b\u0065\u006e\u0053\u0065\u006di"}

// Reference returns an invalid reference for String.
func (_cgebb String) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

type countMode byte

// FunctionCall is a function call expression.
type FunctionCall struct {
	_bbfgf string
	_ebbe  []Expression
}

// Update updates references in the PrefixVerticalRange after removing a row/column.
func (_gdgba PrefixVerticalRange) Update(q *_de.UpdateQuery) Expression {
	if q.UpdateType == _de.UpdateActionRemoveColumn {
		_dedg := _gdgba
		_ecccd := _gdgba._ggdbe.String()
		if _ecccd == q.SheetToUpdate {
			_fgafe := q.ColumnIdx
			_dedg._cagbb = _gca(_gdgba._cagbb, _fgafe)
			_dedg._baae = _gca(_gdgba._baae, _fgafe)
		}
		return _dedg
	}
	return _gdgba
}

// SeriesSum implements the Excel SERIESSUM function.
func SeriesSum(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("\u0053\u0045\u0052\u0049\u0045\u0053\u0053\u0055\u004d\u0028\u0029\u0020\u0072\u0065\u0071u\u0069r\u0065\u0073\u0020\u0034\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dfad := args[0].AsNumber()
	_bbbfb := args[1].AsNumber()
	_acccg := args[2].AsNumber()
	_bdgcf := args[3].ListValues()
	if _dfad.Type != ResultTypeNumber || _bbbfb.Type != ResultTypeNumber || _acccg.Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0045\u0052\u0049\u0045\u0053S\u0055\u004d\u0028)\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073t\u0020\u0074\u0068\u0072\u0065e \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063")
	}
	_dcaac := float64(0)
	for _fedf, _fedba := range _bdgcf {
		_dcaac += _fedba.ValueNumber * _gfc.Pow(_dfad.ValueNumber, _bbbfb.ValueNumber+float64(_fedf)*_acccg.ValueNumber)
	}
	return MakeNumberResult(_dcaac)
}

// Search is an implementation of the Excel SEARCH().
func Search(args []Result) Result {
	_aebd, _ecfa := _bege("\u0046\u0049\u004e\u0044", args)
	if _ecfa.Type != ResultTypeEmpty {
		return _ecfa
	}
	_cccc := _gg.ToLower(_aebd._ebda)
	if _cccc == "" {
		return MakeNumberResult(1.0)
	}
	_cbfg := _gg.ToLower(_aebd._effb)
	_defac := _aebd._cbec
	_eagcf := 1
	for _dcfe := range _cbfg {
		if _eagcf < _defac {
			_eagcf++
			continue
		}
		_defdg := _ce.Index(_cccc, _cbfg[_dcfe:])
		if _defdg == 0 {
			return MakeNumberResult(float64(_eagcf))
		}
		_eagcf++
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

const _cca = "\u0028\u0020\u0028" + _ace + "\u007c" + _eae + "\u007c" + _dgea + "\u007c" + _bcfd + "\u0029\u0029\u003f\u0024"
const _dge = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u002f\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u002f\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029"

// Counta implements the COUNTA function.
func Counta(args []Result) Result { return MakeNumberResult(_aggc(args, _dfgf)) }
func _fggd(_eggcg Reference, _addeg Context) bool {
	return _addeg.Sheet(_eggcg.Value) == InvalidReferenceContext
}

// TimeValue is an implementation of the Excel TIMEVALUE() function.
func TimeValue(args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0054I\u004d\u0045V\u0041\u004c\u0055\u0045 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069ng\u006c\u0065\u0020s\u0074\u0072i\u006e\u0067\u0020\u0061\u0072\u0067u\u006d\u0065n\u0074\u0073")
	}
	_eacd := _gg.ToLower(args[0].ValueString)
	if !_gfb(_eacd) {
		_, _, _, _fcff, _bag := _agda(_eacd)
		if _bag.Type == ResultTypeError {
			_bag.ErrorMessage = "\u0049\u006e\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020f\u006f\u0072\u0020\u0054\u0049\u004d\u0045V\u0041\u004c\u0055\u0045"
			return _bag
		}
		if _fcff {
			return MakeNumberResult(0)
		}
	}
	_gfdcb, _gdg, _ddb, _bee, _, _gec := _cefg(_eacd)
	if _gec.Type == ResultTypeError {
		return _gec
	}
	_bgbaf := _acc(float64(_gfdcb), float64(_gdg), _ddb)
	if _bee {
		_bgbaf += 0.5
	} else if _bgbaf >= 1 {
		_bgbaf -= float64(int(_bgbaf))
	}
	return MakeNumberResult(_bgbaf)
}

const _aead = 57365

// Match implements the MATCH function.
func Match(args []Result) Result {
	_aacf := len(args)
	if _aacf != 2 && _aacf != 3 {
		return MakeErrorResult("\u004d\u0041T\u0043\u0048\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020o\u0072\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_affe := 1
	if _aacf == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065q\u0075\u0069\u0072es\u0020\u0074\u0068\u0065\u0020\u0074h\u0069\u0072\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006db\u0065\u0072")
		}
		_cgeb := args[2].ValueNumber
		if _cgeb == -1 || _cgeb == 0 {
			_affe = int(_cgeb)
		}
	}
	_fafbe := args[1]
	var _bgeb []Result
	switch _fafbe.Type {
	case ResultTypeList:
		_bgeb = _fafbe.ValueList
	case ResultTypeArray:
		_agdefgb := _fafbe.ValueArray
		for _, _feea := range _agdefgb {
			if len(_feea) != 1 {
				return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068e\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006f\u006e\u0065\u002dd\u0069\u006d\u0065\u006e\u0073\u0069o\u006e\u0061l\u0020\u0072a\u006eg\u0065")
			}
			_bgeb = append(_bgeb, _feea[0])
		}
	default:
		return MakeErrorResult("\u004d\u0041\u0054\u0043\u0048\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068e\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006f\u006e\u0065\u002dd\u0069\u006d\u0065\u006e\u0073\u0069o\u006e\u0061l\u0020\u0072a\u006eg\u0065")
	}
	_eaag := _affeg(args[0])
	switch _affe {
	case 0:
		for _eegg, _efbd := range _bgeb {
			if _gdggf(_efbd, _eaag) {
				return MakeNumberResult(float64(_eegg + 1))
			}
		}
	case -1:
		for _ccff := 0; _ccff < len(_bgeb); _ccff++ {
			if _gdggf(_bgeb[_ccff], _eaag) {
				return MakeNumberResult(float64(_ccff + 1))
			}
			if _eaag._dbde && (_bgeb[_ccff].ValueNumber < _eaag._bgfgb) {
				if _ccff == 0 {
					return MakeErrorResultType(ErrorTypeNA, "")
				}
				return MakeNumberResult(float64(_ccff))
			}
		}
	case 1:
		for _gdba := 0; _gdba < len(_bgeb); _gdba++ {
			if _gdggf(_bgeb[_gdba], _eaag) {
				return MakeNumberResult(float64(_gdba + 1))
			}
			if _eaag._dbde && (_bgeb[_gdba].ValueNumber > _eaag._bgfgb) {
				if _gdba == 0 {
					return MakeErrorResultType(ErrorTypeNA, "")
				}
				return MakeNumberResult(float64(_gdba))
			}
		}
	}
	return MakeErrorResultType(ErrorTypeNA, "")
}

const _gbca = 57353

// Sum is an implementation of the Excel SUM() function.
func Sum(args []Result) Result {
	_dcaacd := MakeNumberResult(0)
	for _, _cbefc := range args {
		_cbefc = _cbefc.AsNumber()
		switch _cbefc.Type {
		case ResultTypeNumber:
			_dcaacd.ValueNumber += _cbefc.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_cgebc := Sum(_cbefc.ListValues())
			if _cgebc.Type != ResultTypeNumber {
				return _cgebc
			}
			_dcaacd.ValueNumber += _cgebc.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _cbefc
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068\u0061\u006e\u0064\u006c\u0065\u0064\u0020\u0053\u0055\u004d\u0028\u0029 \u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _cbefc.Type))
		}
	}
	return _dcaacd
}

type node struct {
	_cgbd tokenType
	_cedb string
}

const (
	ResultTypeUnknown ResultType = iota
	ResultTypeNumber
	ResultTypeString
	ResultTypeList
	ResultTypeArray
	ResultTypeError
	ResultTypeEmpty
)

// MaxA is an implementation of the Excel MAXA() function.
func MaxA(args []Result) Result { return _gdfd(args, true) }

// LCM implements the Excel LCM() function which returns the least common
// multiple of a range of numbers.
func LCM(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u004c\u0043M(\u0029\u0020\u0072e\u0071\u0075\u0069\u0072es \u0061t \u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_afed := []float64{}
	for _, _cggd := range args {
		switch _cggd.Type {
		case ResultTypeString:
			_cbbfd := _cggd.AsNumber()
			if _cbbfd.Type != ResultTypeNumber {
				return MakeErrorResult("\u004c\u0043M(\u0029\u0020\u006fn\u006c\u0079\u0020\u0061cce\u0070ts\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
			}
			_afed = append(_afed, _cbbfd.ValueNumber)
		case ResultTypeList:
			_dgbd := LCM(_cggd.ValueList)
			if _dgbd.Type != ResultTypeNumber {
				return _dgbd
			}
			_afed = append(_afed, _dgbd.ValueNumber)
		case ResultTypeNumber:
			_afed = append(_afed, _cggd.ValueNumber)
		case ResultTypeEmpty:
		case ResultTypeError:
			return _cggd
		}
	}
	if len(_afed) == 0 {
		return MakeErrorResult("\u004cC\u004d\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020a\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006fne\u0020\u006e\u006fn\u002d\u0065m\u0070\u0074\u0079\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	if _afed[0] < 0 {
		return MakeErrorResult("\u004c\u0043M\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(_afed) == 1 {
		return MakeNumberResult(_afed[0])
	}
	_gdgc := _afed[0]
	for _cdgdg := 1; _cdgdg < len(_afed); _cdgdg++ {
		if _afed[_cdgdg] < 0 {
			return MakeErrorResult("\u004c\u0043M\u0028\u0029\u0020\u006fn\u006c\u0079 \u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020p\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
		}
		_gdgc = _fcab(_gdgc, _afed[_cdgdg])
	}
	return MakeNumberResult(_gdgc)
}

// NewRange constructs a new range.
func NewRange(from, to Expression) Expression {
	_gddg, _gbead, _acde := _ccac(from, to)
	if _acde != nil {
		_ga.Log.Debug(_acde.Error())
		return NewError(_acde.Error())
	}
	return Range{_efbed: _gddg, _abfd: _gbead}
}
func Trunc(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("T\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061t \u006c\u0065\u0061\u0073t\u0020\u006f\u006e\u0065\u0020\u006e\u0075\u006d\u0065ri\u0063\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_dbgcd := args[0].AsNumber()
	if _dbgcd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0054\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cacbe := float64(0)
	if len(args) > 1 {
		_ccgf := args[1].AsNumber()
		if _ccgf.Type != ResultTypeNumber {
			return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0054\u0052\u0055\u004e\u0043\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
		}
		_cacbe = _ccgf.ValueNumber
	}
	_baab := _dbgcd.ValueNumber
	_ffgad := 1.0
	if _cacbe >= 0 {
		_ffgad = _gfc.Pow(1/10.0, _cacbe)
	} else {
		return MakeNumberResult(0)
	}
	_baab, _ffbf := _gfc.Modf(_baab / _ffgad)
	_ebfc := 0.99999
	if _ffbf > _ebfc {
		_baab++
	} else if _ffbf < -_ebfc {
		_baab--
	}
	_ = _ffbf
	return MakeNumberResult(_baab * _ffgad)
}

// Eval evaluates and returns the result of a sheet expression.
func (_fafe SheetPrefixExpr) Eval(ctx Context, ev Evaluator) Result {
	return MakeErrorResult("\u0073\u0068\u0065\u0065\u0074\u0020\u0070\u0072\u0065\u0066\u0069\u0078\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u006e\u0065\u0076\u0065r\u0020\u0062\u0065\u0020\u0065v\u0061\u006cu\u0061\u0074\u0065\u0064")
}

// Effect implements the Excel EFFECT function.
func Effect(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u0045\u0046F\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u006f\u006d\u0069n\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_eagg := args[0].ValueNumber
	if _eagg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0045\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u006f\u006d\u0069n\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0045\u0046\u0046\u0045\u0043\u0054 \u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066 \u0063\u006f\u006d\u0070\u006f\u0075\u006e\u0064\u0069\u006e\u0067\u0020p\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	_gafa := float64(int(args[1].ValueNumber))
	if _gafa < 1 {
		return MakeErrorResultType(ErrorTypeNum, "E\u0046\u0046\u0045\u0043\u0054\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0066\u0020\u0063o\u006dp\u006f\u0075\u006e\u0064i\u006e\u0067 \u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0031\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065")
	}
	return MakeNumberResult(_gfc.Pow((1+_eagg/_gafa), _gafa) - 1)
}

// CellRef is a reference to a single cell
type CellRef struct{ _acb string }

// Mid is an implementation of the Excel MID function that returns a copy
// of the string with each word capitalized.
func Mid(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u004d\u0049\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068r\u0065e\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074\u0073")
	}
	_aage := args[0]
	if _aage.Type == ResultTypeError {
		return _aage
	}
	if _aage.Type != ResultTypeString && _aage.Type != ResultTypeNumber && _aage.Type != ResultTypeEmpty {
		return MakeErrorResult("\u004d\u0049\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0065x\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_afgaa := args[0].Value()
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049D\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u005fn\u0075\u006d\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_gedbb := int(args[1].ValueNumber)
	if _gedbb < 1 {
		return MakeErrorResult("M\u0049\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0074\u0061\u0072\u0074\u005fn\u0075\u006d\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006dor\u0065\u0020\u0074h\u0061n\u0020\u0030")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u004d\u0049D\u0020\u0072\u0065\u0071u\u0069\u0072e\u0073\u0020\u006e\u0075\u006d\u005f\u0063\u0068a\u0072\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_faeef := int(args[2].ValueNumber)
	if _faeef < 0 {
		return MakeErrorResult("\u004d\u0049\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u005f\u0063\u0068a\u0072\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	_gcag := len(_afgaa)
	if _gedbb > _gcag {
		return MakeStringResult("")
	}
	_gedbb--
	_dbbe := _gedbb + _faeef
	if _dbbe > _gcag {
		return MakeStringResult(_afgaa[_gedbb:])
	} else {
		return MakeStringResult(_afgaa[_gedbb:_dbbe])
	}
}

// RegisterFunctionComplex registers a standard function.
func RegisterFunctionComplex(name string, fn FunctionComplex) {
	_eadgg.Lock()
	defer _eadgg.Unlock()
	if _, _ggcge := _ecdeb[name]; _ggcge {
		_ga.Log.Debug("\u0064\u0075p\u006c\u0069\u0063\u0061t\u0065\u0020r\u0065\u0067\u0069\u0073\u0074\u0072\u0061\u0074i\u006f\u006e\u0020\u006f\u0066\u0020\u0066\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0025\u0073", name)
	}
	_ecdeb[name] = fn
}

// Update returns the same object as updating sheet references does not affect Bool.
func (_gbdd Bool) Update(q *_de.UpdateQuery) Expression { return _gbdd }
func _eabacg(_gaebg string) *criteriaRegex {
	_egfcf := &criteriaRegex{}
	if _gaebg == "" {
		return _egfcf
	}
	if _befcb := _adeeb.FindStringSubmatch(_gaebg); len(_befcb) > 1 {
		_egfcf._cadca = _fdff
		_egfcf._acdd = _befcb[1]
	} else if _dggg := _bcagb.FindStringSubmatch(_gaebg); len(_dggg) > 1 {
		_egfcf._cadca = _fdff
		_egfcf._acdd = _dggg[1]
	} else if _fbdg := _bcda.FindStringSubmatch(_gaebg); len(_fbdg) > 1 {
		_egfcf._cadca = _cegbg
		_egfcf._acdd = _fbdg[1]
	} else if _cbbfdc := _gfaeg.FindStringSubmatch(_gaebg); len(_cbbfdc) > 1 {
		_egfcf._cadca = _deeb
		_egfcf._acdd = _cbbfdc[1]
	} else if _gffa := _ffaa.FindStringSubmatch(_gaebg); len(_gffa) > 1 {
		_egfcf._cadca = _fgabb
		_egfcf._acdd = _gffa[1]
	} else if _gadb := _gbab.FindStringSubmatch(_gaebg); len(_gadb) > 1 {
		_egfcf._cadca = _bbfg
		_egfcf._acdd = _gadb[1]
	}
	return _egfcf
}

// BinOpType is the binary operation operator type
//go:generate stringer -type=BinOpType
type BinOpType byte

func (_cbba *evCache) GetFromCache(key string) (Result, bool) {
	_cbba._cgb.Lock()
	_cfbc, _egg := _cbba._agf[key]
	_cbba._cgb.Unlock()
	return _cfbc, _egg
}

// HorizontalRange is a range expression that when evaluated returns a list of Results from references like 1:4 (all cells from rows 1 to 4).
type HorizontalRange struct{ _ggef, _edddf int }

func _bgb(_eaa string, _bdd *_de.UpdateQuery) string {
	_bdg, _adc := _ee.ParseCellReference(_eaa)
	if _adc != nil {
		return "\u0023\u0052\u0045F\u0021"
	}
	if _bdd.UpdateType == _de.UpdateActionRemoveColumn {
		_dfe := _bdd.ColumnIdx
		_ccg := _bdg.ColumnIdx
		if _ccg < _dfe {
			return _eaa
		} else if _ccg == _dfe {
			return "\u0023\u0052\u0045F\u0021"
		} else {
			return _bdg.Update(_de.UpdateActionRemoveColumn).String()
		}
	}
	return _eaa
}

// RoundUp is an implementation of the Excel ROUNDUP function that rounds a number
// up to a specified number of digits.
func RoundUp(args []Result) Result { return _dgbbg(args, _dfddc) }

// Xirr implements the Excel XIRR function.
func Xirr(args []Result) Result {
	_fce := len(args)
	if _fce != 2 && _fce != 3 {
		return MakeErrorResult("\u0058\u0049RR\u0020\u0072\u0065q\u0075\u0069\u0072\u0065s t\u0077o \u006f\u0072\u0020\u0074\u0068\u0072\u0065e \u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073")
	}
	_fgfb, _afab := _acag(args[0], args[1], "\u0058\u0049\u0052\u0052")
	if _afab.Type == ResultTypeError {
		return _afab
	}
	_bfdb := _fgfb._ccab
	_gade := _fgfb._fade
	_effg := 0.1
	if _fce == 3 && args[2].Type != ResultTypeEmpty {
		if args[2].Type != ResultTypeNumber {
			return MakeErrorResult("\u0058\u0049\u0052\u0052\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_effg = args[2].ValueNumber
		if _effg <= -1 {
			return MakeErrorResult("\u0058\u0049\u0052\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0067\u0075\u0065\u0073\u0073\u0020\u0074\u006f\u0020\u0062e\u0020\u006d\u006f\u0072\u0065 \u0074\u0068a\u006e\u0020\u002d\u0031")
		}
	}
	return _bcbf(_bfdb, _gade, _effg)
}

type tokenType int

func _bagd(_dadad float64) float64 {
	_cecg := float64(1)
	for _dccfa := float64(2); _dccfa <= _dadad; _dccfa++ {
		_cecg *= _dccfa
	}
	return _cecg
}

var (
	_bdddec = 0
	_befg   = false
)

// Rows implements the Excel ROWS function.
func Rows(args []Result) Result {
	if len(args) < 1 {
		return MakeErrorResult("\u0052\u004f\u0057\u0053\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	_debf := args[0]
	if _debf.Type != ResultTypeArray && _debf.Type != ResultTypeList {
		return MakeErrorResult("\u0052\u004f\u0057S\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_fbag := _debf.ValueArray
	if len(_fbag) == 0 {
		return MakeErrorResult("\u0052O\u0057\u0053 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0072r\u0061\u0079\u0020\u0074\u006f\u0020c\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0074\u0020\u006ce\u0061\u0073\u0074\u0020\u0031\u0020\u0072\u006f\u0077")
	}
	return MakeNumberResult(float64(len(_fbag)))
}

// MinA is an implementation of the Excel MINA() function.
func MinA(args []Result) Result { return _dgad(args, true) }

const _ggec int = 30

// NewNegate constructs a new negate expression.
func NewNegate(e Expression) Expression { return Negate{_gdda: e} }

// GetEpoch returns a null time object for the invalid reference context.
func (_dbff *ivr) GetEpoch() _d.Time { return _d.Time{} }

// Pv implements the Excel PV function.
func Pv(args []Result) Result {
	_cbae := len(args)
	if _cbae < 3 || _cbae > 5 {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0069\u006e\u0020\u0072\u0061\u006e\u0067\u0065\u0020\u006f\u0066\u0020\u0033\u0020\u0061\u006e\u0064\u00205")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_ecfg := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020o\u0066\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_bbbgg := args[1].ValueNumber
	if _bbbgg != float64(int(_bbbgg)) {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006ff\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0069\u006e\u0074\u0065\u0067\u0065\u0072\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0061\u0079\u006d\u0065\u006e\u0074 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eef := args[2].ValueNumber
	_dedc := 0.0
	if _cbae >= 4 && args[3].Type != ResultTypeEmpty {
		if args[3].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0056 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0075\u0074\u0075\u0072\u0065\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_dedc = args[3].ValueNumber
	}
	_bccf := 0.0
	if _cbae == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0079\u0070\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_bccf = args[4].ValueNumber
		if _bccf != 0 {
			_bccf = 1
		}
	}
	if _ecfg == 0 {
		return MakeNumberResult(-_eef*_bbbgg - _dedc)
	} else {
		return MakeNumberResult((((1-_gfc.Pow(1+_ecfg, _bbbgg))/_ecfg)*_eef*(1+_ecfg*_bccf) - _dedc) / _gfc.Pow(1+_ecfg, _bbbgg))
	}
}

// HLookup implements the HLOOKUP function that returns a matching value from a
// row in an array.
func HLookup(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004bU\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074 \u006c\u0065\u0061\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if len(args) > 4 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u0061\u0074\u0020m\u006f\u0073\u0074\u0020\u0066\u006f\u0075\u0072\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_dcgd := args[0]
	_dfa := args[1]
	if _dfa.Type != ResultTypeArray {
		return MakeErrorResult("\u0048\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_gbeec := args[2].AsNumber()
	if _gbeec.Type != ResultTypeNumber {
		return MakeErrorResult("\u0048\u004cO\u004f\u004b\u0055\u0050 \u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075m\u0065\u0072\u0069\u0063\u0020\u0072\u006f\u0077\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gcadg := false
	if len(args) == 4 {
		_bgcg := args[3].AsNumber()
		if _bgcg.Type != ResultTypeNumber {
			return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		if _bgcg.ValueNumber == 0 {
			_gcadg = true
		}
	}
	_gaece := -1
	_bbgg := false
	if len(_dfa.ValueArray) == 0 {
		return MakeErrorResult("\u0048\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020n\u006f\u006e\u002d\u0065\u006d\u0070\u0074\u0079\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_dacceg := _dfa.ValueArray[0]
_accbg:
	for _cbdd, _bbfc := range _dacceg {
		switch _faff(_bbfc, _dcgd, false, _gcadg) {
		case _fcga:
			_gaece = _cbdd
		case _effe:
			_gaece = _cbdd
			_bbgg = true
			break _accbg
		}
	}
	if _gaece == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u0048\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
	}
	_aeded := int(_gbeec.ValueNumber) - 1
	if _aeded < 0 || _aeded > len(_dfa.ValueArray) {
		return MakeErrorResult("\u0048L\u004f\u004f\u004b\u0055P\u0020\u0068\u0061\u0064\u0020i\u006ev\u0061l\u0069\u0064\u0020\u0069\u006e\u0064\u0065x")
	}
	_dacceg = _dfa.ValueArray[_aeded]
	if _gaece < 0 || _gaece >= len(_dacceg) {
		return MakeErrorResult("\u0056\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076a\u006ci\u0064\u0020\u0063\u006f\u006c\u0075\u006d\u006e\u0020\u0069\u006e\u0064\u0065\u0078")
	}
	if _bbgg || !_gcadg {
		return _dacceg[_gaece]
	}
	return MakeErrorResultType(ErrorTypeNA, "\u0056\u004c\u004fOK\u0055\u0050\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075\u006e\u0064")
}

// MDeterm is an implementation of the Excel MDETERM which finds the determinant
// of a matrix.
func MDeterm(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u004d\u0044\u0045T\u0045\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0072\u0061\u0079 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fcgf := args[0]
	if _fcgf.Type != ResultTypeArray {
		return MakeErrorResult("\u004d\u0044\u0045T\u0045\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0069\u006e\u0067\u006c\u0065\u0020\u0061\u0072\u0072\u0061\u0079 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bbbc := len(_fcgf.ValueArray)
	for _, _cagd := range _fcgf.ValueArray {
		if len(_cagd) != _bbbc {
			return MakeErrorResult("\u004d\u0044\u0045TE\u0052\u004d\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072e\u0073 \u0061 \u0073\u0071\u0075\u0061\u0072\u0065\u0020\u006d\u0061\u0074\u0072\u0069\u0078")
		}
	}
	return MakeNumberResult(_eggbe(_fcgf.ValueArray))
}

// GetFormat returns an empty string for the invalid reference context.
func (_bgaag *ivr) GetFormat(cellRef string) string { return "" }
func _cgef(_fbaa []Result) []float64 {
	_fdfad := make([]float64, 0)
	for _, _decb := range _fbaa {
		if _decb.Type == ResultTypeEmpty {
			continue
		}
		_decb = _decb.AsNumber()
		switch _decb.Type {
		case ResultTypeNumber:
			if !_decb.IsBoolean {
				_fdfad = append(_fdfad, _decb.ValueNumber)
			}
		case ResultTypeList, ResultTypeArray:
			_fdfad = append(_fdfad, _cgef(_decb.ListValues())...)
		case ResultTypeString:
		default:
			_ga.Log.Debug("\u0075\u006e\u0068\u0061\u006ed\u006c\u0065\u0064\u0020\u0065\u0078\u0074\u0072\u0061\u0063\u0074\u004e\u0075m\u0062\u0065\u0072\u0073\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _decb.Type)
		}
	}
	return _fdfad
}
func (_fbgca *Lexer) emit(_ccaa tokenType, _gcdd []byte) {
	if _dgcd {
		_c.Println("\u0065\u006d\u0069\u0074", _ccaa, _adcb(string(_gcdd)))
	}
	_fbgca._fbfbd <- &node{_ccaa, string(_gcdd)}
}

// NewBinaryExpr constructs a new binary expression with a given operator.
func NewBinaryExpr(lhs Expression, op BinOpType, rhs Expression) Expression {
	return BinaryExpr{_bg: lhs, _fb: rhs, _dee: op}
}

// Reference returns an invalid reference for Number.
func (_bfea Number) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

var _adeeb, _bcagb, _gbab, _ffaa, _gfaeg, _bcda *_ed.Regexp

// Odd is an implementation of the Excel ODD() that rounds a number to the
// nearest odd integer.
func Odd(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("O\u0044\u0044\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006f\u006ee\u0020\u0061\u0072g\u0075m\u0065\u006e\u0074")
	}
	_gdddc := args[0].AsNumber()
	if _gdddc.Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_dcgb := _gfc.Signbit(_gdddc.ValueNumber)
	_aaadf, _fabc := _gfc.Modf((_gdddc.ValueNumber - 1) / 2)
	_cfcc := _aaadf*2 + 1
	if _fabc != 0 {
		if !_dcgb {
			_cfcc += 2
		} else {
			_cfcc -= 2
		}
	}
	return MakeNumberResult(_cfcc)
}

// PrefixHorizontalRange is a range expression that when evaluated returns a list of Results from references like Sheet1!1:4 (all cells from rows 1 to 4 of sheet 'Sheet1').
type PrefixHorizontalRange struct {
	_bbff        Expression
	_abbf, _fdcc int
}

// Reference returns a string reference value to a horizontal range with prefix.
func (_efaf PrefixHorizontalRange) Reference(ctx Context, ev Evaluator) Reference {
	_bgcgg := _efaf._bbff.Reference(ctx, ev)
	return Reference{Type: ReferenceTypeHorizontalRange, Value: _efaf.horizontalRangeReference(_bgcgg.Value)}
}

type parsedReplaceObject struct {
	_dcee  string
	_dfgc  int
	_ceeac int
	_babb  string
}

func _cbgf(_df BinOpType, _ac [][]Result, _gc Result) Result {
	_gag := [][]Result{}
	for _edf := range _ac {
		_ab := _gfd(_df, _ac[_edf], _gc)
		if _ab.Type == ResultTypeError {
			return _ab
		}
		_gag = append(_gag, _ab.ValueList)
	}
	return MakeArrayResult(_gag)
}

// Oddlyield implements the Excel ODDLYIELD function.
func Oddlyield(args []Result) Result {
	if len(args) != 7 && len(args) != 8 {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u006f\u0072\u0020\u0065\u0069\u0067\u0068\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_abcbd, _bbc, _eecbd := _geae(args[0], args[1], "\u004fD\u0044\u004c\u0059\u0049\u0045\u004cD")
	if _eecbd.Type == ResultTypeError {
		return _eecbd
	}
	_egfc, _eecbd := _bdea(args[2], "\u0069\u0073\u0073\u0075\u0065\u0020\u0064\u0061\u0074\u0065", "\u004fD\u0044\u004c\u0050\u0052\u0049\u0043E")
	if _eecbd.Type == ResultTypeError {
		return _eecbd
	}
	if _egfc >= _abcbd {
		return MakeErrorResultType(ErrorTypeNum, "\u004c\u0061\u0073\u0074\u0020i\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0064\u0061\u0074\u0065\u0020s\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u0062\u0065\u0066\u006f\u0072\u0065\u0020\u0073\u0065\u0074\u0074\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u0064\u0061\u0074e")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020o\u0066\u0020\u0074\u0079\u0070e\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_gbb := args[3].ValueNumber
	if _gbb < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	if args[4].Type != ResultTypeNumber {
		return MakeErrorResult("O\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073 p\u0072\u0065\u0073\u0065n\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u006ff \u0074\u0079p\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_caac := args[4].ValueNumber
	if _caac <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0050\u0072\u0065\u0073\u0065\u006e\u0074\u0020\u0076\u0061\u006c\u0075\u0065\u0020\u0073h\u006fu\u006c\u0064\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[5].Type != ResultTypeNumber {
		return MakeErrorResult("\u004fD\u0044\u004cY\u0049\u0045\u004c\u0044 \u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065mp\u0074\u0069\u006fn\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020n\u0075\u006db\u0065\u0072")
	}
	_adcc := args[5].ValueNumber
	if _adcc < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	if args[6].Type != ResultTypeNumber {
		return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u0066\u0072\u0065\u0071\u0075\u0065\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gacg := float64(int(args[6].ValueNumber))
	if !_beg(_gacg) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_dggbb := 0
	if len(args) == 8 && args[7].Type != ResultTypeEmpty {
		if args[7].Type != ResultTypeNumber {
			return MakeErrorResult("\u004f\u0044\u0044\u004c\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0062a\u0073\u0069\u0073\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
		}
		_dggbb = int(args[7].ValueNumber)
		if !_dfeg(_dggbb) {
			return MakeErrorResultType(ErrorTypeNum, "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0062\u0061\u0073\u0069s\u0020\u0076\u0061\u006c\u0075\u0065\u0020f\u006f\u0072\u0020\u004f\u0044\u0044\u004c\u0059\u0049\u0045L\u0044")
		}
	}
	_bbgc, _eecbd := _fbabb(_egfc, _bbc, _dggbb)
	if _eecbd.Type == ResultTypeError {
		return _eecbd
	}
	_bbgc *= _gacg
	_fecd, _eecbd := _fbabb(_abcbd, _bbc, _dggbb)
	if _eecbd.Type == ResultTypeError {
		return _eecbd
	}
	_fecd *= _gacg
	_caef, _eecbd := _fbabb(_egfc, _abcbd, _dggbb)
	if _eecbd.Type == ResultTypeError {
		return _eecbd
	}
	_caef *= _gacg
	_gceed := _adcc + _bbgc*100*_gbb/_gacg
	_gceed /= _caac + _caef*100*_gbb/_gacg
	_gceed--
	_gceed *= _gacg / _fecd
	return MakeNumberResult(_gceed)
}

// MakeStringResult constructs a string result.
func MakeStringResult(s string) Result { return Result{Type: ResultTypeString, ValueString: s} }

// Lookup implements the LOOKUP function that returns a matching value from a
// column, or from the same index in a second column.
func Lookup(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074 \u0074\u0077\u006f\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	if len(args) > 3 {
		return MakeErrorResult("\u004c\u004f\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0061\u0074\u0020\u006do\u0073\u0074\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_dbbbg := args[0]
	_cdebc := args[1]
	if _cdebc.Type != ResultTypeArray && _cdebc.Type != ResultTypeList {
		return MakeErrorResult("\u0056\u004cO\u004f\u004b\u0055\u0050\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_eagd := _cbaad(_cdebc)
	_dabfa := -1
	for _fccgb, _ebcgc := range _eagd {
		if _faff(_dbbbg, _ebcgc, false, false) == _effe {
			_dabfa = _fccgb
		}
	}
	if _dabfa == -1 {
		return MakeErrorResultType(ErrorTypeNA, "\u004c\u004f\u004f\u004bUP\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	_bafb := _eagd
	if len(args) == 3 {
		_bafb = _cbaad(args[2])
	}
	if _dabfa < 0 || _dabfa >= len(_bafb) {
		return MakeErrorResultType(ErrorTypeNA, "\u004c\u004f\u004f\u004bUP\u0020\u006e\u006f\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0066\u006f\u0075n\u0064")
	}
	return _bafb[_dabfa]
}
func _eacda(_dddd string, _gcceg []Result) (*parsedReplaceObject, Result) {
	if len(_gcceg) != 4 {
		return nil, MakeErrorResult(_dddd + "\u0020r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075r\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if _gcceg[0].Type != ResultTypeString {
		return nil, MakeErrorResult(_dddd + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u0073t\u0072\u0069\u006e\u0067")
	}
	_eadd := _gcceg[0].ValueString
	if _gcceg[1].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_dddd + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e \u0061\u0020\u006eu\u006db\u0065\u0072")
	}
	_gecf := int(_gcceg[1].ValueNumber) - 1
	if _gcceg[2].Type != ResultTypeNumber {
		return nil, MakeErrorResult(_dddd + "\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0069r\u0064\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_dfced := int(_gcceg[2].ValueNumber)
	if _gcceg[3].Type != ResultTypeString {
		return nil, MakeErrorResult(_dddd + " \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0074\u0068\u0020\u0061\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062e \u0061\u0020\u0073t\u0072i\u006e\u0067")
	}
	_cab := _gcceg[3].ValueString
	return &parsedReplaceObject{_eadd, _gecf, _dfced, _cab}, _gaef
}
func (_eacc *ivr) Sheet(name string) Context { return _eacc }

const _dbdg = 57363

func MakeRangeReference(ref string) Reference { return Reference{Type: ReferenceTypeRange, Value: ref} }
func _gbf(_ccee, _daed, _ccgbe, _fgea, _cgbec float64) float64 {
	var _afgc float64
	_bcde := _cgbec / _ccgbe
	if _bcde >= 1 {
		_bcde = 1
		if _fgea == 1 {
			_afgc = _ccee
		} else {
			_afgc = 0
		}
	} else {
		_afgc = _ccee * _gfc.Pow(1-_bcde, _fgea-1)
	}
	_agdb := _ccee * _gfc.Pow(1-_bcde, _fgea)
	var _fbfd float64
	if _agdb < _daed {
		_fbfd = _afgc - _daed
	} else {
		_fbfd = _afgc - _agdb
	}
	if _fbfd < 0 {
		_fbfd = 0
	}
	return _fbfd
}
func _bdea(_cdae Result, _fff, _dcce string) (float64, Result) {
	var _fcac float64
	switch _cdae.Type {
	case ResultTypeNumber:
		_fcac = float64(int(_cdae.ValueNumber))
	case ResultTypeString:
		_cgbg := DateValue([]Result{_cdae})
		if _cgbg.Type == ResultTypeError {
			return 0, MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020" + _fff + "\u0020\u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u0020" + _dcce)
		}
		_fcac = _cgbg.ValueNumber
	default:
		return 0, MakeErrorResult("\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072\u0020" + _dcce)
	}
	if _fcac < 0 {
		return 0, MakeErrorResultType(ErrorTypeNum, _fff+"\u0020\u0073\u0068ou\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069\u0076\u0065")
	}
	return _fcac, _gaef
}

// String returns a string representation for Bool.
func (_af Bool) String() string {
	if _af._fgg {
		return "\u0054\u0052\u0055\u0045"
	} else {
		return "\u0046\u0041\u004cS\u0045"
	}
}

// Eval evaluates and returns the result of a constant array expression.
func (_gd ConstArrayExpr) Eval(ctx Context, ev Evaluator) Result {
	_fbc := [][]Result{}
	for _, _ae := range _gd._cff {
		_acd := []Result{}
		for _, _cdg := range _ae {
			_acd = append(_acd, _cdg.Eval(ctx, ev))
		}
		_fbc = append(_fbc, _acd)
	}
	return MakeArrayResult(_fbc)
}

const (
	ReferenceTypeInvalid ReferenceType = iota
	ReferenceTypeCell
	ReferenceTypeHorizontalRange
	ReferenceTypeVerticalRange
	ReferenceTypeNamedRange
	ReferenceTypeRange
	ReferenceTypeSheet
)

// Syd implements the Excel SYD function.
func Syd(args []Result) Result {
	if len(args) != 4 {
		return MakeErrorResult("S\u0059\u0044\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072 \u0061\u0072\u0067u\u006de\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_edece := args[0].ValueNumber
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_eegb := args[1].ValueNumber
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gegf := args[2].ValueNumber
	if _gegf <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0053\u0059\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bccb := args[3].ValueNumber
	if _bccb <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044 r\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070e\u0072i\u006fd\u0020t\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if _bccb > _gegf {
		return MakeErrorResultType(ErrorTypeNum, "\u0053\u0059\u0044\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0065q\u0075\u0061\u006c\u0020\u006f\u0072\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068a\u006e \u006c\u0069\u0066\u0065")
	}
	_cfce := (_edece - _eegb) * (_gegf - _bccb + 1) * 2
	_ffc := _gegf * (_gegf + 1)
	return MakeNumberResult(_cfce / _ffc)
}

// Ddb implements the Excel DDB function.
func Ddb(args []Result) Result {
	_dcda := len(args)
	if _dcda != 4 && _dcda != 5 {
		return MakeErrorResult("\u0044\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u006f\u0072\u0020\u0066\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020c\u006f\u0073\u0074\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_fbee := args[0].ValueNumber
	if _fbee < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044B \u0072\u0065\u0071u\u0069\u0072\u0065\u0073 co\u0073t \u0074\u006f\u0020\u0062\u0065\u0020\u006eon\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042 \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_afbb := args[1].ValueNumber
	if _afbb < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020s\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u006e\u0020\u006e\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020l\u0069\u0066\u0065\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_eacg := args[2].ValueNumber
	if _eacg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069f\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_cfbe := args[3].ValueNumber
	if _cfbe < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071u\u0069\u0072\u0065s\u0020\u0070\u0065\u0072i\u006f\u0064\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u006f\u0074\u0020\u006c\u0065\u0073\u0073\u0020\u0074\u0068\u0061\u006e\u0020\u006f\u006e\u0065")
	}
	if _cfbe > _eacg {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072i\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0044\u0042")
	}
	_gddbf := 2.0
	if _dcda == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0044\u0042\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
		}
		_gddbf = args[4].ValueNumber
		if _gddbf < 0 {
			return MakeErrorResultType(ErrorTypeNum, "\u0044\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0061\u0063\u0074\u006f\u0072\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
		}
	}
	return MakeNumberResult(_gbf(_fbee, _afbb, _eacg, _cfbe, _gddbf))
}
func _cc(_ag BinOpType, _bgc, _ede [][]Result) Result {
	_fa := [][]Result{}
	for _fg := range _bgc {
		_cb := _cbg(_ag, _bgc[_fg], _ede[_fg])
		if _cb.Type == ResultTypeError {
			return _cb
		}
		_fa = append(_fa, _cb.ValueList)
	}
	return MakeArrayResult(_fa)
}

// NewPrefixExpr constructs an expression with prefix.
func NewPrefixExpr(pfx, exp Expression) Expression { return &PrefixExpr{_dcfga: pfx, _bcbe: exp} }
func _cef(_fcb string) bool {
	for _, _eeed := range _fgga {
		_dgc := _eeed.FindStringSubmatch(_fcb)
		if len(_dgc) > 1 {
			return true
		}
	}
	return false
}
func _gca(_bdgc string, _eff uint32) string {
	_aa := _ee.ColumnToIndex(_bdgc)
	if _aa == _eff {
		return "\u0023\u0052\u0045F\u0021"
	} else if _aa > _eff {
		return _ee.IndexToColumn(_aa - 1)
	} else {
		return _bdgc
	}
}

type yySymType struct {
	_cafe  int
	_aacfc *node
	_fada  Expression
	_fecf  []Expression
	_ffdba [][]Expression
}

// String returns a string representation of Number.
func (_eadb Number) String() string { return _ff.FormatFloat(_eadb._dddg, 'f', -1, 64) }

// Xnpv implements the Excel XNPV function.
func Xnpv(args []Result) Result {
	if len(args) != 3 {
		return MakeErrorResult("\u0058\u004eP\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0068\u0072\u0065\u0065\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("X\u004e\u0050\u0056\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_ddfe := args[0].ValueNumber
	if _ddfe <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0058\u004e\u0050\u0056\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0061\u0074\u0065\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	_fedb, _beaf := _acag(args[1], args[2], "\u0058\u004e\u0050\u0056")
	if _beaf.Type == ResultTypeError {
		return _beaf
	}
	_fccdc := _fedb._ccab
	_bcgce := _fedb._fade
	_edbf := 0.0
	_gabc := _bcgce[0]
	for _befe, _deed := range _fccdc {
		_edbf += _deed / _gfc.Pow(1+_ddfe, (_bcgce[_befe]-_gabc)/365)
	}
	return MakeNumberResult(_edbf)
}

const _bcf = "\u0042\u0069\u006e\u004f\u0070\u0054y\u0070\u0065\u0055\u006e\u006bn\u006fw\u006e\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0050\u006c\u0075\u0073\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u004d\u0069\u006e\u0075\u0073\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065M\u0075lt\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0044\u0069\u0076\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u0045\u0078\u0070\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065\u004c\u0054\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065G\u0054B\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0045\u0051\u0042\u0069nO\u0070\u0054\u0079\u0070\u0065\u004c\u0045\u0051\u0042i\u006eO\u0070\u0054\u0079\u0070\u0065\u0047\u0045\u0051\u0042\u0069\u006e\u004f\u0070\u0054\u0079\u0070\u0065N\u0045\u0042\u0069\u006eO\u0070\u0054\u0079\u0070\u0065\u0043\u006f\u006e\u0063\u0061\u0074"

// Fact is an implementation of the excel FACT function which returns the
// factorial of a positive numeric input.
func Fact(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("F\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_age := args[0].AsNumber()
	if _age.Type != ResultTypeNumber {
		return MakeErrorResult("F\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u0061\u0020\u0073\u0069n\u0067\u006c\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069c \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	if _age.ValueNumber < 0 {
		return MakeErrorResult("\u0046\u0041\u0043\u0054\u0028\u0029\u0020\u0061\u0063\u0063\u0065\u0070\u0074\u0073\u0020\u006f\u006e\u006c\u0079\u0020\u0070\u006f\u0073\u0069t\u0069\u0076\u0065\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	return MakeNumberResult(_bagd(_age.ValueNumber))
}

// HasFormula returns FALSE for the invalid reference context.
func (_efae *ivr) HasFormula(cellRef string) bool { return false }

// Number is a nubmer expression.
type Number struct{ _dddg float64 }

func _eab(_dd, _a [][]Result) bool {
	if len(_dd) != len(_a) {
		return false
	}
	for _db := range _dd {
		if len(_dd[_db]) != len(_a[_db]) {
			return false
		}
	}
	return true
}
func _cbed(_gbfdf yyLexer) int { return _fbefg().Parse(_gbfdf) }

// NewNamedRangeRef constructs a new named range reference.
func NewNamedRangeRef(v string) Expression { return NamedRangeRef{_cgag: v} }
func _gfb(_ffdb string) bool {
	for _, _dfgd := range _aee {
		_gbga := _dfgd.FindStringSubmatch(_ffdb)
		if len(_gbga) > 1 {
			return true
		}
	}
	return false
}

const _bdgaf = "\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065U\u006e\u006b\u006e\u006f\u0077\u006e\u0052\u0065\u0073u\u006c\u0074\u0054y\u0070\u0065\u004e\u0075\u006d\u0062\u0065\u0072\u0052\u0065s\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0053\u0074\u0072\u0069\u006e\u0067\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0073\u0074\u0052\u0065\u0073\u0075lt\u0054\u0079p\u0065\u0041r\u0072\u0061\u0079\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0045\u0072\u0072\u006f\u0072\u0052\u0065\u0073\u0075\u006c\u0074\u0054\u0079\u0070\u0065\u0045\u006d\u0070\u0074\u0079"

func _aaccg(_fcaga Result, _bddde, _bgce int) [][]Result {
	_ggca := [][]Result{}
	switch _fcaga.Type {
	case ResultTypeArray:
		for _aaeb, _ebgf := range _fcaga.ValueArray {
			if _aaeb < _bddde {
				_ggca = append(_ggca, _abda(MakeListResult(_ebgf), _bgce))
			} else {
				_ggca = append(_ggca, _abda(MakeErrorResultType(ErrorTypeNA, ""), _bgce))
			}
		}
	case ResultTypeList:
		_fddb := _abda(_fcaga, _bgce)
		for _ddbcg := 0; _ddbcg < _bddde; _ddbcg++ {
			_ggca = append(_ggca, _fddb)
		}
	case ResultTypeNumber, ResultTypeString, ResultTypeError, ResultTypeEmpty:
		for _eged := 0; _eged < _bddde; _eged++ {
			_dccfe := _abda(_fcaga, _bgce)
			_ggca = append(_ggca, _dccfe)
		}
	}
	return _ggca
}

// RoundDown is an implementation of the Excel ROUNDDOWN function that rounds a number
// down to a specified number of digits.
func RoundDown(args []Result) Result { return _dgbbg(args, _cbfe) }

// Couppcd implements the Excel COUPPCD function.
func Couppcd(args []Result) Result {
	_bgfe, _abg := _acdf(args, "\u0043O\u0055\u0050\u0050\u0043\u0044")
	if _abg.Type == ResultTypeError {
		return _abg
	}
	_debdd := _eeec(_bgfe._fafb)
	_fgag := _eeec(_bgfe._ecf)
	_fbcf := _bgfe._gedd
	_ebaf := _bgfe._bgd
	_fcae := _afa(_debdd, _fgag, _fbcf, _ebaf)
	_fde, _gfbd, _bgfa := _fcae.Date()
	return MakeNumberResult(_gfea(_fde, int(_gfbd), _bgfa))
}
func _gcabd(_fdcf []Result, _ffca []string, _fabff bool) []string {
	for _, _adaf := range _fdcf {
		switch _adaf.Type {
		case ResultTypeEmpty:
			if !_fabff {
				_ffca = append(_ffca, "")
			}
		case ResultTypeString:
			if _adaf.ValueString != "" || !_fabff {
				_ffca = append(_ffca, _adaf.ValueString)
			}
		case ResultTypeNumber:
			_ffca = append(_ffca, _adaf.Value())
		case ResultTypeList:
			_ffca = _ggdf(_ffca, _gcabd(_adaf.ValueList, []string{}, _fabff))
		case ResultTypeArray:
			for _, _agagd := range _adaf.ValueArray {
				_ffca = _ggdf(_ffca, _gcabd(_agagd, []string{}, _fabff))
			}
		}
	}
	return _ffca
}
func _fccg(_eba, _abc int64) float64 { return float64(int(0.5 + float64((_abc-_eba)/86400))) }

// Update updates references in the Negate after removing a row/column.
func (_eafe Negate) Update(q *_de.UpdateQuery) Expression {
	return Negate{_gdda: _eafe._gdda.Update(q)}
}

// LastColumn returns empty string for the invalid reference context.
func (_facgc *ivr) LastColumn(rowFrom, rowTo int) string { return "" }

const _eae = "\u0028\u0028\u005b\u0030\u002d\u0039\u005d\u0029\u002b\u0029\u003a\u0028\u0028\u005b\u0030-\u0039]\u0029\u002b\u0029\u0028\u0020\u0028\u0061\u006d\u007c\u0070\u006d\u0029\u0029\u003f"

type noCache struct{}

var _gabbg = [...]int{45, 3, 44, 32, 18, 40, 72, 46, 47, 30, 31, 32, 39, 48, 28, 29, 30, 31, 32, 75, 39, 49, 32, 56, 50, 70, 23, 39, 76, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 77, 71, 69, 54, 43, 13, 19, 21, 55, 82, 11, 78, 9, 74, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 1, 20, 39, 10, 2, 8, 0, 80, 79, 0, 0, 0, 83, 0, 81, 73, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 0, 0, 39, 28, 29, 30, 31, 32, 37, 33, 34, 35, 36, 38, 26, 27, 39, 51, 52, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 23, 12, 0, 6, 7, 26, 27, 0, 42, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 5, 0, 12, 0, 6, 7, 26, 27, 0, 4, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 0, 12, 53, 6, 7, 26, 27, 0, 0, 0, 25, 14, 15, 16, 17, 0, 24, 23, 22, 41, 0, 12, 0, 6, 7}

func (_aefc *Lexer) Next() *node {
	_aefc._bgada.Lock()
	defer _aefc._bgada.Unlock()
	if len(_aefc._eafbd) > 0 {
		_fgefb := _aefc._eafbd[0]
		_aefc._eafbd = _aefc._eafbd[1:]
		return _fgefb
	}
	return _aefc.nextRaw()
}

// Update returns the same object as updating sheet references does not affect Error.
func (_bgbc Error) Update(q *_de.UpdateQuery) Expression { return _bgbc }

// MakeListResult constructs a list result.
func MakeListResult(list []Result) Result { return Result{Type: ResultTypeList, ValueList: list} }

// Reference returns an invalid reference for BinaryExpr.
func (_efg BinaryExpr) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

type yyParserImpl struct {
	_gbbf  yySymType
	_gedef [_feed]yySymType
	_bgbfg int
}

var InvalidReferenceContext = &ivr{}

func _bbefe(_faea, _defc int) int {
	switch _defc {
	case 1:
		if _acec(_faea) {
			return 366
		} else {
			return 365
		}
	case 3:
		return 365
	default:
		return 360
	}
}

// Eval evaluates and returns the result of a Negate expression.
func (_aaaag Negate) Eval(ctx Context, ev Evaluator) Result {
	_bedde := _aaaag._gdda.Eval(ctx, ev)
	if _bedde.Type == ResultTypeNumber {
		return MakeNumberResult(-_bedde.ValueNumber)
	}
	return MakeErrorResult("\u004e\u0045\u0047A\u0054\u0045\u0020\u0065x\u0070\u0065\u0063\u0074\u0065\u0064\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
}

// Eval evaluates and returns the result of a formula.
func (_bcg *defEval) Eval(ctx Context, formula string) Result {
	_dcg := ParseString(formula)
	_gaa := make(chan Result)
	go func() {
		if _dcg == nil {
			_gaa <- MakeErrorResult(_c.Sprintf("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0070a\u0072\u0073\u0065\u0020\u0066\u006f\u0072\u006d\u0075\u006ca\u0020\u0025\u0073", formula))
		} else {
			_bcg.checkLastEvalIsRef(ctx, _dcg)
			_gaa <- _dcg.Eval(ctx, _bcg)
		}
	}()
	select {
	case _afe := <-_gaa:
		return _afe
	case <-_d.After(_ddf):
		_ga.Log.Debug("\u0055\u006e\u0069\u004ff\u0066\u0069\u0063\u0065\u0020\u0065\u0076\u0061\u006c\u0075a\u0074i\u006f\u006e\u0020\u0074\u0069\u006d\u0065o\u0075\u0074")
		return MakeNumberResult(0)
	}
}
func (_dbcac *yyParserImpl) Parse(yylex yyLexer) int {
	_efbad := _d.Now()
	var _ccfg int
	var _cgcc yySymType
	var _afebb []yySymType
	_ = _afebb
	_ccba := _dbcac._gedef[:]
	Nerrs := 0
	Errflag := 0
	_aeaeg := 0
	_dbcac._bgbfg = -1
	_caeda := -1
	defer func() { _aeaeg = -1; _dbcac._bgbfg = -1; _caeda = -1 }()
	_bdga := -1
	goto _caabc
_aaega:
	return 0
_egdda:
	return 1
_caabc:
	if _bfde(_efbad) {
		_ga.Log.Error("\u0050\u0061\u0072\u0073\u0065\u0020\u0074\u0069\u006d\u0065\u006f\u0075\u0074")
		goto _egdda
	}
	if _bdddec >= 4 {
		_c.Printf("\u0063\u0068\u0061\u0072\u0020\u0025\u0076\u0020\u0069n\u0020\u0025\u0076\u000a", _addea(_caeda), _eaaf(_aeaeg))
	}
	_bdga++
	if _bdga >= len(_ccba) {
		_dfada := make([]yySymType, len(_ccba)*2)
		copy(_dfada, _ccba)
		_ccba = _dfada
	}
	_ccba[_bdga] = _cgcc
	_ccba[_bdga]._cafe = _aeaeg
_gcec:
	if _bfde(_efbad) {
		_ga.Log.Error("\u0050\u0061\u0072\u0073\u0065\u0020\u0074\u0069\u006d\u0065\u006f\u0075\u0074")
		goto _egdda
	}
	_ccfg = _fdaae[_aeaeg]
	if _ccfg <= _ecaag {
		goto _afbfc
	}
	if _dbcac._bgbfg < 0 {
		_dbcac._bgbfg, _caeda = _bdfdf(yylex, &_dbcac._gbbf)
	}
	_ccfg += _caeda
	if _ccfg < 0 || _ccfg >= _ccbbb {
		goto _afbfc
	}
	_ccfg = _gabbg[_ccfg]
	if _becg[_ccfg] == _caeda {
		_dbcac._bgbfg = -1
		_caeda = -1
		_cgcc = _dbcac._gbbf
		_aeaeg = _ccfg
		if Errflag > 0 {
			Errflag--
		}
		goto _caabc
	}
_afbfc:
	if _bfde(_efbad) {
		_ga.Log.Error("\u0050\u0061\u0072\u0073\u0065\u0020\u0074\u0069\u006d\u0065\u006f\u0075\u0074")
		goto _egdda
	}
	_ccfg = _eggg[_aeaeg]
	if _ccfg == -2 {
		if _dbcac._bgbfg < 0 {
			_dbcac._bgbfg, _caeda = _bdfdf(yylex, &_dbcac._gbbf)
		}
		_aecgg := 0
		for {
			if _bcfbd[_aecgg+0] == -1 && _bcfbd[_aecgg+1] == _aeaeg {
				break
			}
			_aecgg += 2
		}
		for _aecgg += 2; ; _aecgg += 2 {
			_ccfg = _bcfbd[_aecgg+0]
			if _ccfg < 0 || _ccfg == _caeda {
				break
			}
		}
		_ccfg = _bcfbd[_aecgg+1]
		if _ccfg < 0 {
			goto _aaega
		}
	}
	if _ccfg == 0 {
		switch Errflag {
		case 0:
			yylex.Error(_gbdef(_aeaeg, _caeda))
			Nerrs++
			if _bdddec >= 1 {
				_c.Printf("\u0025\u0073", _eaaf(_aeaeg))
				_c.Printf("\u0020\u0073\u0061\u0077\u0020\u0025\u0073\u000a", _addea(_caeda))
			}
			fallthrough
		case 1, 2:
			Errflag = 3
			for _bdga >= 0 {
				_ccfg = _fdaae[_ccba[_bdga]._cafe] + _egegg
				if _ccfg >= 0 && _ccfg < _ccbbb {
					_aeaeg = _gabbg[_ccfg]
					if _becg[_aeaeg] == _egegg {
						goto _caabc
					}
				}
				if _bdddec >= 2 {
					_c.Printf("\u0065\u0072r\u006f\u0072\u0020\u0072\u0065\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u0070\u006f\u0070\u0073\u0020\u0073\u0074\u0061\u0074\u0065 %\u0064\u000a", _ccba[_bdga]._cafe)
				}
				_bdga--
			}
			goto _egdda
		case 3:
			if _bdddec >= 2 {
				_c.Printf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0063\u006f\u0076\u0065\u0072\u0079\u0020\u0064\u0069s\u0063\u0061\u0072d\u0073 \u0025\u0073\u000a", _addea(_caeda))
			}
			if _caeda == _cbecc {
				goto _egdda
			}
			_dbcac._bgbfg = -1
			_caeda = -1
			goto _gcec
		}
	}
	if _bdddec >= 2 {
		_c.Printf("\u0072e\u0064u\u0063\u0065\u0020\u0025\u0076 \u0069\u006e:\u000a\u0009\u0025\u0076\u000a", _ccfg, _eaaf(_aeaeg))
	}
	_fdeef := _ccfg
	_gafda := _bdga
	_ = _gafda
	_bdga -= _gegec[_ccfg]
	if _bdga+1 >= len(_ccba) {
		_bbdc := make([]yySymType, len(_ccba)*2)
		copy(_bbdc, _ccba)
		_ccba = _bbdc
	}
	_cgcc = _ccba[_bdga+1]
	_ccfg = _dged[_ccfg]
	_ffgbd := _fadc[_ccfg]
	_gcaeg := _ffgbd + _ccba[_bdga]._cafe + 1
	if _gcaeg >= _ccbbb {
		_aeaeg = _gabbg[_ffgbd]
	} else {
		_aeaeg = _gabbg[_gcaeg]
		if _becg[_aeaeg] != -_ccfg {
			_aeaeg = _gabbg[_ffgbd]
		}
	}
	switch _fdeef {
	case 1:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			yylex.(*plex)._beaab = _cgcc._fada
		}
	case 3:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = _afebb[2]._fada
		}
	case 4:
		_afebb = _ccba[_gafda-4 : _gafda+1]
		{
		}
	case 5:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewBool(_afebb[1]._aacfc._cedb)
		}
	case 6:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewNumber(_afebb[1]._aacfc._cedb)
		}
	case 7:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewString(_afebb[1]._aacfc._cedb)
		}
	case 8:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewError(_afebb[1]._aacfc._cedb)
		}
	case 9:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = _afebb[2]._fada
		}
	case 10:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = NewNegate(_afebb[2]._fada)
		}
	case 15:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = _afebb[2]._fada
		}
	case 17:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewConstArrayExpr(_afebb[2]._ffdba)
		}
	case 18:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._ffdba = append(_cgcc._ffdba, _afebb[1]._fecf)
		}
	case 19:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._ffdba = append(_afebb[1]._ffdba, _afebb[3]._fecf)
		}
	case 20:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fecf = append(_cgcc._fecf, _afebb[1]._fada)
		}
	case 21:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fecf = append(_afebb[1]._fecf, _afebb[3]._fada)
		}
	case 23:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = NewPrefixExpr(_afebb[1]._fada, _afebb[2]._fada)
		}
	case 25:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewSheetPrefixExpr(_afebb[1]._aacfc._cedb)
		}
	case 26:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewCellRef(_afebb[1]._aacfc._cedb)
		}
	case 27:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewRange(_afebb[1]._fada, _afebb[3]._fada)
		}
	case 28:
		_afebb = _ccba[_gafda-4 : _gafda+1]
		{
			_cgcc._fada = NewPrefixRangeExpr(_afebb[1]._fada, _afebb[2]._fada, _afebb[4]._fada)
		}
	case 29:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewNamedRangeRef(_afebb[1]._aacfc._cedb)
		}
	case 30:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewHorizontalRange(_afebb[1]._aacfc._cedb)
		}
	case 31:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fada = NewVerticalRange(_afebb[1]._aacfc._cedb)
		}
	case 32:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = NewPrefixHorizontalRange(_afebb[1]._fada, _afebb[2]._aacfc._cedb)
		}
	case 33:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = NewPrefixVerticalRange(_afebb[1]._fada, _afebb[2]._aacfc._cedb)
		}
	case 34:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypePlus, _afebb[3]._fada)
		}
	case 35:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeMinus, _afebb[3]._fada)
		}
	case 36:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeMult, _afebb[3]._fada)
		}
	case 37:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeDiv, _afebb[3]._fada)
		}
	case 38:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeExp, _afebb[3]._fada)
		}
	case 39:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeLT, _afebb[3]._fada)
		}
	case 40:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeGT, _afebb[3]._fada)
		}
	case 41:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeLEQ, _afebb[3]._fada)
		}
	case 42:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeGEQ, _afebb[3]._fada)
		}
	case 43:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeEQ, _afebb[3]._fada)
		}
	case 44:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeNE, _afebb[3]._fada)
		}
	case 45:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewBinaryExpr(_afebb[1]._fada, BinOpTypeConcat, _afebb[3]._fada)
		}
	case 47:
		_afebb = _ccba[_gafda-2 : _gafda+1]
		{
			_cgcc._fada = NewFunction(_afebb[1]._aacfc._cedb, nil)
		}
	case 48:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fada = NewFunction(_afebb[1]._aacfc._cedb, _afebb[2]._fecf)
		}
	case 49:
		_afebb = _ccba[_gafda-1 : _gafda+1]
		{
			_cgcc._fecf = append(_cgcc._fecf, _afebb[1]._fada)
		}
	case 50:
		_afebb = _ccba[_gafda-3 : _gafda+1]
		{
			_cgcc._fecf = append(_afebb[1]._fecf, _afebb[3]._fada)
		}
	case 53:
		_afebb = _ccba[_gafda-0 : _gafda+1]
		{
			_cgcc._fada = NewEmptyExpr()
		}
	}
	goto _caabc
}

// PrefixExpr is an expression containing reference to another sheet like Sheet1!A1 (the value of the cell A1 from sheet 'Sheet1').
type PrefixExpr struct {
	_dcfga Expression
	_bcbe  Expression
}

// NewHorizontalRange constructs a new full rows range.
func NewHorizontalRange(v string) Expression {
	_acddd := _gg.Split(v, "\u003a")
	if len(_acddd) != 2 {
		return nil
	}
	_gcfec, _ := _ff.Atoi(_acddd[0])
	_abeae, _ := _ff.Atoi(_acddd[1])
	if _gcfec > _abeae {
		_gcfec, _abeae = _abeae, _gcfec
	}
	return HorizontalRange{_ggef: _gcfec, _edddf: _abeae}
}
func (_dbade PrefixVerticalRange) verticalRangeReference(_bbgf string) string {
	return _c.Sprintf("\u0025\u0073\u0021\u0025\u0073\u003a\u0025\u0073", _bbgf, _dbade._cagbb, _dbade._baae)
}

// String returns a string representation of a horizontal range.
func (_ebgec HorizontalRange) String() string { return _ebgec.horizontalRangeReference() }

const (
	_effe cmpResult = 0
	_fcga cmpResult = -1
	_cgaa cmpResult = 1
	_gfgf cmpResult = 2
)

var _agg = map[string]int{"\u006aa\u006e\u0075\u0061\u0072\u0079": 1, "\u0066\u0065\u0062\u0072\u0075\u0061\u0072\u0079": 2, "\u006d\u0061\u0072c\u0068": 3, "\u0061\u0070\u0072i\u006c": 4, "\u006d\u0061\u0079": 5, "\u006a\u0075\u006e\u0065": 6, "\u006a\u0075\u006c\u0079": 7, "\u0061\u0075\u0067\u0075\u0073\u0074": 8, "\u0073e\u0070\u0074\u0065\u006d\u0070\u0065r": 9, "\u006fc\u0074\u006f\u0062\u0065\u0072": 10, "\u006e\u006f\u0076\u0065\u006d\u0062\u0065\u0072": 11, "\u0064\u0065\u0063\u0065\u006d\u0062\u0065\u0072": 12, "\u006a\u0061\u006e": 1, "\u0066\u0065\u0062": 2, "\u006d\u0061\u0072": 3, "\u0061\u0070\u0072": 4, "\u006a\u0075\u006e": 6, "\u006a\u0075\u006c": 7, "\u0061\u0075\u0067": 8, "\u0073\u0065\u0070": 9, "\u006f\u0063\u0074": 10, "\u006e\u006f\u0076": 11, "\u0064\u0065\u0063": 12}
var _dffea = []ri{{1000, "\u004d"}, {990, "\u0058\u004d"}, {950, "\u004c\u004d"}, {900, "\u0043\u004d"}, {500, "\u0044"}, {490, "\u0058\u0044"}, {450, "\u004c\u0044"}, {400, "\u0043\u0044"}, {100, "\u0043"}, {99, "\u0049\u0043"}, {90, "\u0058\u0043"}, {50, "\u004c"}, {45, "\u0056\u004c"}, {40, "\u0058\u004c"}, {10, "\u0058"}, {9, "\u0049\u0058"}, {5, "\u0056"}, {4, "\u0049\u0056"}, {1, "\u0049"}}

// Update updates the FunctionCall references after removing a row/column.
func (_ddbga FunctionCall) Update(q *_de.UpdateQuery) Expression {
	_eabgf := []Expression{}
	for _, _bcagd := range _ddbga._ebbe {
		_dfefb := _bcagd.Update(q)
		_eabgf = append(_eabgf, _dfefb)
	}
	return FunctionCall{_bbfgf: _ddbga._bbfgf, _ebbe: _eabgf}
}
func _bcbf(_aed, _adad []float64, _adce float64) Result {
	_effa := false
	_dbbb := false
	for _ebcb := 0; _ebcb < len(_aed); _ebcb++ {
		if _aed[_ebcb] > 0 {
			_effa = true
		}
		if _aed[_ebcb] < 0 {
			_dbbb = true
		}
	}
	if !_effa || !_dbbb {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	_dabb := _adce
	_faeg := 1e-10
	_fcfc := 0
	_gaca := 50
	_gffg := false
	for {
		_ddcc := _bgbe(_aed, _adad, _dabb)
		_fgfc := _dabb - _ddcc/_gbge(_aed, _adad, _dabb)
		_bgeac := _gfc.Abs(_fgfc - _dabb)
		_dabb = _fgfc
		_fcfc++
		if _bgeac <= _faeg || _gfc.Abs(_ddcc) <= _faeg {
			break
		}
		if _fcfc > _gaca {
			_gffg = true
			break
		}
	}
	if _gffg || _gfc.IsNaN(_dabb) || _gfc.IsInf(_dabb, 0) {
		return MakeErrorResultType(ErrorTypeNum, "")
	}
	return MakeNumberResult(_dabb)
}

// Yield implements the Excel YIELD function.
func Yield(args []Result) Result {
	_afaa := len(args)
	if _afaa != 6 && _afaa != 7 {
		return MakeErrorResult("\u0059\u0049E\u004c\u0044\u0020\u0072e\u0071\u0075i\u0072\u0065\u0073\u0020\u0073\u0069\u0078\u0020o\u0072\u0020\u0073\u0065\u0076\u0065\u006e\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_egac, _aceb, _bffd := _geae(args[0], args[1], "\u0059\u0049\u0045L\u0044")
	if _bffd.Type == ResultTypeError {
		return _bffd
	}
	_aeae := args[2]
	if _aeae.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045LD\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072a\u0074e\u0020o\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_eafg := _aeae.ValueNumber
	if _eafg < 0 {
		return MakeErrorResultType(ErrorTypeNum, "R\u0061\u0074\u0065\u0020\u0073\u0068o\u0075\u006c\u0064\u0020\u0062\u0065\u0020\u006e\u006fn\u0020\u006e\u0065g\u0061t\u0069\u0076\u0065")
	}
	_aebf := args[3]
	if _aebf.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020p\u0072 \u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_acced := _aebf.ValueNumber
	if _acced <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "p\u0072\u0020\u0073\u0068ou\u006cd\u0020\u0062\u0065\u0020\u0070o\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	_addf := args[4]
	if _addf.Type != ResultTypeNumber {
		return MakeErrorResult("Y\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0072\u0065\u0064\u0065m\u0070\u0074\u0069\u006f\u006e\u0020\u006f\u0066\u0020\u0074yp\u0065\u0020\u006eu\u006db\u0065\u0072")
	}
	_bcgaa := _addf.ValueNumber
	if _bcgaa < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0059\u0069\u0065\u006cd\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u006eo\u006e\u0020\u006e\u0065\u0067\u0061\u0074i\u0076\u0065")
	}
	_aede := args[5]
	if _aede.Type != ResultTypeNumber {
		return MakeErrorResult("\u0059\u0049\u0045\u004c\u0044\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065s\u0020\u0066\u0072\u0065\u0071\u0075e\u006e\u0063\u0079\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u006eu\u006d\u0062\u0065\u0072")
	}
	_ggdc := float64(int(_aede.ValueNumber))
	if !_beg(_ggdc) {
		return MakeErrorResultType(ErrorTypeNum, "\u0049n\u0063\u006f\u0072\u0072e\u0063\u0074\u0020\u0066\u0072e\u0071u\u0065n\u0063\u0065\u0020\u0076\u0061\u006c\u0075e")
	}
	_efcf := 0
	if _afaa == 7 && args[6].Type != ResultTypeEmpty {
		_becf := args[6]
		if _becf.Type != ResultTypeNumber {
			return MakeErrorResult("Y\u0049\u0045\u004c\u0044\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u0062\u0061\u0073\u0069\u0073\u0020\u006ff\u0020\u0074\u0079\u0070\u0065\u0020\u006e\u0075\u006d\u0062e\u0072")
		}
		_efcf = int(_becf.ValueNumber)
		if !_dfeg(_efcf) {
			return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063o\u0072\u0072\u0065\u0063t\u0020\u0062\u0061\u0073\u0069\u0073\u0020v\u0061\u006c\u0075\u0065\u0020\u0066\u006f\u0072\u0020\u0059\u0049\u0045\u004c\u0044")
		}
	}
	_defec := 0.0
	_effc := 0.0
	_gcbcf := 1.0
	_gefd, _bffd := _cfba(_egac, _aceb, _eafg, _effc, _bcgaa, _ggdc, _efcf)
	if _bffd.Type == ResultTypeError {
		return _bffd
	}
	_cfefd, _bffd := _cfba(_egac, _aceb, _eafg, _gcbcf, _bcgaa, _ggdc, _efcf)
	if _bffd.Type == ResultTypeError {
		return _bffd
	}
	_eaca := (_gcbcf - _effc) * 0.5
	for _dbfa := 0; _dbfa < 100 && _defec != _acced; _dbfa++ {
		_defec, _bffd = _cfba(_egac, _aceb, _eafg, _eaca, _bcgaa, _ggdc, _efcf)
		if _bffd.Type == ResultTypeError {
			return _bffd
		}
		if _acced == _gefd {
			return MakeNumberResult(_effc)
		} else if _acced == _cfefd {
			return MakeNumberResult(_gcbcf)
		} else if _acced == _defec {
			return MakeNumberResult(_eaca)
		} else if _acced < _cfefd {
			_gcbcf *= 2.0
			_cfefd, _bffd = _cfba(_egac, _aceb, _eafg, _gcbcf, _bcgaa, _ggdc, _efcf)
			if _bffd.Type == ResultTypeError {
				return _bffd
			}
			_eaca = (_gcbcf - _effc) * 0.5
		} else {
			if _acced < _defec {
				_effc = _eaca
				_gefd = _defec
			} else {
				_gcbcf = _eaca
				_cfefd = _defec
			}
			_eaca = _gcbcf - (_gcbcf-_effc)*((_acced-_cfefd)/(_gefd-_cfefd))
		}
	}
	return MakeNumberResult(_eaca)
}
func _efagg(_dcdga Context, _fbcdb Evaluator, _aefcb, _fbcff string) Result {
	_cagad, _gccc := _ee.ParseCellReference(_aefcb)
	if _gccc != nil {
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073e\u0020r\u0061n\u0067e\u0020\u0025\u0073\u003a\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _aefcb, _gccc.Error()))
	}
	_gedfc, _ggae := _cagad.ColumnIdx, _cagad.RowIdx
	_aeee, _fbdcd := _ee.ParseCellReference(_fbcff)
	if _fbdcd != nil {
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0070\u0061\u0072\u0073e\u0020r\u0061n\u0067e\u0020\u0025\u0073\u003a\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0025\u0073", _fbcff, _fbdcd.Error()))
	}
	_bedf, _ebcf := _aeee.ColumnIdx, _aeee.RowIdx
	_eaab := [][]Result{}
	for _bbaac := _ggae; _bbaac <= _ebcf; _bbaac++ {
		_abagg := []Result{}
		for _edbab := _gedfc; _edbab <= _bedf; _edbab++ {
			_gdge := _dcdga.Cell(_c.Sprintf("\u0025\u0073\u0025\u0064", _ee.IndexToColumn(_edbab), _bbaac), _fbcdb)
			_abagg = append(_abagg, _gdge)
		}
		_eaab = append(_eaab, _abagg)
	}
	if len(_eaab) == 1 {
		if len(_eaab[0]) == 1 {
			return _eaab[0][0]
		}
		return MakeListResult(_eaab[0])
	}
	return MakeArrayResult(_eaab)
}

type ivr struct{}

var _fgga = []*_ed.Regexp{}

// String is a string expression.
type String struct{ _geef string }

// Arabic implements the Excel ARABIC function which parses roman numerals.  It
// accepts one numeric argument.
func Arabic(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0041\u0052\u0041\u0042I\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065\u0020\u0061\u0072\u0067\u0075\u006de\u006e\u0074")
	}
	_dcfcd := args[0]
	switch _dcfcd.Type {
	case ResultTypeNumber, ResultTypeList, ResultTypeEmpty:
		return MakeErrorResult("\u0041\u0052\u0041B\u0049\u0043\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	case ResultTypeString:
		_abag := 0.0
		_dcga := 0.0
		for _, _acbdd := range _dcfcd.ValueString {
			_aadg := 0.0
			switch _acbdd {
			case 'I':
				_aadg = 1
			case 'V':
				_aadg = 5
			case 'X':
				_aadg = 10
			case 'L':
				_aadg = 50
			case 'C':
				_aadg = 100
			case 'D':
				_aadg = 500
			case 'M':
				_aadg = 1000
			}
			_abag += _aadg
			switch {
			case _dcga == _aadg && (_dcga == 5 || _dcga == 50 || _dcga == 500):
				return MakeErrorResult("i\u006e\u0076\u0061\u006cid\u0020A\u0052\u0041\u0042\u0049\u0043 \u0066\u006f\u0072\u006d\u0061\u0074")
			case 2*_dcga == _aadg:
				return MakeErrorResult("i\u006e\u0076\u0061\u006cid\u0020A\u0052\u0041\u0042\u0049\u0043 \u0066\u006f\u0072\u006d\u0061\u0074")
			}
			if _dcga < _aadg {
				_abag -= 2 * _dcga
			}
			_dcga = _aadg
		}
		return MakeNumberResult(_abag)
	case ResultTypeError:
		return _dcfcd
	default:
		return MakeErrorResult(_c.Sprintf("\u0075\u006e\u0068an\u0064\u006c\u0065\u0064\u0020\u0041\u0043\u004f\u0053H\u0028)\u0020a\u0072g\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dcfcd.Type))
	}
}
func _dgbbg(_fbcb []Result, _bbcf rmode) Result {
	if len(_fbcb) != 2 {
		return MakeErrorResult("\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u006e\u0075\u006de\u0072\u0069\u0063\u0020\u0061r\u0067\u0075m\u0065\u006e\u0074\u0073")
	}
	_dcgba := _fbcb[0].AsNumber()
	if _dcgba.Type != ResultTypeNumber {
		return MakeErrorResult("\u0066\u0069\u0072s\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065 \u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_gegb := _fbcb[1].AsNumber()
	if _gegb.Type != ResultTypeNumber {
		return MakeErrorResult("\u0073\u0065\u0063\u006f\u006e\u0064\u0020a\u0072\u0067\u0075m\u0065\u006e\u0074\u0020t\u006f\u0020\u0052\u004f\u0055\u004e\u0044\u0028\u0029\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_cbdgg := _gegb.ValueNumber
	_bebgb := _dcgba.ValueNumber
	_egea := 1.0
	if _cbdgg > 0 {
		_egea = _gfc.Pow(1/10.0, _cbdgg)
	} else {
		_egea = _gfc.Pow(10.0, -_cbdgg)
	}
	_bebgb, _dbdc := _gfc.Modf(_bebgb / _egea)
	switch _bbcf {
	case _ggdce:
		const _fdg = 0.499999999
		if _dbdc >= _fdg {
			_bebgb++
		} else if _dbdc <= -_fdg {
			_bebgb--
		}
	case _cbfe:
	case _dfddc:
		if _dbdc > 0 {
			_bebgb++
		} else if _dbdc < 0 {
			_bebgb--
		}
	}
	return MakeNumberResult(_bebgb * _egea)
}

// Db implements the Excel DB function.
func Db(args []Result) Result {
	_bgec := len(args)
	if _bgec != 4 && _bgec != 5 {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u006f\u0075\u0072\u0020\u006f\u0072 \u0066\u0069\u0076\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0063\u006f\u0073\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cfee := args[0].ValueNumber
	if _cfee < 0 {
		return MakeErrorResultType(ErrorTypeNum, "D\u0042\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0073\u0020\u0063\u006fs\u0074\u0020\u0074\u006f\u0020\u0062\u0065 \u006e\u006f\u006e\u0020\u006e\u0065\u0067\u0061\u0074\u0069v\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_bafe := args[1].ValueNumber
	if _bafe < 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0061\u006c\u0076\u0061\u0067\u0065\u0020\u0074\u006f\u0020\u0062e\u0020\u006e\u006f\u006e\u0020n\u0065\u0067a\u0074\u0069\u0076\u0065")
	}
	if args[2].Type != ResultTypeNumber {
		return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006c\u0069\u0066\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006eu\u006d\u0062\u0065\u0072\u0020a\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_cagc := args[2].ValueNumber
	if _cagc <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020r\u0065\u0071\u0075\u0069r\u0065\u0073\u0020\u006c\u0069\u0066\u0065 \u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[3].Type != ResultTypeNumber {
		return MakeErrorResult("D\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020t\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065r \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_eeg := args[3].ValueNumber
	if _eeg <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u0044\u0042\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0074o\u0020\u0062\u0065\u0020\u0070\u006f\u0073i\u0074\u0069\u0076\u0065")
	}
	if _eeg-_cagc > 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0042")
	}
	_cdfa := 12.0
	if _bgec == 5 && args[4].Type != ResultTypeEmpty {
		if args[4].Type != ResultTypeNumber {
			return MakeErrorResult("\u0044\u0042\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006do\u006e\u0074\u0068\u0020\u0074\u006f \u0062\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
		}
		_cdfa = args[4].ValueNumber
		if _cdfa < 1 || _cdfa > 12 {
			return MakeErrorResultType(ErrorTypeNum, "\u0044B\u0020\u0072e\u0071\u0075\u0069\u0072e\u0073\u0020\u006do\u006e\u0074\u0068\u0020\u0074\u006f\u0020\u0062\u0065 i\u006e\u0020\u0072a\u006e\u0067e\u0020\u006f\u0066\u0020\u0031\u0020a\u006e\u0064 \u0031\u0032")
		}
	}
	if _cdfa == 12 && _eeg > _cagc {
		return MakeErrorResultType(ErrorTypeNum, "\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0020\u0066\u006f\u0072\u0020\u0044\u0042")
	}
	if _bafe >= _cfee {
		return MakeNumberResult(0)
	}
	_fdcd := 1 - _gfc.Pow(_bafe/_cfee, 1/_cagc)
	_fdcd = float64(int(_fdcd*1000+0.5)) / 1000
	_badc := _cfee * _fdcd * _cdfa / 12
	if _eeg == 1 {
		return MakeNumberResult(_badc)
	}
	_agge := _badc
	_ccbd := 0.0
	_feff := _cagc
	if _feff > _eeg {
		_feff = _eeg
	}
	for _ffde := 2.0; _ffde <= _feff; _ffde++ {
		_ccbd = (_cfee - _agge) * _fdcd
		_agge += _ccbd
	}
	if _eeg > _cagc {
		return MakeNumberResult((_cfee - _agge) * _fdcd * (12 - _cdfa) / 12)
	}
	return MakeNumberResult(_ccbd)
}

// IsLeapYear is an implementation of the Excel ISLEAPYEAR() function.
func IsLeapYear(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 || args[0].Type != ResultTypeNumber {
		return MakeErrorResult("\u0049S\u004c\u0045A\u0050\u0059\u0045\u0041R\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073in\u0067\u006c\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_edac := ctx.GetEpoch()
	_ffeg, _adbff := _bbfa(args[0].Value(), _edac)
	if _adbff != nil {
		return MakeErrorResult("\u0049S\u004c\u0045A\u0050\u0059\u0045\u0041R\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073in\u0067\u006c\u0065 \u006e\u0075m\u0062\u0065\u0072\u0020\u0061\u0072g\u0075\u006de\u006e\u0074")
	}
	_dgec := _ffeg.Year()
	return MakeBoolResult(_acec(_dgec))
}

// Product is an implementation of the Excel PRODUCT() function.
func Product(args []Result) Result {
	_eddc := 1.0
	for _, _cbdg := range args {
		_cbdg = _cbdg.AsNumber()
		switch _cbdg.Type {
		case ResultTypeNumber:
			_eddc *= _cbdg.ValueNumber
		case ResultTypeList, ResultTypeArray:
			_bgcee := Product(_cbdg.ListValues())
			if _bgcee.Type != ResultTypeNumber {
				return _bgcee
			}
			_eddc *= _bgcee.ValueNumber
		case ResultTypeString:
		case ResultTypeError:
			return _cbdg
		case ResultTypeEmpty:
		default:
			return MakeErrorResult(_c.Sprintf("\u0075\u006eha\u006e\u0064\u006ce\u0064\u0020\u0050\u0052ODU\u0043T(\u0029\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0020\u0074\u0079\u0070\u0065\u0020%\u0073", _cbdg.Type))
		}
	}
	return MakeNumberResult(_eddc)
}
func _cefg(_egf string) (int, int, float64, bool, bool, Result) {
	_acbe := ""
	_dce := []string{}
	for _daa, _gga := range _eeea {
		_dce = _gga.FindStringSubmatch(_egf)
		if len(_dce) > 1 {
			_acbe = _daa
			break
		}
	}
	if _acbe == "" {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
	}
	_aecc := _dce[1] == ""
	_dce = _dce[49:]
	_edbd := len(_dce)
	_fag := _dce[_edbd-1]
	_bddf := _fag == "\u0061\u006d"
	_bece := _fag == "\u0070\u006d"
	var _cgf, _baf int
	var _fgbb float64
	var _gbdf error
	switch _acbe {
	case "\u0068\u0068":
		_cgf, _gbdf = _ff.Atoi(_dce[0])
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
		_baf = 0
		_fgbb = 0
	case "\u0068\u0068\u003am\u006d":
		_cgf, _gbdf = _ff.Atoi(_dce[0])
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
		_baf, _gbdf = _ff.Atoi(_dce[2])
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
		_fgbb = 0
	case "\u006d\u006d\u003as\u0073":
		_cgf = 0
		_baf, _gbdf = _ff.Atoi(_dce[0])
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
		_fgbb, _gbdf = _ff.ParseFloat(_dce[2], 64)
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
	case "\u0068\u0068\u003a\u006d\u006d\u003a\u0073\u0073":
		_cgf, _gbdf = _ff.Atoi(_dce[0])
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
		_baf, _gbdf = _ff.Atoi(_dce[2])
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
		_fgbb, _gbdf = _ff.ParseFloat(_dce[4], 64)
		if _gbdf != nil {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		}
	}
	if _baf >= 60 {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
	}
	if _bddf || _bece {
		if _cgf > 12 || _fgbb >= 60 {
			return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
		} else if _cgf == 12 {
			_cgf = 0
		}
	} else if _cgf >= 24 || _fgbb >= 10000 {
		return 0, 0, 0, false, false, MakeErrorResultType(ErrorTypeValue, _gbc)
	}
	return _cgf, _baf, _fgbb, _bece, _aecc, _gaef
}

// Reference returns an invalid reference for Negate.
func (_ccgbdd Negate) Reference(ctx Context, ev Evaluator) Reference { return ReferenceInvalid }

var _aacca = [...]int{1}

// Eval evaluates the binary expression using the context given.
func (_dec BinaryExpr) Eval(ctx Context, ev Evaluator) Result {
	_dc := _dec._bg.Eval(ctx, ev)
	if _dc.Type == ResultTypeError {
		return _dc
	}
	_bb := _dec._fb.Eval(ctx, ev)
	if _bb.Type == ResultTypeError {
		return _bb
	}
	if _dc.Type == _bb.Type {
		if _dc.Type == ResultTypeArray {
			if !_eab(_dc.ValueArray, _bb.ValueArray) {
				return MakeErrorResult("l\u0068\u0073\u002f\u0072\u0068\u0073 \u0073\u0068\u006f\u0075\u006c\u0064 \u0068\u0061\u0076\u0065\u0020\u0073\u0061m\u0065\u0020\u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006fn\u0073")
			}
			return _cc(_dec._dee, _dc.ValueArray, _bb.ValueArray)
		} else if _dc.Type == ResultTypeList {
			if len(_dc.ValueList) != len(_bb.ValueList) {
				return MakeErrorResult("l\u0068\u0073\u002f\u0072\u0068\u0073 \u0073\u0068\u006f\u0075\u006c\u0064 \u0068\u0061\u0076\u0065\u0020\u0073\u0061m\u0065\u0020\u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006fn\u0073")
			}
			return _cbg(_dec._dee, _dc.ValueList, _bb.ValueList)
		}
	} else if _dc.Type == ResultTypeArray && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
		return _cbgf(_dec._dee, _dc.ValueArray, _bb)
	} else if _dc.Type == ResultTypeList && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
		return _gfd(_dec._dee, _dc.ValueList, _bb)
	}
	switch _dec._dee {
	case BinOpTypePlus:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeNumberResult(_dc.ValueNumber + _bb.ValueNumber)
			}
		}
	case BinOpTypeMinus:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeNumberResult(_dc.ValueNumber - _bb.ValueNumber)
			}
		}
	case BinOpTypeMult:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeNumberResult(_dc.ValueNumber * _bb.ValueNumber)
			}
		}
	case BinOpTypeDiv:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				if _bb.ValueNumber == 0 {
					return MakeErrorResultType(ErrorTypeDivideByZero, "\u0064\u0069\u0076\u0069\u0064\u0065\u0020\u0062\u0079 \u007a\u0065\u0072\u006f")
				}
				return MakeNumberResult(_dc.ValueNumber / _bb.ValueNumber)
			}
		}
	case BinOpTypeExp:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeNumberResult(_gfc.Pow(_dc.ValueNumber, _bb.ValueNumber))
			}
		}
	case BinOpTypeLT:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeBoolResult(_dc.ValueNumber < _bb.ValueNumber)
			}
			if _dc.Type == ResultTypeString {
				return MakeBoolResult(_dc.ValueString < _bb.ValueString)
			}
			if _dc.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if _dc.Type == ResultTypeString && _bb.Type == ResultTypeNumber {
			return MakeBoolResult(false)
		} else if _dc.Type == ResultTypeNumber && _bb.Type == ResultTypeString {
			return MakeBoolResult(true)
		} else if _dc.Type == ResultTypeEmpty && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
			return MakeBoolResult(true)
		} else if (_dc.Type == ResultTypeNumber || _dc.Type == ResultTypeString) && _bb.Type == ResultTypeEmpty {
			return MakeBoolResult(false)
		}
	case BinOpTypeGT:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeBoolResult(_dc.ValueNumber > _bb.ValueNumber)
			}
			if _dc.Type == ResultTypeString {
				return MakeBoolResult(_dc.ValueString > _bb.ValueString)
			}
			if _dc.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if _dc.Type == ResultTypeString && _bb.Type == ResultTypeNumber {
			return MakeBoolResult(true)
		} else if _dc.Type == ResultTypeNumber && _bb.Type == ResultTypeString {
			return MakeBoolResult(false)
		} else if _dc.Type == ResultTypeEmpty && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
			return MakeBoolResult(false)
		} else if (_dc.Type == ResultTypeNumber || _dc.Type == ResultTypeString) && _bb.Type == ResultTypeEmpty {
			return MakeBoolResult(true)
		}
	case BinOpTypeEQ:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeBoolResult(_dc.ValueNumber == _bb.ValueNumber)
			}
			if _dc.Type == ResultTypeString {
				return MakeBoolResult(_dc.ValueString == _bb.ValueString)
			}
			if _dc.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if (_dc.Type == ResultTypeString && _bb.Type == ResultTypeNumber) || (_dc.Type == ResultTypeNumber && _bb.Type == ResultTypeString) {
			return MakeBoolResult(false)
		} else if _dc.Type == ResultTypeEmpty && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
			return MakeBoolResult(_fbf(_bb))
		} else if (_dc.Type == ResultTypeNumber || _dc.Type == ResultTypeString) && _bb.Type == ResultTypeEmpty {
			return MakeBoolResult(_fbf(_dc))
		}
	case BinOpTypeNE:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeBoolResult(_dc.ValueNumber != _bb.ValueNumber)
			}
			if _dc.Type == ResultTypeString {
				return MakeBoolResult(_dc.ValueString != _bb.ValueString)
			}
			if _dc.Type == ResultTypeEmpty {
				return MakeBoolResult(false)
			}
		} else if (_dc.Type == ResultTypeString && _bb.Type == ResultTypeNumber) || (_dc.Type == ResultTypeNumber && _bb.Type == ResultTypeString) {
			return MakeBoolResult(true)
		} else if _dc.Type == ResultTypeEmpty && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
			return MakeBoolResult(!_fbf(_bb))
		} else if (_dc.Type == ResultTypeNumber || _dc.Type == ResultTypeString) && _bb.Type == ResultTypeEmpty {
			return MakeBoolResult(!_fbf(_dc))
		}
	case BinOpTypeLEQ:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeBoolResult(_dc.ValueNumber <= _bb.ValueNumber)
			}
			if _dc.Type == ResultTypeString {
				return MakeBoolResult(_dc.ValueString <= _bb.ValueString)
			}
			if _dc.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if _dc.Type == ResultTypeString && _bb.Type == ResultTypeNumber {
			return MakeBoolResult(false)
		} else if _dc.Type == ResultTypeNumber && _bb.Type == ResultTypeString {
			return MakeBoolResult(true)
		} else if _dc.Type == ResultTypeEmpty && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
			return MakeBoolResult(_fbf(_bb))
		} else if (_dc.Type == ResultTypeNumber || _dc.Type == ResultTypeString) && _bb.Type == ResultTypeEmpty {
			return MakeBoolResult(_fbf(_dc))
		}
	case BinOpTypeGEQ:
		if _dc.Type == _bb.Type {
			if _dc.Type == ResultTypeNumber {
				return MakeBoolResult(_dc.ValueNumber >= _bb.ValueNumber)
			}
			if _dc.Type == ResultTypeString {
				return MakeBoolResult(_dc.ValueString >= _bb.ValueString)
			}
			if _dc.Type == ResultTypeEmpty {
				return MakeBoolResult(true)
			}
		} else if _dc.Type == ResultTypeString && _bb.Type == ResultTypeNumber {
			return MakeBoolResult(true)
		} else if _dc.Type == ResultTypeNumber && _bb.Type == ResultTypeString {
			return MakeBoolResult(false)
		} else if _dc.Type == ResultTypeEmpty && (_bb.Type == ResultTypeNumber || _bb.Type == ResultTypeString) {
			return MakeBoolResult(_fbf(_bb))
		} else if (_dc.Type == ResultTypeNumber || _dc.Type == ResultTypeString) && _bb.Type == ResultTypeEmpty {
			return MakeBoolResult(_fbf(_dc))
		}
	case BinOpTypeConcat:
		return MakeStringResult(_dc.Value() + _bb.Value())
	}
	return MakeErrorResult("u\u006e\u0073\u0075\u0070po\u0072t\u0065\u0064\u0020\u0062\u0069n\u0061\u0072\u0079\u0020\u006f\u0070")
}

// Char is an implementation of the Excel CHAR function that takes an integer in
// the range [0,255] and returns the corresponding ASCII character.
func Char(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_gfcd := args[0].AsNumber()
	if _gfcd.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043\u0048\u0041\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0061\u0020\u0073\u0069\u006e\u0067l\u0065\u0020\u006e\u0075\u006d\u0065\u0072\u0069\u0063\u0020\u0061\u0072\u0067u\u006d\u0065\u006e\u0074")
	}
	_eabfa := int(_gfcd.ValueNumber)
	if _eabfa < 0 || _eabfa > 255 {
		return MakeErrorResult("\u0043H\u0041\u0052 \u0072\u0065\u0071\u0075i\u0072\u0065\u0073 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073 i\u006e\u0020\u0074h\u0065\u0020r\u0061\u006e\u0067\u0065\u0020\u005b0\u002c\u00325\u0035\u005d")
	}
	return MakeStringResult(_c.Sprintf("\u0025\u0063", _eabfa))
}
func _fbefg() yyParser { return &yyParserImpl{} }
func _efcge(_fdad, _dacgd float64) float64 {
	_fdad = _gfc.Trunc(_fdad)
	_dacgd = _gfc.Trunc(_dacgd)
	if _fdad == 0 {
		return _dacgd
	}
	if _dacgd == 0 {
		return _fdad
	}
	for _fdad != _dacgd {
		if _fdad > _dacgd {
			_fdad = _fdad - _dacgd
		} else {
			_dacgd = _dacgd - _fdad
		}
	}
	return _fdad
}

const _aedac = 57344

// Eval evaluates and returns the result of the cell reference.
func (_dac CellRef) Eval(ctx Context, ev Evaluator) Result { return ctx.Cell(_dac._acb, ev) }

const _deggf = 57359

var _dgcd = false

// MakeBoolResult constructs a boolean result (internally a number).
func MakeBoolResult(b bool) Result {
	if b {
		return Result{Type: ResultTypeNumber, ValueNumber: 1, IsBoolean: true}
	}
	return Result{Type: ResultTypeNumber, ValueNumber: 0, IsBoolean: true}
}

// Searchb is an implementation of the Excel SEARCHB().
func Searchb(ctx Context, ev Evaluator, args []Result) Result {
	if !ctx.IsDBCS() {
		return Search(args)
	}
	_cede, _eccf := _bege("\u0046\u0049\u004e\u0044", args)
	if _eccf.Type != ResultTypeEmpty {
		return _eccf
	}
	_edgb := _gg.ToLower(_cede._ebda)
	_aggeb := _gg.ToLower(_cede._effb)
	if _edgb == "" {
		return MakeNumberResult(1.0)
	}
	_egfbd := _cede._cbec - 1
	_bcdcd := 1
	_gfbea := 0
	for _ccegf := range _aggeb {
		if _ccegf != 0 {
			_daca := 1
			if _ccegf-_gfbea > 1 {
				_daca = 2
			}
			_bcdcd += _daca
		}
		if _bcdcd > _egfbd {
			_bfbd := _ce.Index(_edgb, _aggeb[_ccegf:])
			if _bfbd == 0 {
				return MakeNumberResult(float64(_bcdcd))
			}
		}
		_gfbea = _ccegf
	}
	return MakeErrorResultType(ErrorTypeValue, "\u004eo\u0074\u0020\u0066\u006f\u0075\u006ed")
}

var _gaef Result = MakeEmptyResult()

func _ebc(_fef, _ccbe int) int {
	if _ccbe == 2 && _acec(_fef) {
		return 29
	} else {
		return _ec[_ccbe-1]
	}
}

// NewEvaluator constructs a new defEval object which is the default formula evaluator.
func NewEvaluator() Evaluator { _agde := &defEval{}; _agde.evCache = _dde(); return _agde }

// NewVerticalRange constructs a new full columns range.
func NewVerticalRange(v string) Expression {
	_cagcf := _gg.Split(v, "\u003a")
	if len(_cagcf) != 2 {
		return nil
	}
	if _cagcf[0] > _cagcf[1] {
		_cagcf[0], _cagcf[1] = _cagcf[1], _cagcf[0]
	}
	return VerticalRange{_dcac: _cagcf[0], _ddef: _cagcf[1]}
}
func _gfea(_efge, _bdgg, _ggba int) float64 {
	return float64(_fca(_efge, _d.Month(_bdgg), _ggba)/86400) + _aagg
}
func _aggbb(_cffd, _bcd, _acf, _gccd, _cdf float64, _fgceg int) Result {
	_fbcc, _deg := _fbabb(_cffd, _bcd, _fgceg)
	if _deg.Type == ResultTypeError {
		return _deg
	}
	_fdeg, _gfdd := _dbbg(_cffd, _bcd, int(_cdf), _fgceg)
	if _gfdd.Type == ResultTypeError {
		return _gfdd
	}
	_bfc := 0.0
	_adfde := 0.0
	_acf *= 100 / _cdf
	_gccd /= _cdf
	_gccd++
	_gcad := _fbcc*_cdf - _fdeg
	for _bef := 1.0; _bef < _fdeg; _bef++ {
		_dfdd := _bef + _gcad
		_ebab := _acf / _gfc.Pow(_gccd, _dfdd)
		_adfde += _ebab
		_bfc += _dfdd * _ebab
	}
	_ade := (_acf + 100) / _gfc.Pow(_gccd, _fdeg+_gcad)
	_adfde += _ade
	_bfc += (_fdeg + _gcad) * _ade
	_bfc /= _adfde
	_bfc /= _cdf
	return MakeNumberResult(_bfc)
}

// Eval evaluates a range with prefix returning a list of results or an error.
func (_addfd PrefixRangeExpr) Eval(ctx Context, ev Evaluator) Result {
	_dfbge := _addfd._gfdcf.Reference(ctx, ev)
	_ccabf := _addfd._cbcgb.Reference(ctx, ev)
	_fddfd := _addfd._fece.Reference(ctx, ev)
	switch _dfbge.Type {
	case ReferenceTypeSheet:
		if _fggd(_dfbge, ctx) {
			return MakeErrorResultType(ErrorTypeName, _c.Sprintf("\u0053h\u0065e\u0074\u0020\u0025\u0073\u0020n\u006f\u0074 \u0066\u006f\u0075\u006e\u0064", _dfbge.Value))
		}
		_gdege := _cegd(_dfbge, _ccabf, _fddfd)
		if _ccabf.Type == ReferenceTypeCell && _fddfd.Type == ReferenceTypeCell {
			if _cdfd, _eegde := ev.GetFromCache(_gdege); _eegde {
				return _cdfd
			} else {
				_ddabbd := _efagg(ctx.Sheet(_dfbge.Value), ev, _ccabf.Value, _fddfd.Value)
				ev.SetCache(_gdege, _ddabbd)
				return _ddabbd
			}
		}
		return MakeErrorResult("\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0072a\u006e\u0067\u0065\u0020" + _gdege)
	default:
		return MakeErrorResult(_c.Sprintf("\u006e\u006f\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0020\u0066\u006f\u0072\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0074\u0079\u0070\u0065\u0020\u0025\u0073", _dfbge.Type))
	}
}

var _dfbff []byte = []byte{0, 1, 2, 1, 11, 1, 12, 1, 13, 1, 14, 1, 15, 1, 16, 1, 17, 1, 18, 1, 19, 1, 20, 1, 21, 1, 22, 1, 23, 1, 24, 1, 25, 1, 26, 1, 27, 1, 28, 1, 29, 1, 30, 1, 31, 1, 32, 1, 33, 1, 34, 1, 35, 1, 36, 1, 37, 1, 38, 1, 39, 1, 40, 1, 41, 1, 42, 1, 43, 2, 0, 1, 2, 3, 4, 2, 3, 5, 2, 3, 6, 2, 3, 7, 2, 3, 8, 2, 3, 9, 2, 3, 10}

func _eagc(_gaac, _cgff float64, _cfbcf, _ded int) float64 {
	_eaba := _eeec(_gaac)
	_cefc := _eeec(_cgff)
	if _ded == 1 {
		_faef := _afa(_eaba, _cefc, _cfbcf, 1)
		_ccf := _faef.AddDate(0, 12/_cfbcf, 0)
		return _ddeg(_faef, _ccf, _ded)
	}
	return float64(_bbefe(0, _ded)) / float64(_cfbcf)
}

// Cell is an implementation of the Excel CELL function that returns information
// about the formatting, location, or contents of a cell.
func Cell(ctx Context, ev Evaluator, args []Result) Result {
	if len(args) != 1 && len(args) != 2 {
		return MakeErrorResult("\u0043\u0045\u004cL \u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_fgda := args[0].AsString()
	if _fgda.Type != ResultTypeString {
		return MakeErrorResult("\u0043\u0045\u004c\u004c\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0069\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065 \u0073t\u0072\u0069\u006e\u0067")
	}
	_gfcaa := "\u0041\u0031"
	if len(args) == 2 {
		_befc := args[1].Ref
		if _befc.Type != ReferenceTypeCell {
			return MakeErrorResult("\u0043\u0045\u004c\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0073\u0065\u0063\u006f\u006e\u0064 \u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006f\u0066\u0020\u0074\u0079p\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065")
		}
		_gfcaa = _befc.Value
	}
	switch _fgda.ValueString {
	case "\u0061d\u0064\u0072\u0065\u0073\u0073":
		_dgda, _aabc := _ee.ParseCellReference(_gfcaa)
		if _aabc != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _gfcaa)
		}
		_fadd := "\u0024" + _dgda.Column + "\u0024" + _ff.Itoa(int(_dgda.RowIdx))
		if _dgda.SheetName != "" {
			_fadd = _dgda.SheetName + "\u0021" + _fadd
		}
		return MakeStringResult(_fadd)
	case "\u0063\u006f\u006c":
		_cfbg, _feffc := _ee.ParseCellReference(_gfcaa)
		if _feffc != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _gfcaa)
		}
		return MakeNumberResult(float64(_cfbg.ColumnIdx + 1))
	case "\u0063\u006f\u006co\u0072":
		_cgac := _gg.Contains(ctx.GetFormat(_gfcaa), "\u005b\u0052\u0045D\u005d")
		return MakeBoolResult(_cgac)
	case "\u0063\u006f\u006e\u0074\u0065\u006e\u0074\u0073":
		return args[1]
	case "\u0066\u0069\u006c\u0065\u006e\u0061\u006d\u0065":
		return MakeStringResult(ctx.GetFilename())
	case "\u0066\u006f\u0072\u006d\u0061\u0074":
		_bcgb := "\u0047"
		_abgeb := ctx.GetFormat(_gfcaa)
		if _abgeb == "\u0047e\u006e\u0065\u0072\u0061\u006c" || _eedd.MatchString(_abgeb) {
			_bcgb = "\u0046\u0030"
		} else if _abgeb == "\u0030\u0025" {
			_bcgb = "\u0050\u0030"
		} else if _abgeb == "\u004d\u004d\u004d\u0020\u0044\u0044" {
			_bcgb = "\u0044\u0032"
		} else if _abgeb == "\u004d\u004d\u002fY\u0059" {
			_bcgb = "\u0044\u0033"
		} else if _abgeb == "\u004d\u004d\u002f\u0044D/\u0059\u0059\u005c\u0020\u0048\u0048\u003a\u004d\u004d\u005c\u0020\u0041\u004d\u002fP\u004d" || _abgeb == "M\u004d/\u0044\u0044\u002f\u0059\u0059\u0059\u0059\u005c \u0048\u0048\u003a\u004dM:\u0053\u0053" {
			_bcgb = "\u0044\u0034"
		} else if _abgeb == "\u004d\u004d\u005c\u002d\u0044\u0044" {
			_bcgb = "\u0044\u0035"
		} else if _abgeb == "\u0048H\u003aM\u004d\u003a\u0053\u0053\u005c\u0020\u0041\u004d\u002f\u0050\u004d" {
			_bcgb = "\u0044\u0036"
		} else if _abgeb == "\u0048\u0048\u003aM\u004d\u005c\u0020\u0041\u004d\u002f\u0050\u004d" {
			_bcgb = "\u0044\u0037"
		} else if _abgeb == "\u0048\u0048\u003a\u004d\u004d\u003a\u0053\u0053" {
			_bcgb = "\u0044\u0038"
		} else if _abgeb == "\u0048\u0048\u003aM\u004d" {
			_bcgb = "\u0044\u0039"
		} else if _aafg.MatchString(_abgeb) {
			_bcgb = "\u002e\u0030"
		} else if _cdce.MatchString(_abgeb) {
			_bcgb = "\u002e\u0030\u0028\u0029"
		} else if _edcb.MatchString(_abgeb) {
			_bcgb = "\u0043\u0030"
		} else if _ddce.MatchString(_abgeb) || _bcfb.MatchString(_abgeb) {
			_bcgb = "\u0044\u0031"
		} else if _badd := _dedac.FindStringSubmatch(_abgeb); len(_badd) > 1 {
			_bcgb = "\u0046" + _ff.Itoa(len(_badd[1]))
		} else if _fgcg := _eccc.FindStringSubmatch(_abgeb); len(_fgcg) > 1 {
			_bcgb = "\u002e" + _ff.Itoa(len(_fgcg[2]))
		} else if _dffe := _ddfad.FindStringSubmatch(_abgeb); len(_dffe) > 1 {
			_bcgb = "\u0050" + _ff.Itoa(len(_dffe[2]))
		} else if _fcdg := _agdbg.FindStringSubmatch(_abgeb); len(_fcdg) > 1 {
			_bcgb = "\u0043" + _eadg(_fcdg, 1)
		} else if _fgac := _egff.FindStringSubmatch(_abgeb); len(_fgac) > 1 {
			_bcgb = "\u0043" + _eadg(_fgac, 1)
		} else if _abggg := _afbf.FindStringSubmatch(_abgeb); len(_abggg) > 1 {
			_bcgb = "\u002e" + _eadg(_abggg, 1) + "\u0028\u0029"
		} else if _edafa := _ggee.FindStringSubmatch(_abgeb); len(_edafa) > 1 {
			_bcgb = "\u002e" + _eadg(_edafa, 1)
		} else if _aafeb := _bbdf.FindStringSubmatch(_abgeb); len(_aafeb) > 1 {
			_bcgb = "\u0053" + _eadg(_aafeb, 3)
		}
		if _bcgb != "\u0047" && _gg.Contains(_abgeb, "\u005b\u0052\u0045D\u005d") {
			_bcgb += "\u002d"
		}
		return MakeStringResult(_bcgb)
	case "p\u0061\u0072\u0065\u006e\u0074\u0068\u0065\u0073\u0065\u0073":
		_edag := ctx.GetFormat(_gfcaa)
		if _eaga.MatchString(_edag) {
			return MakeNumberResult(1)
		} else {
			return MakeNumberResult(0)
		}
	case "\u0070\u0072\u0065\u0066\u0069\u0078":
		return MakeStringResult(ctx.GetLabelPrefix(_gfcaa))
	case "\u0070r\u006f\u0074\u0065\u0063\u0074":
		_gabbf := 0.0
		if ctx.GetLocked(_gfcaa) {
			_gabbf = 1.0
		}
		return MakeNumberResult(_gabbf)
	case "\u0072\u006f\u0077":
		_bddg, _dcfag := _ee.ParseCellReference(_gfcaa)
		if _dcfag != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _gfcaa)
		}
		return MakeNumberResult(float64(_bddg.RowIdx))
	case "\u0074\u0079\u0070\u0065":
		switch args[1].Type {
		case ResultTypeEmpty:
			return MakeStringResult("\u0062")
		case ResultTypeString:
			return MakeStringResult("\u006c")
		default:
			return MakeStringResult("\u0076")
		}
	case "\u0077\u0069\u0064t\u0068":
		_gfag, _gdeag := _ee.ParseCellReference(_gfcaa)
		if _gdeag != nil {
			return MakeErrorResult("I\u006e\u0063\u006f\u0072re\u0063t\u0020\u0072\u0065\u0066\u0065r\u0065\u006e\u0063\u0065\u003a\u0020" + _gfcaa)
		}
		if _gfag.SheetName == "" {
			return MakeNumberResult(ctx.GetWidth(int(_gfag.ColumnIdx)))
		} else {
			return MakeNumberResult(ctx.Sheet(_gfag.SheetName).GetWidth(int(_gfag.ColumnIdx)))
		}
	}
	return MakeErrorResult("\u0049\u006e\u0063or\u0072\u0065\u0063\u0074\u0020\u0066\u0069\u0072\u0073t\u0020a\u0072g\u0075m\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0043\u0045\u004c\u004c\u003a\u0020" + _fgda.ValueString)
}

// Nominal implements the Excel NOMINAL function.
func Nominal(args []Result) Result {
	if len(args) != 2 {
		return MakeErrorResult("\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073\u0020\u0074w\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeNumber {
		return MakeErrorResult("NO\u004d\u0049N\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006e\u006f\u006d\u0069\u006e\u0061\u006c\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062e\u0020n\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072g\u0075m\u0065\u006et")
	}
	_acaa := args[0].ValueNumber
	if _acaa <= 0 {
		return MakeErrorResultType(ErrorTypeNum, "\u004e\u004fM\u0049\u004e\u0041\u004c\u0020r\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u0065\u0066\u0066\u0065\u0063\u0074\u0020\u0069\u006e\u0074\u0065\u0072\u0065\u0073\u0074\u0020\u0072\u0061\u0074\u0065\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065")
	}
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006e\u0075\u006db\u0065\u0072\u0020\u006f\u0066\u0020\u0063\u006f\u006d\u0070\u006f\u0075\u006e\u0064\u0069\u006e\u0067\u0020\u0070\u0065\u0072i\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fbea := float64(int(args[1].ValueNumber))
	if _fbea < 1 {
		return MakeErrorResultType(ErrorTypeNum, "\u004e\u004f\u004d\u0049\u004e\u0041\u004c\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u006eum\u0062e\u0072\u0020\u006f\u0066\u0020\u0063\u006f\u006d\u0070\u006f\u0075\u006ed\u0069\u006e\u0067\u0020\u0070\u0065\u0072\u0069\u006f\u0064\u0073\u0020\u0074\u006f\u0020\u0062\u0065 \u0031\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065")
	}
	return MakeNumberResult((_gfc.Pow(_acaa+1, 1/_fbea) - 1) * _fbea)
}

var _cddcg = map[string]bool{"\u0049F\u0045\u0052\u0052\u004f\u0052": true, "\u0049\u0046\u004e\u0041": true, "\u005f\u0078\u006c\u0066\u006e\u002e\u0049\u0046\u004e\u0041": true, "\u0049\u0053\u0045R\u0052": true, "\u0049S\u0045\u0052\u0052\u004f\u0052": true, "\u0049\u0053\u004e\u0041": true, "\u0049\u0053\u0052E\u0046": true}

func _eaaf(_cgcfb int) string {
	if _cgcfb >= 0 && _cgcfb < len(_cgfab) {
		if _cgfab[_cgcfb] != "" {
			return _cgfab[_cgcfb]
		}
	}
	return _c.Sprintf("\u0073\u0074\u0061\u0074\u0065\u002d\u0025\u0076", _cgcfb)
}

// Value returns a string version of the result.
func (_aecfg Result) Value() string {
	switch _aecfg.Type {
	case ResultTypeNumber:
		_defaf := _ff.FormatFloat(_aecfg.ValueNumber, 'f', -1, 64)
		if len(_defaf) > 12 {
			_bbcc := 12
			for _eddca := _bbcc; _eddca > 0 && _defaf[_eddca] == '0'; _eddca-- {
				_bbcc--
			}
			_defaf = _defaf[0 : _bbcc+1]
		}
		return _defaf
	case ResultTypeError:
		return _aecfg.ValueString
	case ResultTypeString:
		return _aecfg.ValueString
	case ResultTypeList:
		if len(_aecfg.ValueList) == 0 {
			return ""
		}
		return _aecfg.ValueList[0].Value()
	case ResultTypeArray:
		if len(_aecfg.ValueArray) == 0 || len(_aecfg.ValueArray[0]) == 0 {
			return ""
		}
		return _aecfg.ValueArray[0][0].Value()
	case ResultTypeEmpty:
		return ""
	default:
		return "\u0075\u006e\u0068\u0061nd\u006c\u0065\u0064\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0020\u0076\u0061\u006cu\u0065"
	}
}

// SumProduct is an implementation of the Excel SUMPRODUCT() function.
func SumProduct(args []Result) Result {
	if len(args) == 0 {
		return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004f\u0044U\u0043\u0054\u0028)\u0020\u0072\u0065\u0071u\u0069\u0072\u0065\u0073\u0020\u0061\u0074\u0020\u006c\u0065\u0061\u0073\u0074\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	_fgdd := args[0].Type
	for _, _accgg := range args {
		if _accgg.Type != _fgdd {
			return MakeErrorResult("\u0053\u0055M\u0050\u0052\u004f\u0044\u0055C\u0054\u0028\u0029\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006c\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u006f\u0066\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065\u0020\u0074\u0079\u0070\u0065")
		}
	}
	switch _fgdd {
	case ResultTypeNumber:
		return Product(args)
	case ResultTypeList, ResultTypeArray:
		_ddgc := len(args[0].ListValues())
		_bbecg := make([]float64, _ddgc)
		for _accgb := range _bbecg {
			_bbecg[_accgb] = 1.0
		}
		for _, _afgf := range args {
			if len(_afgf.ListValues()) != _ddgc {
				return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004f\u0044\u0055\u0043\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069re\u0073 \u0061\u006c\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074s\u0020\u0074\u006f\u0020\u0068\u0061\u0076\u0065\u0020\u0074\u0068\u0065\u0020\u0073\u0061\u006d\u0065 \u0064\u0069\u006d\u0065\u006e\u0073\u0069\u006f\u006e")
			}
			for _badce, _gdeee := range _afgf.ListValues() {
				_gdeee = _gdeee.AsNumber()
				if _gdeee.Type != ResultTypeNumber {
					return MakeErrorResult("\u0053\u0055\u004d\u0050\u0052\u004fD\u0055\u0043\u0054\u0028\u0029\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u006c\u006c\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0073\u0020\u0074\u006f\u0020\u0062\u0065\u0020n\u0075m\u0065\u0072\u0069\u0063")
				}
				_bbecg[_badce] = _bbecg[_badce] * _gdeee.ValueNumber
			}
		}
		_ecdca := 0.0
		for _, _dcbdd := range _bbecg {
			_ecdca += _dcbdd
		}
		return MakeNumberResult(_ecdca)
	}
	return MakeNumberResult(1.0)
}

// RegisterFunction registers a standard function.
func RegisterFunction(name string, fn Function) {
	_eadgg.Lock()
	defer _eadgg.Unlock()
	if _, _afff := _bfgfa[name]; _afff {
		_ga.Log.Debug("\u0064\u0075p\u006c\u0069\u0063\u0061t\u0065\u0020r\u0065\u0067\u0069\u0073\u0074\u0072\u0061\u0074i\u006f\u006e\u0020\u006f\u0066\u0020\u0066\u0075\u006e\u0063\u0074\u0069o\u006e\u0020\u0025\u0073", name)
	}
	_bfgfa[name] = fn
}
func _eeec(_acea float64) _d.Time {
	_debd := int64((_acea - _aagg) * _baac)
	return _d.Unix(0, _debd).UTC()
}

const _ddf = _d.Second * 1

// TextJoin is an implementation of the Excel TEXTJOIN function.
func TextJoin(args []Result) Result {
	if len(args) < 3 {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u004aO\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074h\u0072\u0065\u0065\u0020\u006f\u0072\u0020\u006d\u006f\u0072\u0065\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type != ResultTypeString {
		return MakeErrorResult("\u0054\u0045\u0058T\u004a\u004f\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0064\u0065\u006c\u0069\u006d\u0069\u0074\u0065\u0072\u0020\u0074\u006f\u0020\u0062\u0065 \u0061\u0020\u0073\u0074\u0072\u0069\u006e\u0067")
	}
	_ddedc := args[0].ValueString
	if args[1].Type != ResultTypeNumber {
		return MakeErrorResult("\u0054\u0045\u0058\u0054\u004a\u004f\u0049\u004e\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0073\u0065c\u006f\u006e\u0064\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0074\u006f\u0020\u0062\u0065\u0020\u0061\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u006f\u0072 \u0062\u006f\u006f\u006c\u0065a\u006e")
	}
	_bcbg := args[1].ValueNumber != 0
	_dgfb := _gcabd(args[2:], []string{}, _bcbg)
	return MakeStringResult(_gg.Join(_dgfb, _ddedc))
}

var _adfcc []byte = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

// Error is an error expression.
type Error struct{ _cbgb string }

// NewBool constructs a new boolean expression.
func NewBool(v string) Expression {
	_bbb, _dbbc := _ff.ParseBool(v)
	if _dbbc != nil {
		_ga.Log.Debug("\u0065\u0072\u0072\u006f\u0072\u0020p\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0066\u006f\u0072\u006d\u0075\u006ca\u0020\u0062\u006f\u006f\u006c\u0020\u0025s\u003a\u0020\u0025\u0076", v, _dbbc)
	}
	return Bool{_fgg: _bbb}
}

// Range is a range expression that when evaluated returns a list of Results.
type Range struct{ _efbed, _abfd Expression }

const _dfca = "\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070\u0065\u0049\u006e\u0076\u0061\u006c\u0069\u0064\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054\u0079\u0070\u0065\u0043\u0065\u006c\u006c\u0052\u0065\u0066\u0065r\u0065\u006ec\u0065\u0054\u0079\u0070e\u004e\u0061\u006d\u0065\u0064\u0052\u0061\u006e\u0067\u0065R\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0054y\u0070\u0065\u0052\u0061\u006e\u0067\u0065\u0052\u0065\u0066e\u0072\u0065\u006ec\u0065\u0054\u0079\u0070\u0065\u0053\u0068e\u0065\u0074"

func _babe() {
	_adeeb = _ed.MustCompile("\u005e\u0028\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u0024")
	_bcagb = _ed.MustCompile("\u005e=\u0028\u002e\u002a\u0029\u0024")
	_ffaa = _ed.MustCompile("\u005e<\u0028\u002e\u002a\u0029\u0024")
	_gbab = _ed.MustCompile("\u005e>\u0028\u002e\u002a\u0029\u0024")
	_bcda = _ed.MustCompile("\u005e\u003c\u003d\u0028\u002e\u002a\u0029\u0024")
	_gfaeg = _ed.MustCompile("\u005e\u003e\u003d\u0028\u002e\u002a\u0029\u0024")
}
func _abda(_aefe Result, _ccgce int) []Result {
	_gbeag := []Result{}
	switch _aefe.Type {
	case ResultTypeList:
		_eedc := _aefe.ValueList
		_ddbf := len(_eedc)
		for _gaded := 0; _gaded < _ccgce; _gaded++ {
			if _gaded < _ddbf {
				_gbeag = append(_gbeag, _eedc[_gaded])
			} else {
				_gbeag = append(_gbeag, MakeErrorResultType(ErrorTypeNA, ""))
			}
		}
	case ResultTypeNumber, ResultTypeString, ResultTypeError, ResultTypeEmpty:
		for _afgca := 0; _afgca < _ccgce; _afgca++ {
			_gbeag = append(_gbeag, _aefe)
		}
	}
	return _gbeag
}

const _gdeeee = 57375

func _bgbac(_bfaa, _ffg _d.Time) bool {
	_dade := _bfaa.Unix()
	_dbg := _ffg.Unix()
	_cbe := _bfaa.Year()
	_bda := _fca(_cbe, _d.March, 1)
	if _acec(_cbe) && _dade < _bda && _dbg >= _bda {
		return true
	}
	var _ccegb = _ffg.Year()
	var _cfa = _fca(_ccegb, _d.March, 1)
	return (_acec(_ccegb) && _dbg >= _cfa && _dade < _cfa)
}

// Update returns the same object as updating sheet references does not affect named ranges.
func (_dccdf NamedRangeRef) Update(q *_de.UpdateQuery) Expression { return _dccdf }

// Day is an implementation of the Excel DAY() function.
func Day(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0044A\u0059\u0020\u0072\u0065q\u0075\u0069\u0072\u0065\u0073 \u006fn\u0065 \u0061\u0072\u0067\u0075\u006d\u0065\u006et")
	}
	_caa := args[0]
	switch _caa.Type {
	case ResultTypeEmpty:
		return MakeNumberResult(0)
	case ResultTypeNumber:
		_baa := _eeec(_caa.ValueNumber)
		return MakeNumberResult(float64(_baa.Day()))
	case ResultTypeString:
		_cbge := _gg.ToLower(_caa.ValueString)
		if !_cef(_cbge) {
			_, _, _, _, _bbba, _cbga := _cefg(_cbge)
			if _cbga.Type == ResultTypeError {
				_cbga.ErrorMessage = "I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006et\u0073\u0020\u0066o\u0072 \u0044\u0041\u0059"
				return _cbga
			}
			if _bbba {
				return MakeNumberResult(0)
			}
		}
		_, _, _bfe, _, _adf := _agda(_cbge)
		if _adf.Type == ResultTypeError {
			return _adf
		}
		return MakeNumberResult(float64(_bfe))
	default:
		return MakeErrorResult("\u0049\u006e\u0063\u006f\u0072\u0072\u0065\u0063\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u0066\u006f\u0072 \u0044\u0041\u0059")
	}
}

const _afec = 57358

// String returns a string representation of PrefixExpr.
func (_faddc PrefixExpr) String() string {
	return _c.Sprintf("\u0025\u0073\u0021%\u0073", _faddc._dcfga.String(), _faddc._bcbe.String())
}

// Proper is an implementation of the Excel PROPER function that returns a copy
// of the string with each word capitalized.
func Proper(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("P\u0052\u004f\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006eg \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_gcaa := args[0].AsString()
	if _gcaa.Type != ResultTypeString {
		return MakeErrorResult("P\u0052\u004f\u0050\u0045\u0052\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0061\u0020\u0073i\u006e\u0067\u006c\u0065\u0020\u0073\u0074\u0072\u0069\u006eg \u0061\u0072\u0067u\u006de\u006e\u0074")
	}
	_gafb := _gb.Buffer{}
	_fabf := false
	for _, _daac := range _gcaa.ValueString {
		if !_fabf && _ea.IsLetter(_daac) {
			_gafb.WriteRune(_ea.ToUpper(_daac))
		} else {
			_gafb.WriteRune(_ea.ToLower(_daac))
		}
		_fabf = _ea.IsLetter(_daac)
	}
	return MakeStringResult(_gafb.String())
}

const _bdcb = 57364

func _dbad(_agbc, _accg _d.Time, _caff int) _d.Time {
	_gggg := _d.Date(_agbc.Year(), _accg.Month(), _accg.Day(), 0, 0, 0, 0, _d.UTC)
	if _gggg.After(_agbc) {
		_gggg = _gggg.AddDate(-1, 0, 0)
	}
	for !_gggg.After(_agbc) {
		_gggg = _gggg.AddDate(0, 12/_caff, 0)
	}
	return _gggg
}

// Reference returns a string reference value to a range.
func (_egeac Range) Reference(ctx Context, ev Evaluator) Reference {
	_dccac := _egeac._efbed.Reference(ctx, ev)
	_cebbc := _egeac._abfd.Reference(ctx, ev)
	if _dccac.Type == ReferenceTypeCell && _cebbc.Type == ReferenceTypeCell {
		return MakeRangeReference(_ffdga(_dccac, _cebbc))
	}
	return ReferenceInvalid
}

type Reference struct {
	Type  ReferenceType
	Value string
}

// SumIfs implements the SUMIFS function.
func SumIfs(args []Result) Result {
	_eebee := _dcfg(args, true, "\u0053\u0055\u004d\u0049\u0046\u0053")
	if _eebee.Type != ResultTypeEmpty {
		return _eebee
	}
	_cgadc := _gcae(args[1:])
	_dfab := 0.0
	_cgda := _bbcd(args[0])
	for _, _decd := range _cgadc {
		_dfab += _cgda[_decd._gefg][_decd._facdg].ValueNumber
	}
	return MakeNumberResult(float64(_dfab))
}

const _ace = "\u0028(\u005b0\u002d\u0039\u005d\u0029\u002b)\u0020\u0028a\u006d\u007c\u0070\u006d\u0029"

var _cgfe = [...]int{0}

// IsNA is an implementation of the Excel ISNA() function.
func IsNA(args []Result) Result {
	if len(args) != 1 {
		return MakeErrorResult("\u0049\u0053\u004e\u0041\u0020\u0072\u0065\u0071\u0075\u0069\u0072e\u0073\u0020\u006f\u006e\u0065\u0020\u0061\u0072\u0067\u0075m\u0065\u006e\u0074")
	}
	return MakeBoolResult(args[0].Type == ResultTypeError && args[0].ValueString == "\u0023\u004e\u002f\u0041")
}

// NewPrefixVerticalRange constructs a new full columns range with prefix.
func NewPrefixVerticalRange(pfx Expression, v string) Expression {
	_bgdd := _gg.Split(v, "\u003a")
	if len(_bgdd) != 2 {
		return nil
	}
	if _bgdd[0] > _bgdd[1] {
		_bgdd[0], _bgdd[1] = _bgdd[1], _bgdd[0]
	}
	return PrefixVerticalRange{_ggdbe: pfx, _cagbb: _bgdd[0], _baae: _bgdd[1]}
}

// Choose implements the Excel CHOOSE function.
func Choose(args []Result) Result {
	if len(args) < 2 {
		return MakeErrorResult("\u0043\u0048O\u004f\u0053\u0045\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006den\u0074\u0073")
	}
	_bbege := args[0]
	if _bbege.Type != ResultTypeNumber {
		return MakeErrorResult("\u0043H\u004f\u004fS\u0045\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073\u0020f\u0069\u0072\u0073\u0074\u0020\u0061r\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074y\u0070\u0065\u0020\u006e\u0075\u006d\u0062\u0065\u0072")
	}
	_bfef := int(_bbege.ValueNumber)
	if _bfef < 1 {
		return MakeErrorResult("\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0068\u006f\u0075\u006c\u0064\u0020\u0062\u0065 \u0061 \u0070\u006f\u0073\u0069\u0074\u0069\u0076\u0065\u0020\u0076\u0061\u006c\u0075\u0065")
	}
	if len(args) <= _bfef {
		return MakeErrorResult("\u0049\u006e\u0064\u0065\u0078\u0020\u0073\u0068\u006f\u0075\u006cd\u0020\u0062\u0065\u0020\u006c\u0065\u0073\u0073 \u006fr\u0020\u0065\u0071\u0075\u0061\u006c\u0020\u0074\u006f\u0020\u0074\u0068\u0065\u0020\u006e\u0075\u006d\u0062e\u0072\u0020\u006f\u0066\u0020\u0076\u0061\u006c\u0075\u0065\u0073")
	}
	return args[_bfef]
}

// Result is the result of a formula or cell evaluation .
type Result struct {
	ValueNumber  float64
	ValueString  string
	ValueList    []Result
	ValueArray   [][]Result
	IsBoolean    bool
	ErrorMessage string
	Type         ResultType
	Ref          Reference
}

// Update updates the horizontal range references after removing a row/column.
func (_ffec HorizontalRange) Update(q *_de.UpdateQuery) Expression { return _ffec }

// Left implements the Excel LEFT(string,[n]) function which returns the
// leftmost n characters.
func Left(args []Result) Result {
	_ccgbd := 1
	switch len(args) {
	case 1:
	case 2:
		if args[1].Type != ResultTypeNumber {
			return MakeErrorResult("\u004c\u0045F\u0054\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020\u0061\u0072\u0067\u0075me\u006e\u0074")
		}
		_ccgbd = int(args[1].ValueNumber)
		if _ccgbd < 0 {
			return MakeErrorResult("\u004c\u0045\u0046T \u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020n\u0075m\u0062e\u0072 \u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u003e\u003d\u0020\u0030")
		}
		if _ccgbd == 0 {
			return MakeStringResult("")
		}
	default:
		return MakeErrorResult("\u004c\u0045\u0046T \u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020o\u006ee\u0020o\u0072 \u0074\u0077\u006f\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	if args[0].Type == ResultTypeList {
		return MakeErrorResult("\u004c\u0045\u0046T\u0020\u0063\u0061\u006e'\u0074\u0020\u0062\u0065\u0020\u0063\u0061l\u006c\u0065\u0064\u0020\u006f\u006e\u0020\u0061\u0020\u0072\u0061\u006e\u0067\u0065")
	}
	_ddfc := args[0].Value()
	if _ccgbd > len(_ddfc) {
		return MakeStringResult(_ddfc)
	}
	return MakeStringResult(_ddfc[0:_ccgbd])
}
func (_dabbf VerticalRange) verticalRangeReference() string {
	return _c.Sprintf("\u0025\u0073\u003a%\u0073", _dabbf._dcac, _dabbf._ddef)
}
func _eddg(_adcdd, _efda float64) bool { return _gfc.Abs(_adcdd-_efda) < 1.0e-6 }

const _adaa int = 0

// Index implements the Excel INDEX function.
func Index(args []Result) Result {
	_gegc := len(args)
	if _gegc < 2 || _gegc > 3 {
		return MakeErrorResult("\u0049\u004e\u0044E\u0058\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073\u0020\u0066\u0072\u006f\u006d\u0020\u006f\u006e\u0065\u0020\u0074\u006f\u0020\u0074\u0068\u0072\u0065\u0065\u0020a\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0073")
	}
	_fcgb := args[0]
	if _fcgb.Type != ResultTypeArray && _fcgb.Type != ResultTypeList {
		return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069r\u0065\u0073\u0020\u0066i\u0072\u0073\u0074\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074\u0020\u006f\u0066\u0020\u0074\u0079\u0070\u0065\u0020\u0061\u0072\u0072\u0061\u0079")
	}
	_befec := args[1].AsNumber()
	if _befec.Type != ResultTypeNumber {
		return MakeErrorResult("I\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u006e\u0075\u006d\u0065\u0072\u0069\u0063 \u0072\u006f\u0077\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
	}
	_ccdf := int(_befec.ValueNumber) - 1
	_gdee := -1
	if _gegc == 3 && args[2].Type != ResultTypeEmpty {
		_acabb := args[2].AsNumber()
		if _acabb.Type != ResultTypeNumber {
			return MakeErrorResult("I\u004e\u0044\u0045\u0058\u0020\u0072e\u0071\u0075\u0069\u0072\u0065\u0073 \u006e\u0075\u006d\u0065\u0072\u0069\u0063 \u0063\u006f\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065n\u0074")
		}
		_gdee = int(_acabb.ValueNumber) - 1
	}
	if _ccdf == -1 && _gdee == -1 {
		return MakeErrorResult("\u0049\u004e\u0044EX\u0020\u0072\u0065\u0071\u0075\u0069\u0072\u0065\u0073 \u0072o\u0077 \u006fr\u0020\u0063\u006f\u006c\u0020\u0061\u0072\u0067\u0075\u006d\u0065\u006e\u0074")
	}
	var _gfdfc []Result
	if _fcgb.Type == ResultTypeArray {
		_egb := _fcgb.ValueArray
		if _ccdf < -1 || _ccdf >= len(_egb) {
			return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0072o\u0077\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
		}
		if _ccdf == -1 {
			if _gdee >= len(_egb[0]) {
				return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
			}
			_ffgc := [][]Result{}
			for _, _baea := range _egb {
				_dfbf := _baea[_gdee]
				if _dfbf.Type == ResultTypeEmpty {
					_dfbf = MakeNumberResult(0)
				}
				_ffgc = append(_ffgc, []Result{_dfbf})
			}
			return MakeArrayResult(_ffgc)
		}
		_gfdfc = _egb[_ccdf]
	} else {
		_afgcg := _fcgb.ValueList
		if _ccdf < -1 || _ccdf >= 1 {
			return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0072o\u0077\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
		}
		if _ccdf == -1 {
			if _gdee >= len(_afgcg) {
				return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
			}
			_ecgd := _afgcg[_gdee]
			if _ecgd.Type == ResultTypeEmpty {
				_ecgd = MakeNumberResult(0)
			}
			return _ecgd
		}
		_gfdfc = _afgcg
	}
	if _gdee < -1 || _gdee > len(_gfdfc) {
		return MakeErrorResult("\u0049\u004e\u0044\u0045\u0058\u0020\u0068\u0061\u0073\u0020\u0063o\u006c\u0020\u006f\u0075\u0074\u0020\u006f\u0066\u0020\u0072a\u006e\u0067\u0065")
	}
	if _gdee == -1 {
		_gfaec := []Result{}
		for _, _cgbeg := range _gfdfc {
			if _cgbeg.Type == ResultTypeEmpty {
				_gfaec = append(_gfaec, MakeNumberResult(0))
			} else {
				_gfaec = append(_gfaec, _cgbeg)
			}
		}
		return MakeArrayResult([][]Result{_gfaec})
	}
	_febd := _gfdfc[_gdee]
	if _febd.Type == ResultTypeEmpty {
		return MakeNumberResult(0)
	}
	return _febd
}

// MaxIfs implements the MAXIFS function.
func MaxIfs(args []Result) Result {
	_ffdgf := _dcfg(args, true, "\u004d\u0041\u0058\u0049\u0046\u0053")
	if _ffdgf.Type != ResultTypeEmpty {
		return _ffdgf
	}
	_bdbcc := _gcae(args[1:])
	_fgaa := -_gfc.MaxFloat64
	_beeda := _bbcd(args[0])
	for _, _edbg := range _bdbcc {
		_edaa := _beeda[_edbg._gefg][_edbg._facdg].ValueNumber
		if _fgaa < _edaa {
			_fgaa = _edaa
		}
	}
	if _fgaa == -_gfc.MaxFloat64 {
		_fgaa = 0
	}
	return MakeNumberResult(float64(_fgaa))
}
